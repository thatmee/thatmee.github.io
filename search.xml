<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Haskell语言学习笔记（一）</title>
      <link href="2021/08/07/Haskell%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>2021/08/07/Haskell%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>学习Haskell函数式编程语言，第一部分，基础知识和基本函数语法。<span id="more"></span></p><h1 id="基础知识"><span class="post-title-index">1 </span><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="语法清单"><span class="post-title-index">1.1 </span><a href="#语法清单" class="headerlink" title="语法清单"></a>语法清单</h2><ul><li><font color="c7254e"><code>let a = 7</code></font>：let 用于定义常量，常量名、函数名必须首字母小写</li></ul><h2 id="List、德州区间和-List-Comprehension"><span class="post-title-index">1.2 </span><a href="#List、德州区间和-List-Comprehension" class="headerlink" title="List、德州区间和 List Comprehension"></a>List、德州区间和 List Comprehension</h2><h3 id="List"><span class="post-title-index">1.2.1 </span><a href="#List" class="headerlink" title="List"></a>List</h3><p>List是一种单类型的数据结构，可以用来存储多个<font color="blue"><strong>类型相同</strong></font>的元素。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> lostNumbers = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; lostNumbers    </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>] </span><br></pre></td></tr></table></figure><p>如上，一个List由方括号括起，其中的元素用逗号分隔开来。</p><ul><li><p><font color="c7254e"><code>&quot;hello&quot; ++ &quot; &quot; ++ &quot;world&quot;</code></font> 得到 <font color="c7254e"><code>&quot;hello world&quot;</code></font>：++运算符，用于连接两个List</p></li><li><p><font color="c7254e"><code>5:[1,2,3,4,5]</code></font> 得到 <font color="c7254e"><code>[5,1,2,3,4,5]</code></font>：使用:运算符往一个List前端插入元素</p></li><li><p><font color="c7254e"><code>&quot;Steve Buscemi&quot; !! 6</code></font> 得到  <font color="c7254e"><code>B</code></font>：使用!!运算符按照索引取得List中的元素</p></li><li>用&gt; &lt; &gt;= = 等符号进行List间的比较</li><li>其余常用函数参见 <a href="https://www.w3cschool.cn/hsriti/y2biqozt.html">第二章 Haskell入门_w3cschool</a></li></ul><h3 id="德州区间"><span class="post-title-index">1.2.2 </span><a href="#德州区间" class="headerlink" title="德州区间"></a>德州区间</h3><p>区间（Range）是构造 List 方法之一，而其中的值必须是可枚举的，如1、2、3，A、B、C等。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1.</span><span class="number">.20</span>]   <span class="comment">--简单的区间</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>,<span class="number">4.</span><span class="number">.20</span>] <span class="comment">--带步长的区间</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])   <span class="comment">--cycle用于循环单个List</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (repeat <span class="number">5</span>)        <span class="comment">--repeat用于循环单个值</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="List-Comprehension"><span class="post-title-index">1.2.3 </span><a href="#List-Comprehension" class="headerlink" title="List Comprehension"></a>List Comprehension</h3><p>List Comprehension能够更加方便自由地生成List，类似于集合的描述法：</p><script type="math/tex; mode=display">\{x\ |\ x∈Z\}</script><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]   <span class="comment">--前10个整数</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50.</span><span class="number">.100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>] <span class="comment">--取50到100间所有除7的余数为3的元素</span></span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]] <span class="comment">--从多个List中取元素</span></span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure><h2 id="Tuple"><span class="post-title-index">1.3 </span><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Tuple （元组）要求你对需要组合的数据的数目非常的明确，它的类型取决于其中<font color="blue"><strong>项的数目</strong></font>与其<font color="blue"><strong>各自的类型</strong></font>。 Tuple 中的项由括号括起，并由逗号隔开。另外，Tuple 中的项不必为同一类型，在 Tuple 里可以存入<font color="blue"><strong>多类型</strong></font>项的组合。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fst (<span class="number">8</span>,<span class="number">11</span>)   <span class="comment">--返回一个序对的首项</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; snd (<span class="number">8</span>,<span class="number">11</span>)   <span class="comment">--返回一个序对的尾项</span></span><br><span class="line"><span class="number">11</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上述两个函数仅对序对有效，而不能应用于三元组，四元组和五元组之上。</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]   <span class="comment">--zip 生成一组序对的List</span></span><br><span class="line">[(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">5</span>)]  </span><br></pre></td></tr></table></figure><h2 id="类型和类型类"><span class="post-title-index">1.4 </span><a href="#类型和类型类" class="headerlink" title="类型和类型类"></a>类型和类型类</h2><ul><li><p><a href="https://www.w3cschool.cn/hsriti/h72qkozt.html">第三章 Haskell类型和类型类_w3cschool</a></p></li><li><p>Haskell 的类型必须是首字母大写</p></li><li><p>使用:t命令后跟任何可用的表达式，可以检测表达式的类型</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t &#x27;a&#x27;   </span><br><span class="line">&#x27;a&#x27; :: <span class="type">Char</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">True</span>   </span><br><span class="line"><span class="type">True</span> :: <span class="type">Bool</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="string">&quot;HELLO!&quot;</span>   </span><br><span class="line"><span class="string">&quot;HELLO!&quot;</span> :: [<span class="type">Char</span>]   <span class="comment">--[char] &lt;=&gt; String</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t (<span class="type">True</span>, &#x27;a&#x27;)   </span><br><span class="line">(<span class="type">True</span>, &#x27;a&#x27;) :: (<span class="type">Bool</span>, <span class="type">Char</span>)   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="number">4</span> == <span class="number">5</span>   </span><br><span class="line"><span class="number">4</span> == <span class="number">5</span> :: <span class="type">Bool</span></span><br></pre></td></tr></table></figure></li><li><p>定义函数时，可以定义参数和返回值类型，参数之间以及参数和返回值之间均使用<font color="c7254e"><code>-&gt;</code></font>分隔</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>   <span class="comment">--三个参数，一个返回值</span></span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数语法"><span class="post-title-index">2 </span><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h1><h2 id="函数声明方法"><span class="post-title-index">2.1 </span><a href="#函数声明方法" class="headerlink" title="函数声明方法"></a>函数声明方法</h2><ul><li><p>函数声明：先<font color="blue"><strong>函数名</strong></font>，后跟由空格分隔的<font color="blue"><strong>参数表</strong></font>。声明中一定要在<font color="c7254e"><code>=</code></font>后面定义函数的<font color="blue"><strong>行为</strong></font></p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleMe</span> x = x + x  <span class="comment">--功能：将一个数字乘以2</span></span><br></pre></td></tr></table></figure></li><li><p>可以在其他函数中调用自己编写的函数，不用考虑函数出现的先后顺序</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleUs</span> x y = doubleMe x + doubleMe y  <span class="comment">--功能：接收两个参数，返回它们的和的2倍</span></span><br></pre></td></tr></table></figure></li><li><p>为函数编写明确的类型声明是一个好习惯</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--功能：过滤大写字母</span></span><br><span class="line"><span class="title">removeNonUppercase</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]   </span><br><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c  st, c `elem` [&#x27;<span class="type">A&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">--功能：三个整数相加</span></span><br><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>   </span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure></li></ul><h2 id="模式匹配"><span class="post-title-index">2.2 </span><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配通过检查数据的特定结构来检查其是否匹配，并按模式从中取得数据。类似于<font color="c7254e"><code>switch...case...</code></font>结构。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">&quot;One!&quot;</span>   <span class="comment">--这里 “1” 是参数</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">&quot;Two!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">&quot;Three!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">&quot;Four!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">&quot;Five!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">&quot;Not between 1 and 5&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">--如果把最后匹配一切的那个模式挪到最前，它的结果就全都是&quot;Not between 1 and 5&quot;</span></span><br></pre></td></tr></table></figure><p>【<strong>注意</strong>】</p><ul><li>不可以在模式匹配中使用 <font color="c7254e"><code>++</code></font></li></ul><h3 id="对Tuple使用模式匹配"><span class="post-title-index">2.2.1 </span><a href="#对Tuple使用模式匹配" class="headerlink" title="对Tuple使用模式匹配"></a>对Tuple使用模式匹配</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--不会模式匹配的时候</span></span><br><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> a b = (fst a + fst b, snd a + snd b) </span><br><span class="line"></span><br><span class="line"><span class="comment">--一个更好的方法</span></span><br><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  </span><br></pre></td></tr></table></figure><p>用模式匹配实现针对三元组的first、second、third函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a   </span><br><span class="line"><span class="title">first</span> (x, _, _) = x        </span><br><span class="line"><span class="comment">--&quot;_&quot;表示我们不关心这部分的具体内容</span></span><br><span class="line"></span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b   </span><br><span class="line"><span class="title">second</span> (_, y, _) = y   </span><br><span class="line"></span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c   </span><br><span class="line"><span class="title">third</span> (_, _, z) = z </span><br></pre></td></tr></table></figure><h3 id="在List-Comprehension中使用模式匹配"><span class="post-title-index">2.2.2 </span><a href="#在List-Comprehension中使用模式匹配" class="headerlink" title="在List Comprehension中使用模式匹配"></a>在List Comprehension中使用模式匹配</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> xs = [(<span class="number">1</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">5</span>,<span class="number">3</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">1</span>)]   </span><br><span class="line"><span class="title">ghci</span>&gt; [a+b | (a,b)  xs]   </span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>一旦模式匹配失败，它就简单挪到下个元素。</p><h3 id="对List使用模式匹配"><span class="post-title-index">2.2.3 </span><a href="#对List使用模式匹配" class="headerlink" title="对List使用模式匹配"></a>对List使用模式匹配</h3><p>用<font color="c7254e"><code>[]</code></font>或<font color="c7254e"><code>:</code></font>来匹配List。例如：</p><ul><li><font color="c7254e"><code>x:xs</code></font>模式，可以将list的头部绑定为x，尾部绑定为xs，但这种模式只能匹配长度<font color="blue"><strong>大于等于1</strong></font>的List，因此对于空的List需要进行特殊判断。</li><li><font color="c7254e"><code>x:y:z:xs</code></font>模式，可以将List的前三个元素都绑定到变量中，但只能匹配长度<font color="blue"><strong>大于等于3</strong></font>的List，因此对于长度小于3的List需要进行特殊判断。</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--实现一个自己的 head 函数</span></span><br><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a   </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span></span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x  </span><br></pre></td></tr></table></figure><h3 id="as模式"><span class="post-title-index">2.2.4 </span><a href="#as模式" class="headerlink" title="as模式"></a>as模式</h3><font color="c7254e">`as`</font>模式，就是将一个名字和<font color="c7254e">`@`</font>置于模式前，可以在按模式分割什么东西时仍保留对其整体的引用。如这个模式<font color="c7254e">`xs@(x:y:ys)`</font>，它会匹配出与<font color="c7254e">`x:y:ys`</font>对应的东西，同时你也可以方便地通过<font color="c7254e">`xs`</font>得到整个list，而不必在函数体中重复<font color="c7254e">`x:y:ys`</font>。<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--代码--</span></span><br><span class="line"><span class="title">capital</span> :: <span class="type">String</span> -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">capital</span> <span class="string">&quot;&quot;</span> = <span class="string">&quot;Empty string, whoops!&quot;</span>   </span><br><span class="line"><span class="title">capital</span> all@(x:xs) = <span class="string">&quot;The first letter of &quot;</span> ++ all ++ <span class="string">&quot; is &quot;</span> ++ [x] </span><br><span class="line"></span><br><span class="line"><span class="comment">--执行结果--</span></span><br><span class="line"><span class="title">ghci</span>&gt; capital <span class="string">&quot;Dracula&quot;</span>   </span><br><span class="line"><span class="string">&quot;The first letter of Dracula is D&quot;</span></span><br></pre></td></tr></table></figure>## 门卫<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--一个用到了门卫的函数--</span></span><br><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">bmiTell</span> bmi   </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>   </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span></span><br></pre></td></tr></table></figure>- 门卫由跟在函数名及参数后面的<font color="blue">**竖线**</font>标志，通常他们都是靠右一个缩进排成一列。一个门卫就是<font color="blue">**一个布尔表达式**</font>，如果为真，就使用其对应的函数体。如果为假，就送去见下一个门卫，如之继续。- 如果一个函数的所有门卫都没有通过（而且没有提供otherwise作万能匹配），就转入下一模式。这便是门卫与模式契合的地方。如果始终没有找到合适的门卫或模式，就会发生一个错误。## where绑定<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用where关键字从而避免重复工作</span></span><br><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">bmiTell</span> weight height   </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>   </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>   </span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>- where关键字跟在门卫后面（最好是与竖线缩进一致）。- 可以定义多个名字和函数，这些名字对每个门卫都是可见的。- 函数在where绑定中定义的名字只对本函数可见，因此我们不必担心它会污染其他函数的命名空间。- where绑定不会在多个模式中共享。如果你在一个函数的多个模式中重复用到同一名字，就应该把它置于全局定义之中。- where绑定也可以使用**模式匹配**    <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...   </span><br><span class="line"><span class="title">where</span> bmi = weight / height ^ <span class="number">2</span>   </span><br><span class="line">      (skinny, normal, fat) = (<span class="number">18.5</span>, <span class="number">25.0</span>, <span class="number">30.0</span>) </span><br></pre></td></tr></table></figure>## let绑定<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--依据半径和高度求圆柱体表面积--</span></span><br><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a   </span><br><span class="line"><span class="title">cylinder</span> r h =  </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h   </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>   </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br></pre></td></tr></table></figure>let的格式为<font color="c7254e">`let [bindings] in [expressions]`</font>。在let中绑定的名字仅对in部分可见。let里面定义的名字也得对齐到一列。> <font color="blue">**let绑定和where绑定的区别：**</font>>> <font color="blue">**（1）where绑定是个语法结构，let绑定是个表达式，可以随处安放（就像if语句一样）。**</font>>> <font color="blue">**（2）let定义域限制的相当小，因此不能在多个门卫中使用。where跟在函数体后面，主函数体距离类型声明近一些，会更易读。**</font><ul><li><p>let可以定义<strong>局部函数</strong></p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]  </span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)] </span><br></pre></td></tr></table></figure></li><li><p>若要在一行中<strong>绑定多个名字</strong>，可以用分号将其分开</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> a = <span class="number">100</span>; b = <span class="number">200</span>; c = <span class="number">300</span> <span class="keyword">in</span> a*b*c, <span class="keyword">let</span> foo=<span class="string">&quot;Hey &quot;</span>; bar = <span class="string">&quot;there!&quot;</span> <span class="keyword">in</span> foo ++ bar)  </span><br><span class="line">(<span class="number">6000000</span>,<span class="string">&quot;Hey there!&quot;</span>) </span><br></pre></td></tr></table></figure></li><li><p>可以在let绑定中使用<strong>模式匹配</strong>。这在从Tuple取值之类的操作中很方便。</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> (a,b,c) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">in</span> a+b+c) * <span class="number">100</span>  </span><br><span class="line"><span class="number">600</span> </span><br></pre></td></tr></table></figure></li><li><p>也可以把let绑定放到<strong>List Comprehension</strong>中。我们重写下那个计算bmi值的函数，用个let替换掉原先的where。</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi | (w, h) xs, <span class="keyword">let</span> bmi = w / h ^ <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li></ul><h2 id="case表达式"><span class="post-title-index">2.3 </span><a href="#case表达式" class="headerlink" title="case表达式"></a>case表达式</h2><p>模式匹配本质上不过就是case语句的语法糖而已。这两段代码就是完全等价的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x </span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a   </span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;No head for empty lists!&quot;</span>   </span><br><span class="line">                      (x:_) -&gt; x  </span><br></pre></td></tr></table></figure><p><strong>case表达式的语法：</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result   </span><br><span class="line">                   pattern -&gt; result   </span><br><span class="line">                   pattern -&gt; result   </span><br><span class="line">                   ...  </span><br></pre></td></tr></table></figure><blockquote><font color="blue">**case表达式和模式匹配的区别：**</font><p>​        <font color="blue"><strong>函数参数的模式匹配只能在定义函数时使用，而case表达式可以用在任何地方</strong></font></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
          <category> 语言学习 </category>
          
          <category> Haskell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络LAB_1——数据链路层协议实现</title>
      <link href="2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CLAB_1%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/"/>
      <url>2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CLAB_1%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本次实验的整理，包括LAB文档内容梳理和实验报告。<span id="more"></span></p><h1 id="LAB文档内容梳理"><span class="post-title-index">1 </span><a href="#LAB文档内容梳理" class="headerlink" title="LAB文档内容梳理"></a>LAB文档内容梳理</h1><h2 id="样例程序分析"><span class="post-title-index">1.1 </span><a href="#样例程序分析" class="headerlink" title="样例程序分析"></a>样例程序分析</h2><h3 id="datalink-h"><span class="post-title-index">1.1.1 </span><a href="#datalink-h" class="headerlink" title="datalink.h"></a>datalink.h</h3><p>首先定义了帧的种类，在数据链路层传递的所有帧，分为数据帧、ACK（确认）帧、NAK（否定确认）帧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FRAME kind */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_DATA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_ACK  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_NAK  3</span></span><br></pre></td></tr></table></figure><p>之后给出了三种帧的具体结构，小括号内是该段信息的大小，单位为字节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    DATA Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | SEQ(1) | ACK(1) | DATA(240~256) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ACK Frame</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">| KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NAK Frame</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">| KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>KIND： 1字节，表示这个帧的种类（可取1,2,3）</p><p>SEQ：   1字节，数据帧序号，如果类型为unsigned char，可表示的范围是 0 ~ 255</p><p>ACK：   ACK帧或NAK帧的序号</p><p>DATA：数据帧中的数据段</p><p>CRC：   冗余码部分</p><h2 id="事件"><span class="post-title-index">1.2 </span><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="五种事件类型"><span class="post-title-index">1.2.1 </span><a href="#五种事件类型" class="headerlink" title="五种事件类型"></a>五种事件类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETWORK_LAYER_READY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSICAL_LAYER_READY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_RECEIVED 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMEOUT 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMEOUT 4</span></span><br></pre></td></tr></table></figure><p><strong>NETWORK_LAYER_READY：</strong><br>当网络层有新的分组需要发送并且未被链路层disable，会产生NETWORK_LAYER_READY事件；否则网络层自行缓冲待发送分组。此事件发生后才可以调用get_packet()得到网络层待发送的下一个分组。</p><p><strong>PHYSICAL_LAYER_READY：</strong><br>物理层发送队列的长度低于50字节。（3.3）</p><p><strong>FRAME_RECEIVED：</strong><br>物理层收到了一整帧 。</p><p><strong>DATA_TIMEOUT：</strong><br>超时发生时，产生 DATA_TIMEOUT事件， 并给出超时的定时器编号。<strong>发生超时的定时器的编号在参数 arg中返回。</strong></p><p><strong>ACK_TIMEOUT：</strong><br>所设置的搭载ACK定时器超时。</p><h3 id="程序流程示意"><span class="post-title-index">1.2.2 </span><a href="#程序流程示意" class="headerlink" title="程序流程示意"></a>程序流程示意</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enable_network_layer</span>();</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">event = <span class="built_in">wait_for_event</span>(&amp;arg);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (event) &#123;</span><br><span class="line"><span class="keyword">case</span> EVENT_NETWORK_LAYER_READY:</span><br><span class="line">len = <span class="built_in">get_packet</span>(my_buf);</span><br><span class="line">… …</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_PHYSICAL_LAYER_READY:</span><br><span class="line">… …</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_FRAME_RECEIVED:</span><br><span class="line">rbuf_len = <span class="built_in">recv_frame</span>(rbuf, <span class="keyword">sizeof</span> rbuf);</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_ACK_TIMEOUT:</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_DATA_TIMEOUT:</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line"><span class="built_in">enable_network_layer</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">disable_network_layer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口函数及库函数"><span class="post-title-index">1.3 </span><a href="#接口函数及库函数" class="headerlink" title="接口函数及库函数"></a>接口函数及库函数</h2><h3 id="初始化协议"><span class="post-title-index">1.3.1 </span><a href="#初始化协议" class="headerlink" title="初始化协议"></a>初始化协议</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void protocol<span class="constructor">_init(<span class="params">int</span> <span class="params">argc</span>, <span class="params">char</span> <span class="operator">**</span><span class="params">argv</span>)</span>;</span><br></pre></td></tr></table></figure><p>必须首先调用此函数对运行环境初始化。该函数的两个参数必<br>须传递 main()函数的两个同名参数。这样做的目的是从命令行参数中获取站点名及某些选项以提供一种配置系统参数的手段。这些 选项包括 重新 指定日志文件，指定 TCP端口号， 设定误码率，等等。当命令行中重新指定了新的参数值，默认值就不再起作用。</p><p>protocol_init()建立两个站点之间的 TCP连接，并且设定时间坐标的 参考 0点，通信的两个站点的时间坐标 0点在建立 TCP连接时被设置成相同的参考时间点 。</p><p>输出样例：</p><p><img src="https://i.loli.net/2021/05/06/pZ3XQuv2S6qxGBy.png" alt="image-20210505142308591.png"></p><h3 id="网络层接口"><span class="post-title-index">1.3.2 </span><a href="#网络层接口" class="headerlink" title="网络层接口"></a>网络层接口</h3><h4 id="网络层包长度"><span class="post-title-index">1.3.2.1 </span><a href="#网络层包长度" class="headerlink" title="网络层包长度"></a>网络层包长度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKT_LEN 256</span></span><br></pre></td></tr></table></figure><h4 id="流量控制函数"><span class="post-title-index">1.3.2.2 </span><a href="#流量控制函数" class="headerlink" title="流量控制函数"></a>流量控制函数</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_network_layer</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">disable_network_layer</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>对于发送方向来说，网络层和数据链路层的约定为：数据链路层在缓冲区满等条件下无法发送分组<br>时通过 disable_network_layer()通知网络层；在能够承接新的发送任务时执行<br>enable_network_layer()允许网络层发送 数据 分组</p><h4 id="包处理函数"><span class="post-title-index">1.3.2.3 </span><a href="#包处理函数" class="headerlink" title="包处理函数"></a>包处理函数</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> get<span class="constructor">_packet(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">packet</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：将分组拷贝到指针 p指定的缓冲区中。</p><p>返回值：分组长度</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void put<span class="constructor">_packet(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">packet</span>, <span class="params">int</span> <span class="params">len</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：存放收到分组的缓冲区首地址，分组长度</p><blockquote><p><strong>统计功能：</strong></p><p>如果本次调用 put_packet()函数 比上次调用该函数的时间间隔超过 2秒，将给出一个接收方向的报告，格式如下所示：</p><p>480.484 …. 1784 packets received, 7611 bps, 95.14%, Err 38 (9.9e 006)</p><p>时间坐标为480.484秒，收到了 1784个分组，网络层有效数据传输率 7611bps，实际线路利用率95.14%，接收方向共检出 38个帧校验和错误，统计计算出实际误码率 9.9x10 6。</p></blockquote><h3 id="物理层接口"><span class="post-title-index">1.3.3 </span><a href="#物理层接口" class="headerlink" title="物理层接口"></a>物理层接口</h3><h4 id="帧处理函数"><span class="post-title-index">1.3.3.1 </span><a href="#帧处理函数" class="headerlink" title="帧处理函数"></a>帧处理函数</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void send<span class="constructor">_frame(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">frame</span>, <span class="params">int</span> <span class="params">len</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：将内存 frame处长度为 len的缓冲区块向物理层发送为一帧，每字节发送需要 1ms，帧与帧之间的边界保留 1ms。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> recv<span class="constructor">_frame(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">size</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：从物理层接收一帧， size为用于存放接收帧的缓冲区 buf的空间大小</p><p>返回值：收到帧的实际长度 。</p><h4 id="查看队列长度"><span class="post-title-index">1.3.3.2 </span><a href="#查看队列长度" class="headerlink" title="查看队列长度"></a>查看队列长度</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phl_sq_len</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数返回当前物理层队列的长度 。</p><h4 id="流量控制机制"><span class="post-title-index">1.3.3.3 </span><a href="#流量控制机制" class="headerlink" title="流量控制机制"></a>流量控制机制</h4><p>为协调数据链路层和物理层之间的流量，采用的机制是：只要在事件处理周期内至少一次调用过 send_frame()函数，那么，事件等待函数 wait_for_event()会在物理层发送队列低于50字节水平时，产生 PHYSICAL_LAYER_READY事件。</p><blockquote><p>例如：物理层当前队列长度 20字节，链路层调用send_frame()发送一 7字节 帧，那么，随后的事件等待函数 wait_for_event()会立即产生PHYSICAL_LAYER_READY事件；再如：物理层当前队列长度 40字节，链路层调用 send_frame()发送一300字节字节帧帧，受限于信道受限于信道8000bps的带宽，需要发送的数据不可能瞬间发送到线路上，的带宽，需要发送的数据不可能瞬间发送到线路上，wait_for_event()会在物理层队列由会在物理层队列由340字节降为字节降为50字节以下（至少需要字节以下（至少需要290毫秒）毫秒）后才产生后才产生PHYSICAL_LAYER_READY事件。</p></blockquote><p>在PHYSICAL_LAYER_READY事件后，如果 数据链路层 暂时没有需要发送的数据，因系统不会再次送来 PHYSICAL_LAYER_READY事件，应记录物理层状态，当有数据需要发送时直接发送。 物理层事件的这种处理方式类似于 硬件中的发送中断。</p><p>不顾物理层是否出于准备好状态而 调用 send_frame()发送多帧，受限于信道的 8000bps能力，会导致数据堆积在物理层发送队列的时间较长，等待物理层慢慢把数据发送出去。</p><p><strong>物理层发送队列最多可以保留 64K字节。</strong></p><h3 id="CRC校验的产生和验证"><span class="post-title-index">1.3.4 </span><a href="#CRC校验的产生和验证" class="headerlink" title="CRC校验的产生和验证"></a>CRC校验的产生和验证</h3><p>本次实验采用的CRC校验方案为 CRC 32，与 IEEE 802.3以太网校验和生成多项式相同。生成多项式为：<br>x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">crc32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>函数crc32()返回一 个 32比特整数。</p><blockquote><p>设指针 p的定义为 char * p并且 p指向一个缓冲区，缓冲区内有 243字节数据，为这 243字节数据生成 CRC 32校验和，并且把这 32比特校验和附在 243字节之后，执行下面的语句：(unsigned int *)(p + 243) = crc32(p, 243);<br><strong>注意：</strong><br>p所指缓冲区必须至少有 247字节有效空间，以防内存访问越界。</p></blockquote><blockquote><p>验证校验和的方法，对上面的例子，只需要判断crc32(p, 243 + 4)是否为 0：<br>校验和正确为 0，否则不为 0。</p></blockquote><h3 id="定时器管理"><span class="post-title-index">1.3.5 </span><a href="#定时器管理" class="headerlink" title="定时器管理"></a>定时器管理</h3><h4 id="get-ms"><span class="post-title-index">1.3.5.1 </span><a href="#get-ms" class="headerlink" title="get_ms"></a>get_ms</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_ms</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>get_ms()函数获取当前的时间坐标，单位为毫秒。</p><h4 id="start-timer"><span class="post-title-index">1.3.5.2 </span><a href="#start-timer" class="headerlink" title="start_timer"></a>start_timer</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start<span class="constructor">_timer(<span class="params">unsigned</span> <span class="params">int</span> <span class="params">nr</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">ms</span>)</span>;</span><br></pre></td></tr></table></figure><p>start_timer()用于启动一个定时器。</p><p><strong>参数：</strong>计时器的编号，超时时间值。计时器的编号只允许在0~63之间，超时时间间隔的单位为毫秒。</p><p>超时发生时，产生 DATA_TIMEOUT事件， 并给出超时的定时器编号。<strong>发生超时的定时器的编号在参数 arg中返回。</strong></p><blockquote><p>例如： start_timer(3, 1200)启动 3号定时器，定时器的长度为 1.2秒 。</p></blockquote><p>系统在把截止到调用函数start_timer()时刻为止已经放入物理层发送队列的数据发送完毕后才开始启动计时（不是从当前时间开始计时）。</p><blockquote><p>例如：当前时间坐标为 5.100，物理层发送队列目前有 300字节，信道速率 8000bps，函数调用 start_timer(3, 1200)会导致 1.5秒之后 时间坐标 6.600处 3号定时器产生DATA_TIMEOUT事件 。</p></blockquote><p>在定时器未超时之前直接对同一个编号的定时器执行start_timer()调用， 将按照<strong>新的时间</strong>设置产生超时事件。</p><h4 id="stop-timer"><span class="post-title-index">1.3.5.3 </span><a href="#stop-timer" class="headerlink" title="stop_timer"></a>stop_timer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span>;</span><br></pre></td></tr></table></figure><p>stop_timer()中止一个定时器。</p><p><strong>参数：</strong>要终止的定时器的编号</p><h4 id="start-ack-timer"><span class="post-title-index">1.3.5.4 </span><a href="#start-ack-timer" class="headerlink" title="start_ack_timer"></a>start_ack_timer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_ack_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ms)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>与start_timer（3.5.2）的不同之处：</strong></p><ol><li>少了一个参数：定时器编号。意味着只有一个ACK定时器</li><li>ACK计时器启动时刻为当前时刻；</li><li>在ACK定时器未超时之前重新执行 start_ack_timer()调用，定时器将<strong>依然</strong>按照<strong>先前</strong>的时间设置产生超时事件 ACK_TIMEOUT。</li></ol><h4 id="stop-ack-timer"><span class="post-title-index">1.3.5.5 </span><a href="#stop-ack-timer" class="headerlink" title="stop_ack_timer"></a>stop_ack_timer</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_ack_timer</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>终止ACK计时器。</p><h3 id="跟踪、调试和输出"><span class="post-title-index">1.3.6 </span><a href="#跟踪、调试和输出" class="headerlink" title="跟踪、调试和输出"></a>跟踪、调试和输出</h3><h4 id="对printf的改良"><span class="post-title-index">1.3.6.1 </span><a href="#对printf的改良" class="headerlink" title="对printf的改良"></a>对printf的改良</h4><p>lprintf()函数</p><h4 id="debug输出"><span class="post-title-index">1.3.6.2 </span><a href="#debug输出" class="headerlink" title="debug输出"></a>debug输出</h4><ol><li><p><strong>debug_mask变量</strong></p><p> 一个静态整型变量，用于调试信息的输出控制，默认值为0。</p></li><li><p><strong>dbg_frame, dbg_event, dbg_warning</strong></p><p> 用 debug_mask的比特 0控制“事件”信息，比特 1控制“帧收发”信息：</p><p> 当 debug_mask的 0号比特为 0时，dbg_event()的所有输出被忽略；</p><p> 当 debug_mask的 1号比特为 0时，dbg_frame()的所有输出被忽略。</p></li></ol><h4 id="获取站点名"><span class="post-title-index">1.3.6.3 </span><a href="#获取站点名" class="headerlink" title="获取站点名"></a>获取站点名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">station_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>此函数获取当前进程所对应的站点名，返回值为字符串 ”A”或者 ”B”。</p><h2 id="命令行选项"><span class="post-title-index">1.4 </span><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h2><p><img src="https://i.loli.net/2021/05/06/P1q6UxWy9zfcAJZ.png" alt="image-20210505141428458.png"></p><h2 id="错误信息"><span class="post-title-index">1.5 </span><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p><img src="https://i.loli.net/2021/05/06/TkN1AXZevEKlsQx.png" alt="image-20210505141514462.png"></p><h2 id="问题汇总"><span class="post-title-index">1.6 </span><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li><p><strong>between函数，为什么那么设计</strong></p></li><li><p>ack计时器，为什么只要一个，为什么send_frame之后立刻就stop_ack，start_ack又为什么是在收到帧的时候的操作，而不是发送帧的操作</p><ul><li>ack的计时器，其实是等待捎带ack的计时器。一切都迎刃而解。</li></ul></li><li><p><strong>关于滑动窗口的大小的计算，已经计算出滑动窗口大小&lt;4，为什么还能设为7，设为63？7和63又是如何得到的？</strong></p></li></ul><h1 id="实验报告"><span class="post-title-index">2 </span><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="实验内容及实验环境描述"><span class="post-title-index">2.1 </span><a href="#实验内容及实验环境描述" class="headerlink" title="实验内容及实验环境描述"></a>实验内容及实验环境描述</h2><h3 id="实验内容"><span class="post-title-index">2.1.1 </span><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>​        利用所学数据链路层原理，自己设计一个滑动窗口协议，在仿真环境下编程实现有噪音信道环境下两站点之间无差错双工通信。信道模型为8000bps 全双工卫星信道，信道传播时延270毫秒，信道误码率为10^-5，信道提供字节流传输服务，网络层分组长度固定为256字节。</p><p>​        本次实验选用的滑动窗口协议为带NAK和不带NAK的回退N协议，以及选择重传协议。</p><h3 id="实验环境"><span class="post-title-index">2.1.2 </span><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>​        Windows10，Microsoft Visual Studio 2019，PowerShell</p><h2 id="软件设计"><span class="post-title-index">2.2 </span><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="数据结构"><span class="post-title-index">2.2.1 </span><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="FRAME结构体"><span class="post-title-index">2.2.1.1 </span><a href="#FRAME结构体" class="headerlink" title="FRAME结构体"></a>FRAME结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FRAME</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> kind;            <span class="comment">/*FRAME_DATA, FRAME_ACK, FRAME_NAK*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> seq;             <span class="comment">/*数据帧序号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ack;             <span class="comment">/*ACK帧或NAK帧的序号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[PKT_LEN];   <span class="comment">/*数据帧里的数据部分*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  padding;         <span class="comment">/*CRC冗余码部分*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>三种帧类型的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FRAME kind */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_DATA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_ACK  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_NAK  3</span></span><br></pre></td></tr></table></figure><p>三种帧的具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DATA Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | SEQ(1) | ACK(1) | DATA(240~256) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ACK Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NAK Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="GBN协议宏定义和全局变量"><span class="post-title-index">2.2.1.2 </span><a href="#GBN协议宏定义和全局变量" class="headerlink" title="GBN协议宏定义和全局变量"></a>GBN协议宏定义和全局变量</h4><ul><li><strong>宏定义</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ 7         <span class="comment">//帧序号最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMER 1500   <span class="comment">//数据帧超时时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMER 300     <span class="comment">//等待捎带ACK的时间</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>全局变量</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> frame_expected = <span class="number">0</span>;           <span class="comment">//接受窗口期待接收的序号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[MAX_SEQ + <span class="number">1</span>][PKT_LEN]; <span class="comment">//发送窗口缓存区。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> ack_expected = <span class="number">0</span>;             <span class="comment">//发送窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> next_frame = <span class="number">0</span>;               <span class="comment">//发送窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> nbuffered;                    <span class="comment">//发送窗口缓冲区已使用的数量，已发送的帧数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> phl_ready = <span class="number">0</span>;                          <span class="comment">//物理层就绪标志。（为 1 就绪）</span></span><br><span class="line"><span class="keyword">int</span> no_nak = <span class="number">1</span>;                                    <span class="comment">//NAK有效标志（为 1 有效）</span></span><br></pre></td></tr></table></figure><p>其中：</p><p>① 在GBN协议中，接收窗口大小规定为 1，发送窗口大小 = 帧序号数量 - 1 = 帧序号最大值。</p><p>② 发送窗口缓冲区的作用是：将每个已发送未确认的帧缓存下来，若出现丢包或坏帧则可以重发。因此，缓冲区大小和发送窗口大小相同。</p><h4 id="SR协议宏定义和全局变量"><span class="post-title-index">2.2.1.3 </span><a href="#SR协议宏定义和全局变量" class="headerlink" title="SR协议宏定义和全局变量"></a>SR协议宏定义和全局变量</h4><ul><li><strong>宏定义</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ 63                  <span class="comment">//帧序号最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_BUF ((MAX_SEQ + 1) / 2)  <span class="comment">//接收\发送窗口缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMER 3000             <span class="comment">//数据帧超时时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMER 1000              <span class="comment">//ACK帧超时时间</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>全局变量</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> out_buffer[NR_BUF][PKT_LEN];   <span class="comment">//发送窗口缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> in_buffer[NR_BUF][PKT_LEN];    <span class="comment">//接收窗口缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> ack_expected = <span class="number">0</span>;              <span class="comment">//发送窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> next_frame = <span class="number">0</span>;                <span class="comment">//发送窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> frame_expected = <span class="number">0</span>;            <span class="comment">//接收窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> too_far = NR_BUF;              <span class="comment">//接收窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> nbuffered;                     <span class="comment">//发送窗口缓冲区已使用的数量，已发送的帧数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> phl_ready = <span class="number">0</span>;                           <span class="comment">//物理层就绪标志。（为 1 就绪）</span></span><br><span class="line"><span class="keyword">int</span> no_nak = <span class="number">1</span>;                                     <span class="comment">//NAK有效标志（为 1 有效）</span></span><br><span class="line"><span class="keyword">int</span> arrv[NR_BUF];                                   <span class="comment">//接收窗口缓冲区标志（为 1 表示已占用）</span></span><br></pre></td></tr></table></figure><p>其中：接收\发送窗口缓冲区大小 = 发送窗口大小 = 接收窗口大小</p><h3 id="模块结构"><span class="post-title-index">2.2.2 </span><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><h4 id="子程序说明"><span class="post-title-index">2.2.2.1 </span><a href="#子程序说明" class="headerlink" title="子程序说明"></a>子程序说明</h4><blockquote><p>两个协议的子程序原理、作用及参数等大致相同，不再分开阐述</p></blockquote><ul><li><p><strong>static int between(unsigned char a, unsigned char b, unsigned char c)</strong></p><ul><li>函数作用：判断帧序号是否落在接收\发送窗口内，以此决定接下来的操作（缓存、发送ACK或者丢弃等）</li><li>参数：<ul><li>unsigned char a, unsigned char c：窗口的边界</li><li>unsigned char b：帧序号或ACK序号</li></ul></li><li>返回值：int 类型，若在窗口内，返回true（1），否则返回false（0）</li></ul></li><li><p><strong>char inc(char c)</strong></p><ul><li>函数作用：用于序号的循环有界递增。例如，帧序号最大值为3时，序号只能取 0,1,2,3,0,1,2…</li><li>参数：char c：需要递增的序号值</li><li>返回值：char类型，递增之后的结果</li></ul></li><li><p><em><em>static void put_frame(unsigned char</em> frame, int len)</em>*</p><ul><li>函数作用：为一帧添加CRC校验和，并将这一帧发送给物理层</li><li>参数：<ul><li>unsigned char* frame：指向这一帧的指针</li><li>int len：这一帧的长度，单位为字节</li></ul></li><li>无返回值</li></ul></li><li><p><strong>static void send_data_frame(void)</strong></p><ul><li><p>函数作用：发送数据帧</p></li><li><p>无参数</p><blockquote><p>这里与教材中是不同的，由于本协议实现中使用了大量全局变量，在传参方面省略了很多功夫</p></blockquote></li><li><p>无返回值</p></li></ul></li><li><p><strong>static void send_ack_frame(void)</strong></p><ul><li>函数作用：发送单独ACK帧</li></ul></li><li><p><strong>static void send_nak_frame(void)</strong></p><ul><li>函数作用：发送单独的NAK帧</li></ul></li></ul><h4 id="程序调用关系图"><span class="post-title-index">2.2.2.2 </span><a href="#程序调用关系图" class="headerlink" title="程序调用关系图"></a>程序调用关系图</h4><p><img src="https://i.loli.net/2021/05/06/P5WJxNwhGBRKFlt.png" alt="image-20210505182426979.png"></p><h4 id="响应分析"><span class="post-title-index">2.2.2.3 </span><a href="#响应分析" class="headerlink" title="响应分析"></a>响应分析</h4><ul><li><p><strong>GBN协议</strong></p><p>  <img src="https://i.loli.net/2021/05/06/hwXlKNHo81qUcba.png" alt="image-20210505171554501.png"></p></li><li><p><strong>SR协议</strong></p><p>  <img src="https://i.loli.net/2021/05/06/R9IxP674r3fHYLh.png" alt="image-20210505171638295.png"></p></li></ul><h4 id="算法流程图"><span class="post-title-index">2.2.2.4 </span><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h4><p><img src="https://i.loli.net/2021/05/06/N9k1zYTAbQjwrt2.png" alt="image-20210505182001929.png"></p><h2 id="实验结果分析"><span class="post-title-index">2.3 </span><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p><strong>1.描述你所实现的协议软件是否实现了有误码信道环境中无差错传输功能。</strong></p><p>实现了有误码信道环境中的无差错传输功能，采用了CRC校验和重传技术使错误得以发现和纠正</p><p><strong>2.程序的健壮性如何，能否可靠地长时间运行。</strong></p><p>程序健壮性强，在高负荷和高误码率等条件下均未出现过死锁现象，能够正常运行。线下测试时运行30min左右没有问题。</p><p><strong>3.协议参数的选取：滑动窗口的大小，重传定时器的时限，ACK 搭载定时器的时限，这些参数是怎样确定的？根据信道特性数据，分组层分组的大小，以及你的滑动窗口机制，给出定量分析，详细列举出选择这些参数值的具体原因。</strong></p><p>根据实验模型：8000bps全双工卫星信道，分组长度固定为 256 字节，单向传输时延为270ms，信道误码率（默认）10^-5，帧间间隔1ms。我对两个协议的窗口大小、重传定时器时限和ACK定时器时限进行了理论计算和实际测试。</p><p>①  <strong>滑动窗口的大小：</strong></p><p>滑动窗口大小直接涉及到信道利用率和数据拥塞问题，若窗口太小，将导致信道利用率过低，信道中长时间没有数据传送；若窗口太大，数据发送过快，将造成接收方被数据淹没，发生拥塞现象导致数据丢失，出错率增加。</p><ul><li>首先计算得到滑动窗口的最小值，设滑动窗口的大小 W，信道传输时延 t，数据率 c，帧长度 l 。则应有关系式如下：</li></ul><p>$$<br>W &gt;= [ 2t + 2 * (l/c) ] / (l/c)<br>$$</p><blockquote><p>根据自定义的帧的数据结构可知，一个数据帧最长包括3字节的帧头（kind，seq，ack）、256字节的数据和4字节的 CRC 冗余码，共263字节。即此处l = 263 * 8 bit。代入其他数据计算可得，W &gt;= 4.05。</p></blockquote><ul><li>而滑动窗口的最大值与帧序列有关，设发送窗口大小 Ws，接收窗口大小为Wr，帧序列的二进制位数为 n。则有关系式如下：<br>$$<br>Ws + Wr &lt;= 2^n<br>$$</li></ul><blockquote><p>在帧结构中，帧序列seq为unsigned char类型，大小为1字节，即n = 8。<br>在GBN协议中，Wr = 1，所以其Ws &lt;= 255 。<br>在SR协议中，Wr = Ws时效率最高，从而，Wr = Ws &lt;= 128</p></blockquote><ul><li>通过实际测试的结果分析得到合适的 W 值，最终发现，在 GBN 协议中，W 取 7 效率最高；在 SR 协议中，W 取 63 效率最高</li></ul><p>②  <strong>重传定时器时限和ACK定时器时限</strong>：</p><p>重传计时器的时限涉及到重传的响应时间，若太大，将导致重传等待的时间过久；若太小，将导致较为频繁的重传，两种情况均将导致信道利用率下降。</p><ul><li><p>估算重传定时器时限的<strong>下界 t</strong> ，考虑如下几个时间：</p><ul><li>每一帧的帧长为263B，由信道传输速率为 8000bps 可得<strong>数据发送延迟时间 Td</strong> 为 263ms 。</li><li><strong>传播时延 Ts</strong> 固定为 270ms 。</li><li>接收方接收完数据帧后，既可能以捎带 ACK 的方式发送 ACK ，也可能由于 ACK定时器超时而发送单独的 ACK 帧。这里显然应取：对方从接收完数据帧，到开始发送 ACK 的时间间隔的上界进行计算，不难看出，这个上界就是ACK定时器的时长 <strong>ACK_TIMER</strong></li><li>ACK 帧在物理层队列中<strong>排队的等待时间</strong>，同样以最坏情况进行计算，即在 ACK 帧之前存在等待发送的普通数据帧（已发送0字节）、重传数据帧和 NAK 帧，总计 263 + 263 + 6 = 532 字节，需要花费 532ms 才能发送完成。</li><li><strong>发送这个ACK 帧</strong>的时间为6ms，它在信道上的<strong>传输时延</strong>为270ms 。</li><li>物理层在发送数据帧时会在帧与帧之间添加 <strong>1ms 的时间间隔</strong>，最坏情况下增加 4ms 的时间。</li></ul><p>  综上有：</p></li></ul><p>$$<br>t = 263 + 270 + ACK_TIMER + 532 + 6 + 270 + 4 = 1345 + ACK_TIMER (ms)<br>$$</p><ul><li><p>由此可得，重传定时器时限 t 与ACK定时器时限 ACK_TIMER 有关。我们知道，ACK定时器时限的一个最低的下界为数据链路层从网络层获得一个数据包的时间，经过多次的测试和分析，我们发现这个下界大约为200ms。而在实际测试中，当ACK定时器时限高于这个下界时可取得较高的效率。</p></li><li><p>最终，我们通过多次实验观察的方式，确定了 t 的最优值 : </p><ul><li>在 GBN 协议中令ACK定时器时限为 <strong>240 ms</strong>，在SR协议中，令ACK定时器时限为<strong>1000 ms</strong>。</li><li>重传定时器在 GBN 协议中取 <strong>2800ms</strong> 最优，在SR协议中取 <strong>3000ms</strong> 最优。</li></ul></li></ul><p><strong>4.理论分析：根据所设计的滑动窗口工作机制(Go-Back-N 或者选择重传)，推导出在无差错信道环境下分组层能获得的最大信道利用率；推导出在有误码条件下重传操作及时发生等理想情况下分组层能获得的最大信道利用率。给出理论推导过程。理论推导的目的是得到信道利用率的极限数据。为了简化有误码条件下的最大利用率推导过程，可以对问题模型进行简化，比如：假定超时重传的数据帧的回馈ACK 帧可以100%正确传输，但是简化问题分析的这些假设必须不会对整个结论产生较大的误差。</strong></p><ul><li><p>在无差错信道上，由于需要携带3字节的控制信息和4字节的校验位，因此最大的信道利用率为<br>  $$<br>  256/(256 + 3 + 4)= 97.3%<br>  $$</p></li><li><p>在误码率为 1e-5 的信道上（即每传送 100000 个比特平均会发生 1 个错误）</p><blockquote><p>假设信道上始终有数据需要传送，则可以传送 100000/((256+3+4)*8) 约为 47 个数据包，即每 47 个数据包会有一个出错。</p></blockquote><blockquote><p>假设超时重传的数据帧的回馈ACK 帧可以100%正确传输，出错的是最后一个数据包，且每出错一次，在限定时间内可以正确重传该帧。</p></blockquote><p>  则每传送 47 个数据包需要传送 47+1+1 = 49 次。于是此时的信道利用率为<br>  $$<br>  (47 * 256)/(49 <em>(256+3+4)) ≈ 93.4 %<br>  $$<br>  但由于程序设计并不能够达到理想状态，当一个数据包超时后，往往需要重复多次重传，造成信道浪费。若重传 K 次，则信道利用率为<br>  $$<br>  (47</em>256)/((48 + k) *(256+3+4))<br>  $$<br>  若平均重传10次，信道利用率约为 78.88% 。</p></li></ul><p><strong>5.实验结果分析：你的程序运行实际达到了什么样的效率，比对理论推导给出的结论，有没有差距？给出原因。有没有改进的办法？如果没有时间把这些方法付诸编程实施，介绍你的方案。</strong></p><p>实际达到的效率如下表所示：</p><p><img src="https://i.loli.net/2021/05/06/yjQkKdcia9BnDGU.png" alt="image-20210505210958256"></p><p>协议效率大部分达到了参考效率，但有一些数据与理想效率有差距，比如无误码情况下的97.3%，以及高误码率下的效率。考虑其原因，猜想主要有以下几方面：</p><ul><li>不能保证数据链路层和物理层之间没有延迟，ACK和重传的帧也不能100%正确，与理想的假设情况有区别</li><li>在高误码率的环境下，NAK帧的丢失有可能会导致一连串的重传，降低传输效率</li><li>所选的窗口大小和超时时间还不是最优的</li></ul><p>据此，提出以下方案：</p><ul><li>修改回退N步协议，添加NAK帧。根据实测结果（见上述表格），这种方法对回退N的效率有一定提升，但不明显。</li><li>对选择重传协议的NAK帧进行一定修改，拓宽其服务对象，设置NAK数组，对每一个缓冲区内的帧都可以单独发送NAK帧，这样可以缓解高误码率下NAK帧丢失、坏帧之后带来的一系列超时重传问题。</li><li>针对数据链路层与物理层之间的延迟，考虑取消PHYSICAL_LAYER_READY事件对NAK帧、ACK帧、超时重传的数据帧的限制，一旦产生这些帧，无论PHYSICAL_LAYER_READY事件是否发生，都可以直接发送。</li><li>通过有设计的实验，对误码率、传输速率、窗口大小、超时时间等量进行定量分析，借助dbg输出以及相关统计工具，从统计学角度对实验结果进行更加合理严谨的分析，通过图像、函数、求导等手段，得出理论上最优超时时间以及窗口大小。</li></ul><h2 id="研究和探索的问题"><span class="post-title-index">2.4 </span><a href="#研究和探索的问题" class="headerlink" title="研究和探索的问题"></a>研究和探索的问题</h2><p><strong>（1） CRC校验能力</strong></p><p>CRC校验码的检错能力很强，它除了能检查出离散错外，还能检查出突发错误。本次实验采用的CRC校验方案为CRC-32，与IEEE802.3以太网校验和生成多项式相同。生成多项式为：</p><p>x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+1</p><p>从其检错能力来看，不能发现传输错误的概率为2的-32次方，几乎接近于0，因此没有必要增加成本再去达到理论上为0的错误率。</p><p>另外一个方面，如果CRC校验错误而导致给网络层传输了错误数据，那么网络层也可以通过它的校验方式发现错误，采取重传，因此能够进一步保证传输正确性。</p><p><strong>（2）</strong> <strong>程序设计方面的问题</strong></p><p>①  协议软件跟踪功能为协议的调试提供了优质的方法，通过调用dbg_event和dbg_frame函数，可以清楚地观察协议的运行过程，可以非常自由的输出运行中的调试信息，并且跟踪到相应的代码段。我的程序多处调用dbg函数，实现了协议软件跟踪调试。</p><p>②  C语言的time.h当中提供了一些关于时间操作的函数可以用来实现get_ms()函数，如clock_t clock()。该函数返回程序开始执行后占用的处理器时间，如果无法获得占用时间则返回-1。只需在开始通信时，设置一个静态变量start_time。然后在每次调用get_ms()后，获取当前的时间current_time。然后再返回start_time-current_time即可。</p><p>③  如果本次实验提供的程序库中不包含log_printf和lprintf函数，可自己实现。</p><p>④  Start_timer()函数用于给发出的数据帧计时，如果超时还未收到确认ACK，便重发缓存中的数据帧。因此，在重新调用时应重新开始计时。Start_ack_timer()函数用于等待捎带确认的反向数据帧，若超时还没有反向数据帧，那就需要单独发送一个ACK帧。Start_ack_timer()在重新调用上的特点，就是为了避免ACK定时器时限过长使得发送方超时重发。</p><p><strong>（3）对等协议实体之间的流量控制</strong></p><p>我的协议解决了流量控制问题。作为滑动窗口协议，窗口本身就是一个流量控制，由于窗口大小的限制，发送方不会一次性发送过多信息导致接收方被数据所淹没或信息丢失。</p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
          <category> 专业课程 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 网络协议 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> LAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++程序设计08——运算符重载</title>
      <link href="2021/04/27/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A108%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>2021/04/27/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A108%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>崔毅东C++程序设计——运算符重载的笔记。<span id="more"></span></p><h1 id="引入：平面向量类-2D-Vector-Class"><span class="post-title-index">1 </span><a href="#引入：平面向量类-2D-Vector-Class" class="headerlink" title="引入：平面向量类 2D Vector Class"></a>引入：平面向量类 2D Vector Class</h1><h2 id="在C-中描述平面向量"><span class="post-title-index">1.1 </span><a href="#在C-中描述平面向量" class="headerlink" title="在C++中描述平面向量"></a>在C++中描述平面向量</h2><ol><li><p>C++ STL vector: 变长数组</p></li><li><p>向量数据成员：</p><p> <em>double x, double y</em></p><p> <em>或者 std::array&lt;double, 2&gt; v_;</em></p></li><li><p>运算</p><p> a. 数乘、点积</p><p> b. 求长度和方向</p><p> ​     <em>| (1, 2)| : √ ( 11 + 22)</em></p><p> ​     <em>dir (1, 2) : arctan ( 1/2 )</em></p></li><li><p>==, !=, &lt;, &lt;=, &gt;, &gt;=</p></li><li><p>类型转换：</p><ol><li>转为double，即求向量长度；</li><li>转为string</li></ol></li><li><p>负值</p></li><li><p>自加1，自减1</p></li></ol><h2 id="TDD开发设计方法"><span class="post-title-index">1.2 </span><a href="#TDD开发设计方法" class="headerlink" title="TDD开发设计方法"></a>TDD开发设计方法</h2><ol><li><p>Test-Driven Development (TDD),测试驱动开发</p><blockquote><p>一种开发设计方法，值得一看。Kent Beck 《测试驱动开发》</p></blockquote></li><li><p>步骤</p><p> (1)   先编写测试代码，而不是功能代码</p><p> (2)   编译运行测试代码，发现不能通过</p><p> (3)   做一些小小的改动（编写功能代码），尽快地让测试程序可运行</p><p> (4)   重构代码，优化设计</p></li></ol><h2 id="Vector-2D-类成员函数"><span class="post-title-index">1.3 </span><a href="#Vector-2D-类成员函数" class="headerlink" title="Vector 2D 类成员函数"></a>Vector 2D 类成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的反正切值，以弧度为单位。有其他类型重载</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的平方根。有其它类型重载</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span> <span class="params">(<span class="keyword">double</span> b, <span class="keyword">double</span> exp)</span></span>; <span class="comment">// 返回b的exp次方。有其它类型重载</span></span><br></pre></td></tr></table></figure><h1 id="重载运算符基本介绍"><span class="post-title-index">2 </span><a href="#重载运算符基本介绍" class="headerlink" title="重载运算符基本介绍"></a>重载运算符基本介绍</h1><h2 id="运算符与函数的异同"><span class="post-title-index">2.1 </span><a href="#运算符与函数的异同" class="headerlink" title="运算符与函数的异同"></a>运算符与函数的异同</h2><ol><li><p>运算符可以看做是函数</p></li><li><p>不同之处</p><p> （1） 语法有区别</p><p> （2） 不能自定义新的运算符，只能重载已经存在的运算符</p><p> （3） <strong>函数可overload, override产生任何想要的结果，但运算符作用于内置类型的行为不能修改</strong></p></li><li><p>函数式编程语言的观念——一切皆是函数【Haskell】</p></li><li><p>Emacs calculator软件</p></li></ol><h2 id="C-运算符函数"><span class="post-title-index">2.2 </span><a href="#C-运算符函数" class="headerlink" title="C++运算符函数"></a>C++运算符函数</h2><h3 id="可重载的运算符"><span class="post-title-index">2.2.1 </span><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h3><ol><li><p>类型转换运算符：double, int, char, ……</p></li><li><p>new/delete, new []/delete[]</p></li><li><p>“”_suffix 用户自定义字面量运算符(自C++11起)</p></li><li><p>一般运算符:</p> <img src="https://i.loli.net/2021/05/06/MKTHDrqfknUy7t8.png" alt="QQ截图20210506113235" style="zoom: 50%;"></li></ol><h3 id="不可重载的运算符"><span class="post-title-index">2.2.2 </span><a href="#不可重载的运算符" class="headerlink" title="不可重载的运算符"></a>不可重载的运算符</h3><table><thead><tr><th>Operator</th><th align="left">Name</th></tr></thead><tbody><tr><td>.</td><td align="left">类属关系运算符</td></tr><tr><td>.*</td><td align="left">成员指针运算符</td></tr><tr><td>::</td><td align="left">作用域运算符</td></tr><tr><td>?:</td><td align="left">条件运算符</td></tr><tr><td>#</td><td align="left">预编译符号</td></tr></tbody></table><h3 id="运算符重载的限制"><span class="post-title-index">2.2.3 </span><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><ol><li>优先级和结合性不变</li><li>不可创造新的运算符</li></ol><h3 id="运算符函数"><span class="post-title-index">2.2.4 </span><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><p><img src="https://i.loli.net/2021/05/06/tkHxceE5rpDMQYP.png" alt="QQ截图20210506113253"></p><p>【<strong>注意</strong>】</p><ol><li>v2作为<strong>参数</strong>传递给v1的operator函数</li><li>this指针的几个要点（见上图），调用v1 &lt; v2 时，this指向v1</li><li>传参的时候可以不用引用吗——可以</li><li>使用引用的好处——提高调用效率，不需要调用拷贝构造函数！</li></ol><h3 id="确定运算符的调用形式"><span class="post-title-index">2.2.5 </span><a href="#确定运算符的调用形式" class="headerlink" title="确定运算符的调用形式"></a>确定运算符的调用形式</h3><p><img src="https://i.loli.net/2021/05/06/jc7uy5ZGzi2CRos.png" alt="image-20210426215559462"></p><h2 id="左值、纯右值与将亡值"><span class="post-title-index">2.3 </span><a href="#左值、纯右值与将亡值" class="headerlink" title="左值、纯右值与将亡值"></a>左值、纯右值与将亡值</h2><h3 id="C-03-的左值和右值"><span class="post-title-index">2.3.1 </span><a href="#C-03-的左值和右值" class="headerlink" title="C++03 的左值和右值"></a>C++03 的左值和右值</h3><p>(1)   能放在等号左边的是lvalue</p><p>(2)   只能放在等号右边的是rvalue</p><p>(3)   lvalue可以作为rvalue使用</p><h3 id="C-11-的左值和右值"><span class="post-title-index">2.3.2 </span><a href="#C-11-的左值和右值" class="headerlink" title="C++11 的左值和右值"></a>C++11 的左值和右值</h3><ol><li><p><strong>左值</strong></p><ul><li><p>指定了一个函数或者对象，它是一个可以取地址的表达式</p></li><li><p>举例：</p></li></ul><p> ​    (1)   解引用表达式*p：&amp;(*p)</p><p> ​    (2)   字符串字面量”abc”：字符串存储在静态区，是有地址的，首地址是一个指针。</p><p> ​    (3)   <strong>前置</strong>自增/自减表达式 ++i / –i：前置表达式操作过程是先对i进行自增自减运算，再取地址，&amp;(++i)等价于&amp;i。后置自增/自减表达式不能进行取地址操作</p><p> ​    (4)   赋值或复合运算符表达式(x=y或m*=n等）</p></li><li><p><strong>纯右值</strong></p><ul><li><p>纯右值：不和对象相关联的值(字面量)，或者其求值结果是字面量或者一个匿名的临时对象</p></li><li><p>举例：</p><p>  (1)   除字符串字面量以外的字面量，比如 32, ‘a’</p><p>  (2)   返回非引用类型的函数调用 int f() { return 1;}</p><p>  (3)   后置自增/自减表达式 i++/i–</p><p>  (4)   算术/逻辑/关系表达式（a+b、a&amp;b、a&lt;&lt;b）（a&amp;&amp;b、a||b、~a）（a==b、a&gt;=b、a&lt;b）</p><p>  (5)   取地址（&amp;x）</p></li></ul></li><li><p><strong>左值可以当成右值使用</strong></p></li></ol><h3 id="C-11-将亡值"><span class="post-title-index">2.3.3 </span><a href="#C-11-将亡值" class="headerlink" title="C++11 将亡值"></a>C++11 将亡值</h3><ol><li><p>将亡值：将亡值也指定了一个对象，是一个将纯右值转换为<strong>右值引用</strong>的表达式</p><ul><li>右值引用：int**&amp;&amp;** rvr1{ 22 };</li><li>举例：</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">6</span> * x; &#125; <span class="comment">// pure rvalue </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>&amp; lvr5&#123; <span class="number">21</span> &#125;; <span class="comment">// 常量左值引用可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp; lvr6&#123; <span class="number">22</span> &#125;; <span class="comment">// 错！非常量左值引用不可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp;&amp; rvr1&#123; <span class="number">22</span> &#125;; <span class="comment">// 右值引用可以引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp; lvr7&#123; <span class="built_in">prv</span>(<span class="number">2</span>) &#125;; <span class="comment">// 错！非常量左值引用不可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp;&amp; rvr2&#123; <span class="built_in">prv</span>(<span class="number">2</span>) &#125;; <span class="comment">// 右值引用普通函数返回值</span></span><br><span class="line">      rvr1 = ++rvr2; <span class="comment">// 右值引用做左值使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 右值引用可以看作延续了纯右值的生命期，比如line7，原本执行完prv(2)之后返回值就找不到了，使用右值引用就可以继续对返回值进行修改，比如line8。</p></li></ol><h1 id="重载实例"><span class="post-title-index">3 </span><a href="#重载实例" class="headerlink" title="重载实例"></a>重载实例</h1><h2 id="重载一般二元算术运算符"><span class="post-title-index">3.1 </span><a href="#重载一般二元算术运算符" class="headerlink" title="重载一般二元算术运算符"></a>重载一般二元算术运算符</h2><h3 id="调用一般二元运算符"><span class="post-title-index">3.1.1 </span><a href="#调用一般二元运算符" class="headerlink" title="调用一般二元运算符"></a>调用一般二元运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec2D a&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, b&#123;<span class="number">3</span>, <span class="number">6</span>&#125;; <span class="keyword">double</span> z &#123;<span class="number">1.3</span>&#125;;</span><br><span class="line">Vec2D c = a + b;  <span class="comment">// a.operator+(b); à Vec2D Vec2D::operator+(Vec2D);</span></span><br><span class="line">Vec2D d = a + z;  <span class="comment">// a.operator+(z); à Vec2D Vec2D::operator+(double);</span></span><br><span class="line">Vec2D e = z + b;  <span class="comment">// z.operator+(b); à Vec2D double::operator+(Vec2D);错误！</span></span><br></pre></td></tr></table></figure><p>【注意】最后一行错误原因：double 类型是内建类型，其运算符不能被重载</p><h3 id="函数原型"><span class="post-title-index">3.1.2 </span><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2D</span> &#123;</span></span><br><span class="line">  Vec2D <span class="keyword">operator</span> +(Vec2D);                <span class="comment">//成员函数</span></span><br><span class="line">  Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>);               <span class="comment">//成员函数</span></span><br><span class="line">  <span class="keyword">friend</span> Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>, Vec2D); <span class="comment">//非成员函数，友元函数    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>, Vec2D) &#123; <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】友元函数需要两个参数，不能像成员函数一样默认本对象为调用者</p><h3 id="关于返回值"><span class="post-title-index">3.1.3 </span><a href="#关于返回值" class="headerlink" title="关于返回值"></a>关于返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Matrice Matrice::<span class="keyword">operator</span>+(<span class="keyword">const</span> Matrice&amp; second_m) <span class="keyword">const</span> &#123;</span><br><span class="line">    Matrice resultMatrice&#123; <span class="keyword">this</span>-&gt;lines, <span class="keyword">this</span>-&gt;rows &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">this</span>-&gt;lines); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">this</span>-&gt;rows); j++) &#123;</span><br><span class="line">            (resultMatrice.matricePointer)[i][j] =</span><br><span class="line">                (<span class="keyword">this</span>-&gt;matricePointer)[i][j] + (second_m.matricePointer)[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMatrice; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】类内如果有指针成员，在返回的时候一定要格外小心深拷贝、浅拷贝。</p><p>如果要用上面代码实现矩阵加法的重载，一定要先重载拷贝构造函数，将默认的浅拷贝重载成深拷贝的方式，不然将会出现内存泄漏——也就是直接返回了 resultMatrice 这个局部对象，而+运算的函数体结束后这个对象会立刻被析构，其中的矩阵指针也会立刻被释放，这时继续使用返回值里的矩阵指针，显然是内存泄漏！！</p><h3 id="举例"><span class="post-title-index">3.1.4 </span><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Vec2D v2 = v1 + <span class="built_in">Vec2D</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1 is &quot;</span> &lt;&lt; v1.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2 is &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="重载复合二元算术运算符（-and-）"><span class="post-title-index">3.2 </span><a href="#重载复合二元算术运算符（-and-）" class="headerlink" title="重载复合二元算术运算符（+=, -=, *=, and /=）"></a>重载复合二元算术运算符（+=, -=, *=, and /=）</h2><h3 id="复合运算符操作的特殊之处"><span class="post-title-index">3.2.1 </span><a href="#复合运算符操作的特殊之处" class="headerlink" title="复合运算符操作的特殊之处"></a>复合运算符操作的特殊之处</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1 += v2; <span class="comment">// 语句执行后，v1的值被改变了（这非常重要！！）</span></span><br><span class="line">v1 = v1 + v2;</span><br></pre></td></tr></table></figure><h3 id="复合运算符的重载"><span class="post-title-index">3.2.2 </span><a href="#复合运算符的重载" class="headerlink" title="复合运算符的重载"></a>复合运算符的重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vec2D Vec2D::<span class="keyword">operator</span> +=(<span class="keyword">const</span> Vec2D&amp; secondVec2D ) &#123;</span><br><span class="line">    *<span class="keyword">this</span> = <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D); <span class="comment">//add函数返回临时的匿名对象，这个对象被赋给this指针</span></span><br><span class="line"> <span class="keyword">return</span> (*<span class="keyword">this</span>); <span class="comment">//返回解引用的this指针，也就是返回了this指向的对象</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Vec2D <span class="title">Vec2D::add</span><span class="params">(<span class="keyword">const</span> Vec2D&amp; secondVec2D)</span> </span>&#123; <span class="comment">//prvalue</span></span><br><span class="line"> <span class="keyword">double</span> m = x_ + secondVec2D.<span class="built_in">getX</span>()</span><br><span class="line"> <span class="keyword">double</span> n = y_ + secondVec2D.y_;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Vec2D</span>(m, n); <span class="comment">//返回临时的匿名对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果将以上代码对应v1+=v2; 则有：</p><ul><li>secondVec2D 是 v2</li><li>(*this) 是改变后的 v1</li></ul></li><li><p>如果将</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">this</span> = <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D);</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>  修改为：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D);</span><br></pre></td></tr></table></figure><p>  这个重载是否还有效？</p></li></ul><h3 id="举例-1"><span class="post-title-index">3.2.3 </span><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v2</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">v2 += <span class="built_in">Vec2D</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2 is &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="重载数组下标运算符"><span class="post-title-index">3.3 </span><a href="#重载数组下标运算符" class="headerlink" title="重载数组下标运算符"></a>重载数组下标运算符</h2><h3 id="重载-运算符"><span class="post-title-index">3.3.1 </span><a href="#重载-运算符" class="headerlink" title="重载[]运算符"></a>重载[]运算符</h3><ul><li><p>为什么重载[]运算符</p></li><li><p>[]重载后可用类似数组的语法格式访问对象内容</p></li><li><p>重载代码示例</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vec2D v &#123;<span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v.x_: &quot;</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;v.y_: &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Vec2D::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y_;</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index out of bound&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这种重载方法只能读取数据*/</span></span><br></pre></td></tr></table></figure><h3 id="数组下标运算符作为访问器和修改器"><span class="post-title-index">3.3.2 </span><a href="#数组下标运算符作为访问器和修改器" class="headerlink" title="数组下标运算符作为访问器和修改器"></a>数组下标运算符作为访问器和修改器</h3></li></ul><ol><li><p>访问器和修改器：作为访问器就是用[]运算符读取数据，修改器就是用[]运算符修改数据</p></li><li><p>使r2[]成为左值的方法：使[]返回一个引用</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>&amp; Vec2D::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;index) &#123; <span class="comment">//lvalue</span></span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> x_;  <span class="comment">//x_ can be modified</span></span><br><span class="line">      <span class="comment">//...... Now, the Vec2D class is mutable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​    </p><h2 id="重载一元运算符"><span class="post-title-index">3.4 </span><a href="#重载一元运算符" class="headerlink" title="重载一元运算符"></a>重载一元运算符</h2><h3 id="单目运算符"><span class="post-title-index">3.4.1 </span><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h3><ol><li><p>主要的单目运算符：–, ++, -（负号）, *（解引用）</p></li><li><p>编译器执行过程：</p><ul><li><p>若operator @是在obj的类的<strong>成员函数</strong>，则调用obj.operator @()【无参数】</p></li><li><p>若operator @是obj的类的<strong>友元函数</strong>，则调用operator @(obj)</p></li></ul></li></ol><h3 id="重载负号运算符"><span class="post-title-index">3.4.2 </span><a href="#重载负号运算符" class="headerlink" title="重载负号运算符"></a>重载负号运算符</h3><h4 id="调用"><span class="post-title-index">3.4.2.1 </span><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Vec2D v2 = -v1;  <span class="comment">// 向量v1求负值；v1的值不变</span></span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">toString</span>();</span><br></pre></td></tr></table></figure><h4 id="重载负号运算符-1"><span class="post-title-index">3.4.2.2 </span><a href="#重载负号运算符-1" class="headerlink" title="重载负号运算符"></a>重载负号运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec2D* Vec2D::<span class="keyword">operator</span>-()&#123;</span><br><span class="line">    <span class="keyword">return</span> *Vec2D*(-<span class="keyword">this</span>-&gt;x_**,** **-**<span class="keyword">this</span>-&gt;y_); <span class="comment">// 返回匿名临时对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载-和-运算符"><span class="post-title-index">3.4.3 </span><a href="#重载-和-运算符" class="headerlink" title="重载++和- -运算符"></a>重载++和- -运算符</h3><h4 id="前置、后置运算符与操作顺序"><span class="post-title-index">3.4.3.1 </span><a href="#前置、后置运算符与操作顺序" class="headerlink" title="前置、后置运算符与操作顺序"></a>前置、后置运算符与操作顺序</h4><ul><li><p>前置：先增减后取值，表达式是lvalue</p></li><li><p>后置：先取值（存在某个地方）后增减，表达式是prvalue（纯右值）</p><ul><li>举例：<ul><li>b = (a++) / 2 这一算式中，会先把a的值取出来放到某处，假设为temp（temp将被用于参加整个表达式的后续计算），之后a会被+1，a的值被改变。</li><li>b = (++a) / 2 这一算式，则直接将a值+1，并用a进行后续计算，没有temp这一环节。</li></ul></li><li>代码示例：</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">//v1: (3, 4)</span></span><br><span class="line">Vec2D v2 = ++v1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2: &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v2: (3, 4)</span></span><br><span class="line"><span class="function">Vec2D <span class="title">v3</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Vec2D v4 = v3++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v3: &quot;</span> &lt;&lt; v3.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v3: (3, 4)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v4: &quot;</span> &lt;&lt; v4.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v4: (2, 3)</span></span><br></pre></td></tr></table></figure><h4 id="前置与后置在函数定义中的区别"><span class="post-title-index">3.4.3.2 </span><a href="#前置与后置在函数定义中的区别" class="headerlink" title="前置与后置在函数定义中的区别"></a>前置与后置在函数定义中的区别</h4><p><img src="https://i.loli.net/2021/05/06/jc7uy5ZGzi2CRos.png" alt="image-20210426215559462"></p><ul><li><p>前置++/–重载无参数，返回引用类型</p></li><li><p>后置++/–重载带参数——“dummy”</p><ul><li>这个参数用于表示这是一个后置运算符，实际调用的时候并不会传参</li></ul></li><li><p>若在类外定义，则不论前置后置都需要参数</p></li></ul><h4 id="重载实例-1"><span class="post-title-index">3.4.3.3 </span><a href="#重载实例-1" class="headerlink" title="重载实例"></a>重载实例</h4><ul><li>前置++运算符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vec2D&amp; Vec2D::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    x_ += <span class="number">1</span>;</span><br><span class="line">    y_ += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置++运算符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec2D Vec2D::<span class="keyword">operator</span>++(<span class="keyword">int</span> dummy)&#123;</span><br><span class="line">    <span class="function">Vec2D <span class="title">temp</span><span class="params">(<span class="keyword">this</span>-&gt;x_, <span class="keyword">this</span>-&gt;y_)</span></span>;</span><br><span class="line">    x_ += <span class="number">1</span>;</span><br><span class="line">    y_ += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">//返回的是未自增的对象，是一个纯右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>两条返回语句的不同</strong>导致了前置++和后置++的区别</li></ul><h2 id="重载流插入-lt-lt-提取-gt-gt-运算符"><span class="post-title-index">3.5 </span><a href="#重载流插入-lt-lt-提取-gt-gt-运算符" class="headerlink" title="重载流插入(&lt;&lt;)/提取(&gt;&gt;)运算符"></a>重载流插入(&lt;&lt;)/提取(&gt;&gt;)运算符</h2><h3 id="重载-lt-lt-gt-gt-的目的"><span class="post-title-index">3.5.1 </span><a href="#重载-lt-lt-gt-gt-的目的" class="headerlink" title="重载&lt;&lt;/&gt;&gt;的目的"></a>重载&lt;&lt;/&gt;&gt;的目的</h3><p>能够把对象信息直接输出，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; vec2d;</span><br><span class="line">cin &gt;&gt; vec2d;</span><br></pre></td></tr></table></figure><h3 id="重载为友元函数"><span class="post-title-index">3.5.2 </span><a href="#重载为友元函数" class="headerlink" title="重载为友元函数"></a>重载为友元函数</h3><ol><li><p>为什么不能重载为成员函数</p><p> 运算符重载为类成员函数后，当调用该运算符时，左操作数必须是该类的实例。若&lt;&lt;和&gt;&gt;重载为成员函数，则只能用 v1&lt;&lt;cout; 如下所示：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*重载为成员函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream);</span><br><span class="line">    istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;stream);</span><br><span class="line">&#125;;</span><br><span class="line">Vec2D v1;</span><br><span class="line">v1 &lt;&lt; cout; <span class="comment">//Vec2D对象只能作为第一个操作数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*重载为友元函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2D</span> &#123;</span> </span><br><span class="line">  <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream, Vec2D &amp;v);</span><br><span class="line">  <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;stream, Vec2D &amp;v);</span><br><span class="line">&#125;;</span><br><span class="line">Vec2D v1;</span><br><span class="line">cout &lt;&lt; v1; <span class="comment">//更符合编程习惯</span></span><br></pre></td></tr></table></figure></li><li><p>为什么友元函数的返回值是**ostream&amp;**类型</p><p> 要实现cout&lt;&lt;x&lt;&lt;y; 这类<strong>连续输出</strong>的代码，想要输出y，cout&lt;&lt;x这一部分应该返回一个ostream类型，所以使用ostream&amp;作为返回值</p><blockquote><p>返回ostream类型与&amp;有什么联系？为什么一定是&amp;呢</p></blockquote></li></ol><h2 id="重载对象转换运算符"><span class="post-title-index">3.6 </span><a href="#重载对象转换运算符" class="headerlink" title="重载对象转换运算符"></a>重载对象转换运算符</h2><h3 id="重载目的"><span class="post-title-index">3.6.1 </span><a href="#重载目的" class="headerlink" title="重载目的"></a>重载目的</h3><ul><li>将Vec2D对象转换为double数时，我们可以求该对象的范数，也就是向量长度</li></ul><h3 id="重载实例-2"><span class="post-title-index">3.6.2 </span><a href="#重载实例-2" class="headerlink" title="重载实例"></a>重载实例</h3><ul><li>类型转换函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="comment">//操作符名称和要转到的类型同名，类似于构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">magnitude</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用实例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = v1 + <span class="number">5.1</span>; <span class="comment">// d: 10.1</span></span><br><span class="line"><span class="keyword">double</span> e = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(v1);  <span class="comment">// e: 5.0</span></span><br></pre></td></tr></table></figure><h2 id="重载赋值运算符"><span class="post-title-index">3.7 </span><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h2><p><a href="https://www.icourse163.org/learn/BUPT-1003564002?tid=1461043448#/learn/content?type=detail&id=1237770721&cid=1257884782">C++程序设计（面向对象进阶）_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
      
      
      <categories>
          
          <category> 专业 </category>
          
          <category> 语言学习 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
