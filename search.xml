<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++程序设计08——运算符重载</title>
    <url>/2021/04/27/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A108%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
    <content><![CDATA[<p>崔毅东C++程序设计——运算符重载的笔记。<span id="more"></span></p>
<h1 id="引入：平面向量类-2D-Vector-Class"><span class="post-title-index">1 </span><a href="#引入：平面向量类-2D-Vector-Class" class="headerlink" title="引入：平面向量类 2D Vector Class"></a>引入：平面向量类 2D Vector Class</h1><h2 id="在C-中描述平面向量"><span class="post-title-index">1.1 </span><a href="#在C-中描述平面向量" class="headerlink" title="在C++中描述平面向量"></a>在C++中描述平面向量</h2><ol>
<li><p>C++ STL vector: 变长数组</p>
</li>
<li><p>向量数据成员：</p>
<p> <em>double x, double y</em></p>
<p> <em>或者 std::array<double, 2> v_;</double,></em></p>
</li>
<li><p>运算</p>
<p> a. 数乘、点积</p>
<p> b. 求长度和方向</p>
<p> ​     <em>| (1, 2)| : √ ( 11 + 22)</em></p>
<p> ​     <em>dir (1, 2) : arctan ( 1/2 )</em></p>
</li>
<li><p>==, !=, &lt;, &lt;=, &gt;, &gt;=</p>
</li>
<li><p>类型转换：</p>
<ol>
<li>转为double，即求向量长度；</li>
<li>转为string</li>
</ol>
</li>
<li><p>负值</p>
</li>
<li><p>自加1，自减1</p>
</li>
</ol>
<h2 id="TDD开发设计方法"><span class="post-title-index">1.2 </span><a href="#TDD开发设计方法" class="headerlink" title="TDD开发设计方法"></a>TDD开发设计方法</h2><ol>
<li><p>Test-Driven Development (TDD),测试驱动开发</p>
<blockquote>
<p>一种开发设计方法，值得一看。Kent Beck 《测试驱动开发》</p>
</blockquote>
</li>
<li><p>步骤</p>
<p> (1)   先编写测试代码，而不是功能代码</p>
<p> (2)   编译运行测试代码，发现不能通过</p>
<p> (3)   做一些小小的改动（编写功能代码），尽快地让测试程序可运行</p>
<p> (4)   重构代码，优化设计</p>
</li>
</ol>
<h2 id="Vector-2D-类成员函数"><span class="post-title-index">1.3 </span><a href="#Vector-2D-类成员函数" class="headerlink" title="Vector 2D 类成员函数"></a>Vector 2D 类成员函数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的反正切值，以弧度为单位。有其他类型重载</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的平方根。有其它类型重载</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span> <span class="params">(<span class="keyword">double</span> b, <span class="keyword">double</span> exp)</span></span>; <span class="comment">// 返回b的exp次方。有其它类型重载</span></span><br></pre></td></tr></table></figure>
<h1 id="重载运算符基本介绍"><span class="post-title-index">2 </span><a href="#重载运算符基本介绍" class="headerlink" title="重载运算符基本介绍"></a>重载运算符基本介绍</h1><h2 id="运算符与函数的异同"><span class="post-title-index">2.1 </span><a href="#运算符与函数的异同" class="headerlink" title="运算符与函数的异同"></a>运算符与函数的异同</h2><ol>
<li><p>运算符可以看做是函数</p>
</li>
<li><p>不同之处</p>
<p> （1） 语法有区别</p>
<p> （2） 不能自定义新的运算符，只能重载已经存在的运算符</p>
<p> （3） <strong>函数可overload, override产生任何想要的结果，但运算符作用于内置类型的行为不能修改</strong></p>
</li>
<li><p>函数式编程语言的观念——一切皆是函数【Haskell】</p>
</li>
<li><p>Emacs calculator软件</p>
</li>
</ol>
<h2 id="C-运算符函数"><span class="post-title-index">2.2 </span><a href="#C-运算符函数" class="headerlink" title="C++运算符函数"></a>C++运算符函数</h2><h3 id="可重载的运算符"><span class="post-title-index">2.2.1 </span><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h3><ol>
<li><p>类型转换运算符：double, int, char, ……</p>
</li>
<li><p>new/delete, new []/delete[]</p>
</li>
<li><p>“”_suffix 用户自定义字面量运算符(自C++11起)</p>
</li>
<li><p>一般运算符:</p>
<p> <img src="https://i.loli.net/2021/05/06/MKTHDrqfknUy7t8.png" alt="QQ截图20210506113235" style="zoom: 50%;"></p>
</li>
</ol>
<h3 id="不可重载的运算符"><span class="post-title-index">2.2.2 </span><a href="#不可重载的运算符" class="headerlink" title="不可重载的运算符"></a>不可重载的运算符</h3><div class="table-container">
<table>
<thead>
<tr>
<th>Operator</th>
<th style="text-align:left">Name</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td style="text-align:left">类属关系运算符</td>
</tr>
<tr>
<td>.*</td>
<td style="text-align:left">成员指针运算符</td>
</tr>
<tr>
<td>::</td>
<td style="text-align:left">作用域运算符</td>
</tr>
<tr>
<td>?:</td>
<td style="text-align:left">条件运算符</td>
</tr>
<tr>
<td>#</td>
<td style="text-align:left">预编译符号</td>
</tr>
</tbody>
</table>
</div>
<h3 id="运算符重载的限制"><span class="post-title-index">2.2.3 </span><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><ol>
<li>优先级和结合性不变</li>
<li>不可创造新的运算符</li>
</ol>
<h3 id="运算符函数"><span class="post-title-index">2.2.4 </span><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><p><img src="https://i.loli.net/2021/05/06/tkHxceE5rpDMQYP.png" alt="QQ截图20210506113253"></p>
<p>【<strong>注意</strong>】</p>
<ol>
<li>v2作为<strong>参数</strong>传递给v1的operator函数</li>
<li>this指针的几个要点（见上图），调用v1 &lt; v2 时，this指向v1</li>
<li>传参的时候可以不用引用吗——可以</li>
<li>使用引用的好处——提高调用效率，不需要调用拷贝构造函数！</li>
</ol>
<h3 id="确定运算符的调用形式"><span class="post-title-index">2.2.5 </span><a href="#确定运算符的调用形式" class="headerlink" title="确定运算符的调用形式"></a>确定运算符的调用形式</h3><p><img src="https://i.loli.net/2021/05/06/jc7uy5ZGzi2CRos.png" alt="image-20210426215559462"></p>
<h2 id="左值、纯右值与将亡值"><span class="post-title-index">2.3 </span><a href="#左值、纯右值与将亡值" class="headerlink" title="左值、纯右值与将亡值"></a>左值、纯右值与将亡值</h2><h3 id="C-03-的左值和右值"><span class="post-title-index">2.3.1 </span><a href="#C-03-的左值和右值" class="headerlink" title="C++03 的左值和右值"></a>C++03 的左值和右值</h3><p>(1)   能放在等号左边的是lvalue</p>
<p>(2)   只能放在等号右边的是rvalue</p>
<p>(3)   lvalue可以作为rvalue使用</p>
<h3 id="C-11-的左值和右值"><span class="post-title-index">2.3.2 </span><a href="#C-11-的左值和右值" class="headerlink" title="C++11 的左值和右值"></a>C++11 的左值和右值</h3><ol>
<li><p><strong>左值</strong></p>
<ul>
<li><p>指定了一个函数或者对象，它是一个可以取地址的表达式</p>
</li>
<li><p>举例：</p>
<p>​    (1)   解引用表达式<em>p：&amp;(\</em>p)</p>
<p>​    (2)   字符串字面量”abc”：字符串存储在静态区，是有地址的，首地址是一个指针。</p>
<p>​    (3)   <strong>前置</strong>自增/自减表达式 ++i / —i：前置表达式操作过程是先对i进行自增自减运算，再取地址，&amp;(++i)等价于&amp;i。后置自增/自减表达式不能进行取地址操作</p>
<p>​    (4)   赋值或复合运算符表达式(x=y或m*=n等）</p>
</li>
</ul>
</li>
<li><p><strong>纯右值</strong></p>
<ul>
<li><p>纯右值：不和对象相关联的值(字面量)，或者其求值结果是字面量或者一个匿名的临时对象</p>
</li>
<li><p>举例：</p>
<p>  (1)   除字符串字面量以外的字面量，比如 32, ‘a’</p>
<p>  (2)   返回非引用类型的函数调用 int f() { return 1;}</p>
<p>  (3)   后置自增/自减表达式 i++/i—</p>
<p>  (4)   算术/逻辑/关系表达式（a+b、a&amp;b、a&lt;<b）（a&&b、a||b、~a）（a==b、a>=b、a&lt;b）</b）（a&&b、a||b、~a）（a==b、a></p>
<p>  (5)   取地址（&amp;x）</p>
</li>
</ul>
</li>
<li><p><strong>左值可以当成右值使用</strong></p>
</li>
</ol>
<h3 id="C-11-将亡值"><span class="post-title-index">2.3.3 </span><a href="#C-11-将亡值" class="headerlink" title="C++11 将亡值"></a>C++11 将亡值</h3><ol>
<li><p>将亡值：将亡值也指定了一个对象，是一个将纯右值转换为<strong>右值引用</strong>的表达式</p>
<ul>
<li>右值引用：int<strong>&amp;&amp;</strong> rvr1{ 22 };</li>
<li><p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">6</span> * x; &#125; <span class="comment">// pure rvalue </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>&amp; lvr5&#123; <span class="number">21</span> &#125;; <span class="comment">// 常量左值引用可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp; lvr6&#123; <span class="number">22</span> &#125;; <span class="comment">// 错！非常量左值引用不可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp;&amp; rvr1&#123; <span class="number">22</span> &#125;; <span class="comment">// 右值引用可以引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp; lvr7&#123; <span class="built_in">prv</span>(<span class="number">2</span>) &#125;; <span class="comment">// 错！非常量左值引用不可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp;&amp; rvr2&#123; <span class="built_in">prv</span>(<span class="number">2</span>) &#125;; <span class="comment">// 右值引用普通函数返回值</span></span><br><span class="line">      rvr1 = ++rvr2; <span class="comment">// 右值引用做左值使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>右值引用可以看作延续了纯右值的生命期，比如line7，原本执行完prv(2)之后返回值就找不到了，使用右值引用就可以继续对返回值进行修改，比如line8。</p>
</li>
</ul>
</li>
</ol>
<h1 id="重载实例"><span class="post-title-index">3 </span><a href="#重载实例" class="headerlink" title="重载实例"></a>重载实例</h1><h2 id="重载一般二元算术运算符"><span class="post-title-index">3.1 </span><a href="#重载一般二元算术运算符" class="headerlink" title="重载一般二元算术运算符"></a>重载一般二元算术运算符</h2><h3 id="调用一般二元运算符"><span class="post-title-index">3.1.1 </span><a href="#调用一般二元运算符" class="headerlink" title="调用一般二元运算符"></a>调用一般二元运算符</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec2D a&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, b&#123;<span class="number">3</span>, <span class="number">6</span>&#125;; <span class="keyword">double</span> z &#123;<span class="number">1.3</span>&#125;;</span><br><span class="line">Vec2D c = a + b;  <span class="comment">// a.operator+(b); à Vec2D Vec2D::operator+(Vec2D);</span></span><br><span class="line">Vec2D d = a + z;  <span class="comment">// a.operator+(z); à Vec2D Vec2D::operator+(double);</span></span><br><span class="line">Vec2D e = z + b;  <span class="comment">// z.operator+(b); à Vec2D double::operator+(Vec2D);错误！</span></span><br></pre></td></tr></table></figure>
<p>【注意】最后一行错误原因：double 类型是内建类型，其运算符不能被重载</p>
<h3 id="函数原型"><span class="post-title-index">3.1.2 </span><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2D</span> &#123;</span></span><br><span class="line">  	Vec2D <span class="keyword">operator</span> +(Vec2D);                <span class="comment">//成员函数</span></span><br><span class="line">  	Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>);               <span class="comment">//成员函数</span></span><br><span class="line">  	<span class="keyword">friend</span> Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>, Vec2D); <span class="comment">//非成员函数，友元函数    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>, Vec2D) &#123; <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】友元函数需要两个参数，不能像成员函数一样默认本对象为调用者</p>
<h3 id="关于返回值"><span class="post-title-index">3.1.3 </span><a href="#关于返回值" class="headerlink" title="关于返回值"></a>关于返回值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrice Matrice::<span class="keyword">operator</span>+(<span class="keyword">const</span> Matrice&amp; second_m) <span class="keyword">const</span> &#123;</span><br><span class="line">    Matrice resultMatrice&#123; <span class="keyword">this</span>-&gt;lines, <span class="keyword">this</span>-&gt;rows &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">this</span>-&gt;lines); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">this</span>-&gt;rows); j++) &#123;</span><br><span class="line">            (resultMatrice.matricePointer)[i][j] =</span><br><span class="line">                (<span class="keyword">this</span>-&gt;matricePointer)[i][j] + (second_m.matricePointer)[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMatrice; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【注意】类内如果有指针成员，在返回的时候一定要格外小心深拷贝、浅拷贝。</p>
<p>如果要用上面代码实现矩阵加法的重载，一定要先重载拷贝构造函数，将默认的浅拷贝重载成深拷贝的方式，不然将会出现内存泄漏——也就是直接返回了 resultMatrice 这个局部对象，而+运算的函数体结束后这个对象会立刻被析构，其中的矩阵指针也会立刻被释放，这时继续使用返回值里的矩阵指针，显然是内存泄漏！！</p>
<h3 id="举例"><span class="post-title-index">3.1.4 </span><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Vec2D v2 = v1 + <span class="built_in">Vec2D</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1 is &quot;</span> &lt;&lt; v1.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2 is &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="重载复合二元算术运算符（-and-）"><span class="post-title-index">3.2 </span><a href="#重载复合二元算术运算符（-and-）" class="headerlink" title="重载复合二元算术运算符（+=, -=, *=, and /=）"></a>重载复合二元算术运算符（+=, -=, *=, and /=）</h2><h3 id="复合运算符操作的特殊之处"><span class="post-title-index">3.2.1 </span><a href="#复合运算符操作的特殊之处" class="headerlink" title="复合运算符操作的特殊之处"></a>复合运算符操作的特殊之处</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v1 += v2; <span class="comment">// 语句执行后，v1的值被改变了（这非常重要！！）</span></span><br><span class="line">v1 = v1 + v2;</span><br></pre></td></tr></table></figure>
<h3 id="复合运算符的重载"><span class="post-title-index">3.2.2 </span><a href="#复合运算符的重载" class="headerlink" title="复合运算符的重载"></a>复合运算符的重载</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec2D Vec2D::<span class="keyword">operator</span> +=(<span class="keyword">const</span> Vec2D&amp; secondVec2D ) &#123;</span><br><span class="line">    *<span class="keyword">this</span> = <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D); <span class="comment">//add函数返回临时的匿名对象，这个对象被赋给this指针</span></span><br><span class="line"> 	<span class="keyword">return</span> (*<span class="keyword">this</span>); <span class="comment">//返回解引用的this指针，也就是返回了this指向的对象</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Vec2D <span class="title">Vec2D::add</span><span class="params">(<span class="keyword">const</span> Vec2D&amp; secondVec2D)</span> </span>&#123; <span class="comment">//prvalue</span></span><br><span class="line"> 	<span class="keyword">double</span> m = x_ + secondVec2D.<span class="built_in">getX</span>()</span><br><span class="line"> 	<span class="keyword">double</span> n = y_ + secondVec2D.y_;</span><br><span class="line"> 	<span class="keyword">return</span> <span class="built_in">Vec2D</span>(m, n); <span class="comment">//返回临时的匿名对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果将以上代码对应v1+=v2; 则有：</p>
<ul>
<li>secondVec2D 是 v2</li>
<li>(*this) 是改变后的 v1</li>
</ul>
</li>
<li><p>如果将</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">*<span class="keyword">this</span> = <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D);</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>  修改为：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D);</span><br></pre></td></tr></table></figure>
<p>  这个重载是否还有效？</p>
</li>
</ul>
<h3 id="举例-1"><span class="post-title-index">3.2.3 </span><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v2</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">v2 += <span class="built_in">Vec2D</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2 is &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h2 id="重载数组下标运算符"><span class="post-title-index">3.3 </span><a href="#重载数组下标运算符" class="headerlink" title="重载数组下标运算符"></a>重载数组下标运算符</h2><h3 id="重载-运算符"><span class="post-title-index">3.3.1 </span><a href="#重载-运算符" class="headerlink" title="重载[]运算符"></a>重载[]运算符</h3><ul>
<li><p>为什么重载[]运算符</p>
</li>
<li><p>[]重载后可用类似数组的语法格式访问对象内容</p>
</li>
<li><p>重载代码示例</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec2D v &#123;<span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v.x_: &quot;</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;v.y_: &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Vec2D::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y_;</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index out of bound&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这种重载方法只能读取数据*/</span></span><br></pre></td></tr></table></figure>
<h3 id="数组下标运算符作为访问器和修改器"><span class="post-title-index">3.3.2 </span><a href="#数组下标运算符作为访问器和修改器" class="headerlink" title="数组下标运算符作为访问器和修改器"></a>数组下标运算符作为访问器和修改器</h3></li>
</ul>
<ol>
<li><p>访问器和修改器：作为访问器就是用[]运算符读取数据，修改器就是用[]运算符修改数据</p>
</li>
<li><p>使r2[]成为左值的方法：使[]返回一个引用</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span>&amp; Vec2D::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;index) &#123; <span class="comment">//lvalue</span></span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> x_;  <span class="comment">//x_ can be modified</span></span><br><span class="line">      <span class="comment">//...... Now, the Vec2D class is mutable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>​    </p>
<h2 id="重载一元运算符"><span class="post-title-index">3.4 </span><a href="#重载一元运算符" class="headerlink" title="重载一元运算符"></a>重载一元运算符</h2><h3 id="单目运算符"><span class="post-title-index">3.4.1 </span><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h3><ol>
<li><p>主要的单目运算符：—, ++, -（负号）, *（解引用）</p>
</li>
<li><p>编译器执行过程：</p>
<ul>
<li><p>若operator @是在obj的类的<strong>成员函数</strong>，则调用obj.operator @()【无参数】</p>
</li>
<li><p>若operator @是obj的类的<strong>友元函数</strong>，则调用operator @(obj)</p>
</li>
</ul>
</li>
</ol>
<h3 id="重载负号运算符"><span class="post-title-index">3.4.2 </span><a href="#重载负号运算符" class="headerlink" title="重载负号运算符"></a>重载负号运算符</h3><h4 id="调用"><span class="post-title-index">3.4.2.1 </span><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Vec2D v2 = -v1;  <span class="comment">// 向量v1求负值；v1的值不变</span></span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">toString</span>();</span><br></pre></td></tr></table></figure>
<h4 id="重载负号运算符-1"><span class="post-title-index">3.4.2.2 </span><a href="#重载负号运算符-1" class="headerlink" title="重载负号运算符"></a>重载负号运算符</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec2D* Vec2D::<span class="keyword">operator</span>-()&#123;</span><br><span class="line">    <span class="keyword">return</span> *Vec2D*(-<span class="keyword">this</span>-&gt;x_**,** **-**<span class="keyword">this</span>-&gt;y_); <span class="comment">// 返回匿名临时对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载-和-运算符"><span class="post-title-index">3.4.3 </span><a href="#重载-和-运算符" class="headerlink" title="重载++和- -运算符"></a>重载++和- -运算符</h3><h4 id="前置、后置运算符与操作顺序"><span class="post-title-index">3.4.3.1 </span><a href="#前置、后置运算符与操作顺序" class="headerlink" title="前置、后置运算符与操作顺序"></a>前置、后置运算符与操作顺序</h4><ul>
<li><p>前置：先增减后取值，表达式是lvalue</p>
</li>
<li><p>后置：先取值（存在某个地方）后增减，表达式是prvalue（纯右值）</p>
<ul>
<li>举例：<ul>
<li>b = (a++) / 2 这一算式中，会先把a的值取出来放到某处，假设为temp（temp将被用于参加整个表达式的后续计算），之后a会被+1，a的值被改变。</li>
<li>b = (++a) / 2 这一算式，则直接将a值+1，并用a进行后续计算，没有temp这一环节。</li>
</ul>
</li>
<li>代码示例：</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">//v1: (3, 4)</span></span><br><span class="line">Vec2D v2 = ++v1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2: &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v2: (3, 4)</span></span><br><span class="line"><span class="function">Vec2D <span class="title">v3</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Vec2D v4 = v3++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v3: &quot;</span> &lt;&lt; v3.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v3: (3, 4)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v4: &quot;</span> &lt;&lt; v4.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v4: (2, 3)</span></span><br></pre></td></tr></table></figure>
<h4 id="前置与后置在函数定义中的区别"><span class="post-title-index">3.4.3.2 </span><a href="#前置与后置在函数定义中的区别" class="headerlink" title="前置与后置在函数定义中的区别"></a>前置与后置在函数定义中的区别</h4><p><img src="https://i.loli.net/2021/05/06/jc7uy5ZGzi2CRos.png" alt="image-20210426215559462"></p>
<ul>
<li><p>前置++/—重载无参数，返回引用类型</p>
</li>
<li><p>后置++/—重载带参数——“dummy”</p>
<ul>
<li>这个参数用于表示这是一个后置运算符，实际调用的时候并不会传参</li>
</ul>
</li>
<li>若在类外定义，则不论前置后置都需要参数</li>
</ul>
<h4 id="重载实例-1"><span class="post-title-index">3.4.3.3 </span><a href="#重载实例-1" class="headerlink" title="重载实例"></a>重载实例</h4><ul>
<li>前置++运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec2D&amp; Vec2D::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    x_ += <span class="number">1</span>;</span><br><span class="line">    y_ += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后置++运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Vec2D Vec2D::<span class="keyword">operator</span>++(<span class="keyword">int</span> dummy)&#123;</span><br><span class="line">    <span class="function">Vec2D <span class="title">temp</span><span class="params">(<span class="keyword">this</span>-&gt;x_, <span class="keyword">this</span>-&gt;y_)</span></span>;</span><br><span class="line">    x_ += <span class="number">1</span>;</span><br><span class="line">    y_ += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">//返回的是未自增的对象，是一个纯右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>两条返回语句的不同</strong>导致了前置++和后置++的区别</li>
</ul>
<h2 id="重载流插入-lt-lt-提取-gt-gt-运算符"><span class="post-title-index">3.5 </span><a href="#重载流插入-lt-lt-提取-gt-gt-运算符" class="headerlink" title="重载流插入(&lt;&lt;)/提取(&gt;&gt;)运算符"></a>重载流插入(&lt;&lt;)/提取(&gt;&gt;)运算符</h2><h3 id="重载-lt-lt-gt-gt-的目的"><span class="post-title-index">3.5.1 </span><a href="#重载-lt-lt-gt-gt-的目的" class="headerlink" title="重载&lt;&lt;/&gt;&gt;的目的"></a>重载&lt;&lt;/&gt;&gt;的目的</h3><p>能够把对象信息直接输出，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; vec2d;</span><br><span class="line">cin &gt;&gt; vec2d;</span><br></pre></td></tr></table></figure>
<h3 id="重载为友元函数"><span class="post-title-index">3.5.2 </span><a href="#重载为友元函数" class="headerlink" title="重载为友元函数"></a>重载为友元函数</h3><ol>
<li><p>为什么不能重载为成员函数</p>
<p> 运算符重载为类成员函数后，当调用该运算符时，左操作数必须是该类的实例。若&lt;&lt;和&gt;&gt;重载为成员函数，则只能用 v1&lt;&lt;cout; 如下所示：</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*重载为成员函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream);</span><br><span class="line">    istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;stream);</span><br><span class="line">&#125;;</span><br><span class="line">Vec2D v1;</span><br><span class="line">v1 &lt;&lt; cout; <span class="comment">//Vec2D对象只能作为第一个操作数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*重载为友元函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2D</span> &#123;</span> </span><br><span class="line">  <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream, Vec2D &amp;v);</span><br><span class="line">  <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;stream, Vec2D &amp;v);</span><br><span class="line">&#125;;</span><br><span class="line">Vec2D v1;</span><br><span class="line">cout &lt;&lt; v1; <span class="comment">//更符合编程习惯</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为什么友元函数的返回值是<strong>ostream&amp;</strong>类型</p>
<p> 要实现cout&lt;&lt;x&lt;&lt;y; 这类<strong>连续输出</strong>的代码，想要输出y，cout&lt;&lt;x这一部分应该返回一个ostream类型，所以使用ostream&amp;作为返回值</p>
<blockquote>
<p>返回ostream类型与&amp;有什么联系？为什么一定是&amp;呢</p>
</blockquote>
</li>
</ol>
<h2 id="重载对象转换运算符"><span class="post-title-index">3.6 </span><a href="#重载对象转换运算符" class="headerlink" title="重载对象转换运算符"></a>重载对象转换运算符</h2><h3 id="重载目的"><span class="post-title-index">3.6.1 </span><a href="#重载目的" class="headerlink" title="重载目的"></a>重载目的</h3><ul>
<li>将Vec2D对象转换为double数时，我们可以求该对象的范数，也就是向量长度</li>
</ul>
<h3 id="重载实例-2"><span class="post-title-index">3.6.2 </span><a href="#重载实例-2" class="headerlink" title="重载实例"></a>重载实例</h3><ul>
<li>类型转换函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec2D::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="comment">//操作符名称和要转到的类型同名，类似于构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">magnitude</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用实例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = v1 + <span class="number">5.1</span>; <span class="comment">// d: 10.1</span></span><br><span class="line"><span class="keyword">double</span> e = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(v1);  <span class="comment">// e: 5.0</span></span><br></pre></td></tr></table></figure>
<h2 id="重载赋值运算符"><span class="post-title-index">3.7 </span><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h2><p><a href="https://www.icourse163.org/learn/BUPT-1003564002?tid=1461043448#/learn/content?type=detail&amp;id=1237770721&amp;cid=1257884782">C++程序设计（面向对象进阶）_中国大学MOOC(慕课) (icourse163.org)</a></p>
]]></content>
      <categories>
        <category>专业</category>
        <category>语言学习</category>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Haskell语言学习笔记</title>
    <url>/2021/08/07/Haskell%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>学习Haskell函数式编程语言，第一部分，基础知识和基本函数语法。<span id="more"></span></p>
<h1 id="基础知识"><span class="post-title-index">1 </span><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="语法清单"><span class="post-title-index">1.1 </span><a href="#语法清单" class="headerlink" title="语法清单"></a>语法清单</h2><ul>
<li><font color="c7254e"><code>let a = 7</code></font>：let 用于定义常量，常量名、函数名必须首字母小写</li>
</ul>
<h2 id="List、德州区间和-List-Comprehension"><span class="post-title-index">1.2 </span><a href="#List、德州区间和-List-Comprehension" class="headerlink" title="List、德州区间和 List Comprehension"></a>List、德州区间和 List Comprehension</h2><h3 id="List"><span class="post-title-index">1.2.1 </span><a href="#List" class="headerlink" title="List"></a>List</h3><p>List是一种单类型的数据结构，可以用来存储多个<font color="blue"><strong>类型相同</strong></font>的元素。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> lostNumbers = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; lostNumbers    </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>] </span><br></pre></td></tr></table></figure>
<p>如上，一个List由方括号括起，其中的元素用逗号分隔开来。</p>
<ul>
<li><p><font color="c7254e"><code>&quot;hello&quot; ++ &quot; &quot; ++ &quot;world&quot;</code></font> 得到 <font color="c7254e"><code>&quot;hello world&quot;</code></font>：++运算符，用于连接两个List</p>
</li>
<li><p><font color="c7254e"><code>5:[1,2,3,4,5]</code></font> 得到 <font color="c7254e"><code>[5,1,2,3,4,5]</code></font>：使用:运算符往一个List前端插入元素</p>
</li>
<li><p><font color="c7254e"><code>&quot;Steve Buscemi&quot; !! 6</code></font> 得到  <font color="c7254e"><code>B</code></font>：使用!!运算符按照索引取得List中的元素</p>
</li>
<li>用&gt; &lt; &gt;= = 等符号进行List间的比较</li>
<li>其余常用函数参见 <a href="https://www.w3cschool.cn/hsriti/y2biqozt.html">第二章 Haskell入门_w3cschool</a></li>
</ul>
<h3 id="德州区间"><span class="post-title-index">1.2.2 </span><a href="#德州区间" class="headerlink" title="德州区间"></a>德州区间</h3><p>区间（Range）是构造 List 方法之一，而其中的值必须是可枚举的，如1、2、3，A、B、C等。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1.</span><span class="number">.20</span>]   <span class="comment">--简单的区间</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>,<span class="number">4.</span><span class="number">.20</span>] <span class="comment">--带步长的区间</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])   <span class="comment">--cycle用于循环单个List</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (repeat <span class="number">5</span>)        <span class="comment">--repeat用于循环单个值</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="List-Comprehension"><span class="post-title-index">1.2.3 </span><a href="#List-Comprehension" class="headerlink" title="List Comprehension"></a>List Comprehension</h3><p>List Comprehension能够更加方便自由地生成List，类似于集合的描述法：</p>
<script type="math/tex; mode=display">
\{x\ |\ x∈Z\}</script><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]   <span class="comment">--前10个整数</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50.</span><span class="number">.100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>] <span class="comment">--取50到100间所有除7的余数为3的元素</span></span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]] <span class="comment">--从多个List中取元素</span></span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Tuple"><span class="post-title-index">1.3 </span><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Tuple （元组）要求你对需要组合的数据的数目非常的明确，它的类型取决于其中<font color="blue"><strong>项的数目</strong></font>与其<font color="blue"><strong>各自的类型</strong></font>。 Tuple 中的项由括号括起，并由逗号隔开。另外，Tuple 中的项不必为同一类型，在 Tuple 里可以存入<font color="blue"><strong>多类型</strong></font>项的组合。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fst (<span class="number">8</span>,<span class="number">11</span>)   <span class="comment">--返回一个序对的首项</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; snd (<span class="number">8</span>,<span class="number">11</span>)   <span class="comment">--返回一个序对的尾项</span></span><br><span class="line"><span class="number">11</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上述两个函数仅对序对有效，而不能应用于三元组，四元组和五元组之上。</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]   <span class="comment">--zip 生成一组序对的List</span></span><br><span class="line">[(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">5</span>)]  </span><br></pre></td></tr></table></figure>
<h2 id="类型和类型类"><span class="post-title-index">1.4 </span><a href="#类型和类型类" class="headerlink" title="类型和类型类"></a>类型和类型类</h2><ul>
<li><p><a href="https://www.w3cschool.cn/hsriti/h72qkozt.html">第三章 Haskell类型和类型类_w3cschool</a></p>
</li>
<li><p>Haskell 的类型必须是首字母大写</p>
</li>
<li><p>使用:t命令后跟任何可用的表达式，可以检测表达式的类型</p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t &#x27;a&#x27;   </span><br><span class="line">&#x27;a&#x27; :: <span class="type">Char</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">True</span>   </span><br><span class="line"><span class="type">True</span> :: <span class="type">Bool</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="string">&quot;HELLO!&quot;</span>   </span><br><span class="line"><span class="string">&quot;HELLO!&quot;</span> :: [<span class="type">Char</span>]   <span class="comment">--[char] &lt;=&gt; String</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t (<span class="type">True</span>, &#x27;a&#x27;)   </span><br><span class="line">(<span class="type">True</span>, &#x27;a&#x27;) :: (<span class="type">Bool</span>, <span class="type">Char</span>)   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="number">4</span> == <span class="number">5</span>   </span><br><span class="line"><span class="number">4</span> == <span class="number">5</span> :: <span class="type">Bool</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义函数时，可以定义参数和返回值类型，参数之间以及参数和返回值之间均使用<font color="c7254e"><code>-&gt;</code></font>分隔</p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>   <span class="comment">--三个参数，一个返回值</span></span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="函数语法"><span class="post-title-index">2 </span><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h1><h2 id="函数声明方法"><span class="post-title-index">2.1 </span><a href="#函数声明方法" class="headerlink" title="函数声明方法"></a>函数声明方法</h2><ul>
<li><p>函数声明：先<font color="blue"><strong>函数名</strong></font>，后跟由空格分隔的<font color="blue"><strong>参数表</strong></font>。声明中一定要在<font color="c7254e"><code>=</code></font>后面定义函数的<font color="blue"><strong>行为</strong></font></p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">doubleMe</span> x = x + x  <span class="comment">--功能：将一个数字乘以2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在其他函数中调用自己编写的函数，不用考虑函数出现的先后顺序</p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">doubleUs</span> x y = doubleMe x + doubleMe y  <span class="comment">--功能：接收两个参数，返回它们的和的2倍</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>为函数编写明确的类型声明是一个好习惯</p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--功能：过滤大写字母</span></span><br><span class="line"><span class="title">removeNonUppercase</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]   </span><br><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c  st, c `elem` [&#x27;<span class="type">A&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">--功能：三个整数相加</span></span><br><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>   </span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="模式匹配"><span class="post-title-index">2.2 </span><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配通过检查数据的特定结构来检查其是否匹配，并按模式从中取得数据。类似于<font color="c7254e"><code>switch...case...</code></font>结构。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">&quot;One!&quot;</span>   <span class="comment">--这里 “1” 是参数</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">&quot;Two!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">&quot;Three!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">&quot;Four!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">&quot;Five!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">&quot;Not between 1 and 5&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">--如果把最后匹配一切的那个模式挪到最前，它的结果就全都是&quot;Not between 1 and 5&quot;</span></span><br></pre></td></tr></table></figure>
<p>【<strong>注意</strong>】</p>
<ul>
<li>不可以在模式匹配中使用 <font color="c7254e"><code>++</code></font></li>
</ul>
<h3 id="对Tuple使用模式匹配"><span class="post-title-index">2.2.1 </span><a href="#对Tuple使用模式匹配" class="headerlink" title="对Tuple使用模式匹配"></a>对Tuple使用模式匹配</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--不会模式匹配的时候</span></span><br><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> a b = (fst a + fst b, snd a + snd b) </span><br><span class="line"></span><br><span class="line"><span class="comment">--一个更好的方法</span></span><br><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  </span><br></pre></td></tr></table></figure>
<p>用模式匹配实现针对三元组的first、second、third函数</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a   </span><br><span class="line"><span class="title">first</span> (x, _, _) = x        </span><br><span class="line"><span class="comment">--&quot;_&quot;表示我们不关心这部分的具体内容</span></span><br><span class="line"></span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b   </span><br><span class="line"><span class="title">second</span> (_, y, _) = y   </span><br><span class="line"></span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c   </span><br><span class="line"><span class="title">third</span> (_, _, z) = z </span><br></pre></td></tr></table></figure>
<h3 id="在List-Comprehension中使用模式匹配"><span class="post-title-index">2.2.2 </span><a href="#在List-Comprehension中使用模式匹配" class="headerlink" title="在List Comprehension中使用模式匹配"></a>在List Comprehension中使用模式匹配</h3><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> xs = [(<span class="number">1</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">5</span>,<span class="number">3</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">1</span>)]   </span><br><span class="line"><span class="title">ghci</span>&gt; [a+b | (a,b)  xs]   </span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
<p>一旦模式匹配失败，它就简单挪到下个元素。</p>
<h3 id="对List使用模式匹配"><span class="post-title-index">2.2.3 </span><a href="#对List使用模式匹配" class="headerlink" title="对List使用模式匹配"></a>对List使用模式匹配</h3><p>用<font color="c7254e"><code>[]</code></font>或<font color="c7254e"><code>:</code></font>来匹配List。例如：</p>
<ul>
<li><font color="c7254e"><code>x:xs</code></font>模式，可以将list的头部绑定为x，尾部绑定为xs，但这种模式只能匹配长度<font color="blue"><strong>大于等于1</strong></font>的List，因此对于空的List需要进行特殊判断。</li>
<li><font color="c7254e"><code>x:y:z:xs</code></font>模式，可以将List的前三个元素都绑定到变量中，但只能匹配长度<font color="blue"><strong>大于等于3</strong></font>的List，因此对于长度小于3的List需要进行特殊判断。</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--实现一个自己的 head 函数</span></span><br><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a   </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span></span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x  </span><br></pre></td></tr></table></figure>
<h3 id="as模式"><span class="post-title-index">2.2.4 </span><a href="#as模式" class="headerlink" title="as模式"></a>as模式</h3><p>所谓<font color="c7254e"><code>as</code></font>模式，就是将一个名字和<font color="c7254e"><code>@</code></font>置于模式前，可以在按模式分割什么东西时仍保留对其整体的引用。如这个模式<font color="c7254e"><code>xs@(x:y:ys)</code></font>，它会匹配出与<font color="c7254e"><code>x:y:ys</code></font>对应的东西，同时你也可以方便地通过<font color="c7254e"><code>xs</code></font>得到整个list，而不必在函数体中重复<font color="c7254e"><code>x:y:ys</code></font>。</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--代码--</span></span><br><span class="line"><span class="title">capital</span> :: <span class="type">String</span> -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">capital</span> <span class="string">&quot;&quot;</span> = <span class="string">&quot;Empty string, whoops!&quot;</span>   </span><br><span class="line"><span class="title">capital</span> all@(x:xs) = <span class="string">&quot;The first letter of &quot;</span> ++ all ++ <span class="string">&quot; is &quot;</span> ++ [x] </span><br><span class="line"></span><br><span class="line"><span class="comment">--执行结果--</span></span><br><span class="line"><span class="title">ghci</span>&gt; capital <span class="string">&quot;Dracula&quot;</span>   </span><br><span class="line"><span class="string">&quot;The first letter of Dracula is D&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="门卫"><span class="post-title-index">2.3 </span><a href="#门卫" class="headerlink" title="门卫"></a>门卫</h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--一个用到了门卫的函数--</span></span><br><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">bmiTell</span> bmi   </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>   </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>门卫由跟在函数名及参数后面的<font color="blue"><strong>竖线</strong></font>标志，通常他们都是靠右一个缩进排成一列。一个门卫就是<font color="blue"><strong>一个布尔表达式</strong></font>，如果为真，就使用其对应的函数体。如果为假，就送去见下一个门卫，如之继续。</p>
</li>
<li><p>如果一个函数的所有门卫都没有通过（而且没有提供otherwise作万能匹配），就转入下一模式。这便是门卫与模式契合的地方。如果始终没有找到合适的门卫或模式，就会发生一个错误。</p>
</li>
</ul>
<h2 id="where绑定"><span class="post-title-index">2.4 </span><a href="#where绑定" class="headerlink" title="where绑定"></a>where绑定</h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--使用where关键字从而避免重复工作</span></span><br><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">bmiTell</span> weight height   </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>   </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>   </span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>where关键字跟在门卫后面（最好是与竖线缩进一致）。</li>
<li>可以定义多个名字和函数，这些名字对每个门卫都是可见的。</li>
<li>函数在where绑定中定义的名字只对本函数可见，因此我们不必担心它会污染其他函数的命名空间。</li>
<li><p>where绑定不会在多个模式中共享。如果你在一个函数的多个模式中重复用到同一名字，就应该把它置于全局定义之中。</p>
</li>
<li><p>where绑定也可以使用<strong>模式匹配</strong></p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line">...   </span><br><span class="line"><span class="title">where</span> bmi = weight / height ^ <span class="number">2</span>   </span><br><span class="line">      (skinny, normal, fat) = (<span class="number">18.5</span>, <span class="number">25.0</span>, <span class="number">30.0</span>) </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="let绑定"><span class="post-title-index">2.5 </span><a href="#let绑定" class="headerlink" title="let绑定"></a>let绑定</h2><figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="comment">--依据半径和高度求圆柱体表面积--</span></span><br><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a   </span><br><span class="line"><span class="title">cylinder</span> r h =  </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h   </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>   </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br></pre></td></tr></table></figure>
<p>let的格式为<font color="c7254e"><code>let [bindings] in [expressions]</code></font>。在let中绑定的名字仅对in部分可见。let里面定义的名字也得对齐到一列。</p>
<blockquote>
<p><strong>note：</strong><font color="blue"><strong>let绑定和where绑定的区别：</strong> </font></p>
<font color="blue">**（1）where绑定是个语法结构，let绑定是个表达式，可以随处安放（就像if语句一样）。**</font>

<font color="blue">**（2）let定义域限制的相当小，因此不能在多个门卫中使用。where跟在函数体后面，主函数体距离类型声明近一些，会更易读。**</font>

</blockquote>
<ul>
<li><p>let可以定义<strong>局部函数</strong></p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]  </span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)] </span><br></pre></td></tr></table></figure>
</li>
<li><p>若要在一行中<strong>绑定多个名字</strong>，可以用分号将其分开</p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> a = <span class="number">100</span>; b = <span class="number">200</span>; c = <span class="number">300</span> <span class="keyword">in</span> a*b*c, <span class="keyword">let</span> foo=<span class="string">&quot;Hey &quot;</span>; bar = <span class="string">&quot;there!&quot;</span> <span class="keyword">in</span> foo ++ bar)  </span><br><span class="line">(<span class="number">6000000</span>,<span class="string">&quot;Hey there!&quot;</span>) </span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在let绑定中使用<strong>模式匹配</strong>。这在从Tuple取值之类的操作中很方便。</p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> (a,b,c) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">in</span> a+b+c) * <span class="number">100</span>  </span><br><span class="line"><span class="number">600</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以把let绑定放到<strong>List Comprehension</strong>中。我们重写下那个计算bmi值的函数，用个let替换掉原先的where。</p>
  <figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi | (w, h) xs, <span class="keyword">let</span> bmi = w / h ^ <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="case表达式"><span class="post-title-index">2.6 </span><a href="#case表达式" class="headerlink" title="case表达式"></a>case表达式</h2><p>模式匹配本质上不过就是case语句的语法糖而已。这两段代码就是完全等价的：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x </span><br></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a   </span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;No head for empty lists!&quot;</span>   </span><br><span class="line">                      (x:_) -&gt; x  </span><br></pre></td></tr></table></figure>
<p><strong>case表达式的语法：</strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result   </span><br><span class="line">                   pattern -&gt; result   </span><br><span class="line">                   pattern -&gt; result   </span><br><span class="line">                   ...  </span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>note：</strong><font color="blue"><strong>case表达式和模式匹配的区别：</strong></font></p>
<p>​        <font color="blue"><strong>函数参数的模式匹配只能在定义函数时使用，而case表达式可以用在任何地方</strong></font></p>
</blockquote>
<h1 id="关于函数式编程和Haskell的参考文章"><span class="post-title-index">3 </span><a href="#关于函数式编程和Haskell的参考文章" class="headerlink" title="关于函数式编程和Haskell的参考文章"></a>关于函数式编程和Haskell的参考文章</h1><p><a href="https://www.infoq.cn/article/u4eNCEwHEfBZUHpE4RVo">Clojure和Haskell——深度学习中的函数式语言之美-InfoQ</a></p>
<p><a href="https://www.infoq.cn/article/2009/02/rwh-book-interview">学习Haskell的现实意义-InfoQ</a></p>
<p>上学期看崔毅东老师的C++课程时，依稀记得老师提到了这门语言，于是大概学习了一下，第一次接触函数式编程的思想，蛮有趣但还是比较懵，之后再找找实战玩玩看。</p>
]]></content>
      <categories>
        <category>专业</category>
        <category>语言学习</category>
        <category>Haskell</category>
      </categories>
      <tags>
        <tag>Haskell</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络LAB_1——数据链路层协议实现</title>
    <url>/2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CLAB_1%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本次实验的整理，包括LAB文档内容梳理和实验报告。<span id="more"></span></p>
<h1 id="LAB文档内容梳理"><span class="post-title-index">1 </span><a href="#LAB文档内容梳理" class="headerlink" title="LAB文档内容梳理"></a>LAB文档内容梳理</h1><h2 id="样例程序分析"><span class="post-title-index">1.1 </span><a href="#样例程序分析" class="headerlink" title="样例程序分析"></a>样例程序分析</h2><h3 id="datalink-h"><span class="post-title-index">1.1.1 </span><a href="#datalink-h" class="headerlink" title="datalink.h"></a>datalink.h</h3><p>首先定义了帧的种类，在数据链路层传递的所有帧，分为数据帧、ACK（确认）帧、NAK（否定确认）帧</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FRAME kind */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_DATA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_ACK  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_NAK  3</span></span><br></pre></td></tr></table></figure>
<p>之后给出了三种帧的具体结构，小括号内是该段信息的大小，单位为字节：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    DATA Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | SEQ(1) | ACK(1) | DATA(240~256) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	ACK Frame</span></span><br><span class="line"><span class="comment">	+=========+========+========+</span></span><br><span class="line"><span class="comment">	| KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">	+=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	NAK Frame</span></span><br><span class="line"><span class="comment">	+=========+========+========+</span></span><br><span class="line"><span class="comment">	| KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">	+=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>KIND： 1字节，表示这个帧的种类（可取1,2,3）</p>
<p>SEQ：   1字节，数据帧序号，如果类型为unsigned char，可表示的范围是 0 ~ 255</p>
<p>ACK：   ACK帧或NAK帧的序号</p>
<p>DATA：数据帧中的数据段</p>
<p>CRC：   冗余码部分</p>
<h2 id="事件"><span class="post-title-index">1.2 </span><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="五种事件类型"><span class="post-title-index">1.2.1 </span><a href="#五种事件类型" class="headerlink" title="五种事件类型"></a>五种事件类型</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETWORK_LAYER_READY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSICAL_LAYER_READY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_RECEIVED 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMEOUT 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMEOUT 4</span></span><br></pre></td></tr></table></figure>
<p><strong>NETWORK_LAYER_READY：</strong><br>当网络层有新的分组需要发送并且未被链路层disable，会产生NETWORK_LAYER_READY事件；否则网络层自行缓冲待发送分组。此事件发生后才可以调用get_packet()得到网络层待发送的下一个分组。</p>
<p><strong>PHYSICAL_LAYER_READY：</strong><br>物理层发送队列的长度低于50字节。（3.3）</p>
<p><strong>FRAME_RECEIVED：</strong><br>物理层收到了一整帧 。</p>
<p><strong>DATA_TIMEOUT：</strong><br>超时发生时，产生 DATA_TIMEOUT事件， 并给出超时的定时器编号。<strong>发生超时的定时器的编号在参数 arg中返回。</strong></p>
<p><strong>ACK_TIMEOUT：</strong><br>所设置的搭载ACK定时器超时。</p>
<h3 id="程序流程示意"><span class="post-title-index">1.2.2 </span><a href="#程序流程示意" class="headerlink" title="程序流程示意"></a>程序流程示意</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enable_network_layer</span>();</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">event = <span class="built_in">wait_for_event</span>(&amp;arg);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (event) &#123;</span><br><span class="line"><span class="keyword">case</span> EVENT_NETWORK_LAYER_READY:</span><br><span class="line">len = <span class="built_in">get_packet</span>(my_buf);</span><br><span class="line">… …</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_PHYSICAL_LAYER_READY:</span><br><span class="line">… …</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_FRAME_RECEIVED:</span><br><span class="line">rbuf_len = <span class="built_in">recv_frame</span>(rbuf, <span class="keyword">sizeof</span> rbuf);</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_ACK_TIMEOUT:</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_DATA_TIMEOUT:</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line"><span class="built_in">enable_network_layer</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">disable_network_layer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接口函数及库函数"><span class="post-title-index">1.3 </span><a href="#接口函数及库函数" class="headerlink" title="接口函数及库函数"></a>接口函数及库函数</h2><h3 id="初始化协议"><span class="post-title-index">1.3.1 </span><a href="#初始化协议" class="headerlink" title="初始化协议"></a>初始化协议</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void protocol<span class="constructor">_init(<span class="params">int</span> <span class="params">argc</span>, <span class="params">char</span> <span class="operator">**</span><span class="params">argv</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>必须首先调用此函数对运行环境初始化。该函数的两个参数必<br>须传递 main()函数的两个同名参数。这样做的目的是从命令行参数中获取站点名及某些选项以提供一种配置系统参数的手段。这些 选项包括 重新 指定日志文件，指定 TCP端口号， 设定误码率，等等。当命令行中重新指定了新的参数值，默认值就不再起作用。</p>
<p>protocol_init()建立两个站点之间的 TCP连接，并且设定时间坐标的 参考 0点，通信的两个站点的时间坐标 0点在建立 TCP连接时被设置成相同的参考时间点 。</p>
<p>输出样例：</p>
<p><img src="https://i.loli.net/2021/05/06/pZ3XQuv2S6qxGBy.png" alt="image-20210505142308591.png"></p>
<h3 id="网络层接口"><span class="post-title-index">1.3.2 </span><a href="#网络层接口" class="headerlink" title="网络层接口"></a>网络层接口</h3><h4 id="网络层包长度"><span class="post-title-index">1.3.2.1 </span><a href="#网络层包长度" class="headerlink" title="网络层包长度"></a>网络层包长度</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKT_LEN 256</span></span><br></pre></td></tr></table></figure>
<h4 id="流量控制函数"><span class="post-title-index">1.3.2.2 </span><a href="#流量控制函数" class="headerlink" title="流量控制函数"></a>流量控制函数</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_network_layer</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">disable_network_layer</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对于发送方向来说，网络层和数据链路层的约定为：数据链路层在缓冲区满等条件下无法发送分组<br>时通过 disable_network_layer()通知网络层；在能够承接新的发送任务时执行<br>enable_network_layer()允许网络层发送 数据 分组</p>
<h4 id="包处理函数"><span class="post-title-index">1.3.2.3 </span><a href="#包处理函数" class="headerlink" title="包处理函数"></a>包处理函数</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> get<span class="constructor">_packet(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">packet</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>参数：将分组拷贝到指针 p指定的缓冲区中。</p>
<p>返回值：分组长度</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void put<span class="constructor">_packet(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">packet</span>, <span class="params">int</span> <span class="params">len</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>参数：存放收到分组的缓冲区首地址，分组长度</p>
<blockquote>
<p><strong>统计功能：</strong></p>
<p>如果本次调用 put_packet()函数 比上次调用该函数的时间间隔超过 2秒，将给出一个接收方向的报告，格式如下所示：</p>
<p>480.484 …. 1784 packets received, 7611 bps, 95.14%, Err 38 (9.9e 006)</p>
<p>时间坐标为480.484秒，收到了 1784个分组，网络层有效数据传输率 7611bps，实际线路利用率95.14%，接收方向共检出 38个帧校验和错误，统计计算出实际误码率 9.9x10 6。</p>
</blockquote>
<h3 id="物理层接口"><span class="post-title-index">1.3.3 </span><a href="#物理层接口" class="headerlink" title="物理层接口"></a>物理层接口</h3><h4 id="帧处理函数"><span class="post-title-index">1.3.3.1 </span><a href="#帧处理函数" class="headerlink" title="帧处理函数"></a>帧处理函数</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void send<span class="constructor">_frame(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">frame</span>, <span class="params">int</span> <span class="params">len</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>参数：将内存 frame处长度为 len的缓冲区块向物理层发送为一帧，每字节发送需要 1ms，帧与帧之间的边界保留 1ms。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> recv<span class="constructor">_frame(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">size</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>参数：从物理层接收一帧， size为用于存放接收帧的缓冲区 buf的空间大小</p>
<p>返回值：收到帧的实际长度 。</p>
<h4 id="查看队列长度"><span class="post-title-index">1.3.3.2 </span><a href="#查看队列长度" class="headerlink" title="查看队列长度"></a>查看队列长度</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phl_sq_len</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这个函数返回当前物理层队列的长度 。</p>
<h4 id="流量控制机制"><span class="post-title-index">1.3.3.3 </span><a href="#流量控制机制" class="headerlink" title="流量控制机制"></a>流量控制机制</h4><p>为协调数据链路层和物理层之间的流量，采用的机制是：只要在事件处理周期内至少一次调用过 send_frame()函数，那么，事件等待函数 wait_for_event()会在物理层发送队列低于50字节水平时，产生 PHYSICAL_LAYER_READY事件。</p>
<blockquote>
<p>例如：物理层当前队列长度 20字节，链路层调用send_frame()发送一 7字节 帧，那么，随后的事件等待函数 wait_for_event()会立即产生PHYSICAL_LAYER_READY事件；再如：物理层当前队列长度 40字节，链路层调用 send_frame()发送一300字节字节帧帧，受限于信道受限于信道8000bps的带宽，需要发送的数据不可能瞬间发送到线路上，的带宽，需要发送的数据不可能瞬间发送到线路上，wait_for_event()会在物理层队列由会在物理层队列由340字节降为字节降为50字节以下（至少需要字节以下（至少需要290毫秒）毫秒）后才产生后才产生PHYSICAL_LAYER_READY事件。</p>
</blockquote>
<p>在PHYSICAL_LAYER_READY事件后，如果 数据链路层 暂时没有需要发送的数据，因系统不会再次送来 PHYSICAL_LAYER_READY事件，应记录物理层状态，当有数据需要发送时直接发送。 物理层事件的这种处理方式类似于 硬件中的发送中断。</p>
<p>不顾物理层是否出于准备好状态而 调用 send_frame()发送多帧，受限于信道的 8000bps能力，会导致数据堆积在物理层发送队列的时间较长，等待物理层慢慢把数据发送出去。</p>
<p><strong>物理层发送队列最多可以保留 64K字节。</strong></p>
<h3 id="CRC校验的产生和验证"><span class="post-title-index">1.3.4 </span><a href="#CRC校验的产生和验证" class="headerlink" title="CRC校验的产生和验证"></a>CRC校验的产生和验证</h3><p>本次实验采用的CRC校验方案为 CRC 32，与 IEEE 802.3以太网校验和生成多项式相同。生成多项式为：<br>x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">crc32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数crc32()返回一 个 32比特整数。</p>
<blockquote>
<p>设指针 p的定义为 char * p并且 p指向一个缓冲区，缓冲区内有 243字节数据，为这 243字节数据生成 CRC 32校验和，并且把这 32比特校验和附在 243字节之后，执行下面的语句：(unsigned int *)(p + 243) = crc32(p, 243);<br><strong>注意：</strong><br>p所指缓冲区必须至少有 247字节有效空间，以防内存访问越界。</p>
<p>验证校验和的方法，对上面的例子，只需要判断crc32(p, 243 + 4)是否为 0：<br>校验和正确为 0，否则不为 0。</p>
</blockquote>
<h3 id="定时器管理"><span class="post-title-index">1.3.5 </span><a href="#定时器管理" class="headerlink" title="定时器管理"></a>定时器管理</h3><h4 id="get-ms"><span class="post-title-index">1.3.5.1 </span><a href="#get-ms" class="headerlink" title="get_ms"></a>get_ms</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_ms</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>get_ms()函数获取当前的时间坐标，单位为毫秒。</p>
<h4 id="start-timer"><span class="post-title-index">1.3.5.2 </span><a href="#start-timer" class="headerlink" title="start_timer"></a>start_timer</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">void start<span class="constructor">_timer(<span class="params">unsigned</span> <span class="params">int</span> <span class="params">nr</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">ms</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>start_timer()用于启动一个定时器。</p>
<p><strong>参数：</strong>计时器的编号，超时时间值。计时器的编号只允许在0~63之间，超时时间间隔的单位为毫秒。</p>
<p>超时发生时，产生 DATA_TIMEOUT事件， 并给出超时的定时器编号。<strong>发生超时的定时器的编号在参数 arg中返回。</strong></p>
<blockquote>
<p>例如： start_timer(3, 1200)启动 3号定时器，定时器的长度为 1.2秒 。</p>
</blockquote>
<p>系统在把截止到调用函数start_timer()时刻为止已经放入物理层发送队列的数据发送完毕后才开始启动计时（不是从当前时间开始计时）。</p>
<blockquote>
<p>例如：当前时间坐标为 5.100，物理层发送队列目前有 300字节，信道速率 8000bps，函数调用 start_timer(3, 1200)会导致 1.5秒之后 时间坐标 6.600处 3号定时器产生DATA_TIMEOUT事件 。</p>
</blockquote>
<p>在定时器未超时之前直接对同一个编号的定时器执行start_timer()调用， 将按照<strong>新的时间</strong>设置产生超时事件。</p>
<h4 id="stop-timer"><span class="post-title-index">1.3.5.3 </span><a href="#stop-timer" class="headerlink" title="stop_timer"></a>stop_timer</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>stop_timer()中止一个定时器。</p>
<p><strong>参数：</strong>要终止的定时器的编号</p>
<h4 id="start-ack-timer"><span class="post-title-index">1.3.5.4 </span><a href="#start-ack-timer" class="headerlink" title="start_ack_timer"></a>start_ack_timer</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_ack_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ms)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>与start_timer（3.5.2）的不同之处：</strong></p>
<ol>
<li>少了一个参数：定时器编号。意味着只有一个ACK定时器</li>
<li>ACK计时器启动时刻为当前时刻；</li>
<li>在ACK定时器未超时之前重新执行 start_ack_timer()调用，定时器将<strong>依然</strong>按照<strong>先前</strong>的时间设置产生超时事件 ACK_TIMEOUT。</li>
</ol>
<h4 id="stop-ack-timer"><span class="post-title-index">1.3.5.5 </span><a href="#stop-ack-timer" class="headerlink" title="stop_ack_timer"></a>stop_ack_timer</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_ack_timer</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>终止ACK计时器。</p>
<h3 id="跟踪、调试和输出"><span class="post-title-index">1.3.6 </span><a href="#跟踪、调试和输出" class="headerlink" title="跟踪、调试和输出"></a>跟踪、调试和输出</h3><h4 id="对printf的改良"><span class="post-title-index">1.3.6.1 </span><a href="#对printf的改良" class="headerlink" title="对printf的改良"></a>对printf的改良</h4><p>lprintf()函数</p>
<h4 id="debug输出"><span class="post-title-index">1.3.6.2 </span><a href="#debug输出" class="headerlink" title="debug输出"></a>debug输出</h4><ol>
<li><p><strong>debug_mask变量</strong></p>
<p> 一个静态整型变量，用于调试信息的输出控制，默认值为0。</p>
</li>
<li><p><strong>dbg_frame, dbg_event, dbg_warning</strong></p>
<p> 用 debug_mask的比特 0控制“事件”信息，比特 1控制“帧收发”信息：</p>
<p> 当 debug_mask的 0号比特为 0时，dbg_event()的所有输出被忽略；</p>
<p> 当 debug_mask的 1号比特为 0时，dbg_frame()的所有输出被忽略。</p>
</li>
</ol>
<h4 id="获取站点名"><span class="post-title-index">1.3.6.3 </span><a href="#获取站点名" class="headerlink" title="获取站点名"></a>获取站点名</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">station_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>此函数获取当前进程所对应的站点名，返回值为字符串 ”A”或者 ”B”。</p>
<h2 id="命令行选项"><span class="post-title-index">1.4 </span><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h2><p><img src="https://i.loli.net/2021/05/06/P1q6UxWy9zfcAJZ.png" alt="image-20210505141428458.png"></p>
<h2 id="错误信息"><span class="post-title-index">1.5 </span><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p><img src="https://i.loli.net/2021/05/06/TkN1AXZevEKlsQx.png" alt="image-20210505141514462.png"></p>
<h2 id="问题汇总"><span class="post-title-index">1.6 </span><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul>
<li><p><strong>between函数，为什么那么设计</strong></p>
</li>
<li><p>ack计时器，为什么只要一个，为什么send_frame之后立刻就stop_ack，start_ack又为什么是在收到帧的时候的操作，而不是发送帧的操作</p>
<ul>
<li>ack的计时器，其实是等待捎带ack的计时器。一切都迎刃而解。</li>
</ul>
</li>
<li><p><strong>关于滑动窗口的大小的计算，已经计算出滑动窗口大小&lt;4，为什么还能设为7，设为63？7和63又是如何得到的？</strong></p>
</li>
</ul>
<h1 id="实验报告"><span class="post-title-index">2 </span><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="实验内容及实验环境描述"><span class="post-title-index">2.1 </span><a href="#实验内容及实验环境描述" class="headerlink" title="实验内容及实验环境描述"></a>实验内容及实验环境描述</h2><h3 id="实验内容"><span class="post-title-index">2.1.1 </span><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>​        利用所学数据链路层原理，自己设计一个滑动窗口协议，在仿真环境下编程实现有噪音信道环境下两站点之间无差错双工通信。信道模型为8000bps 全双工卫星信道，信道传播时延270毫秒，信道误码率为10^-5，信道提供字节流传输服务，网络层分组长度固定为256字节。</p>
<p>​        本次实验选用的滑动窗口协议为带NAK和不带NAK的回退N协议，以及选择重传协议。</p>
<h3 id="实验环境"><span class="post-title-index">2.1.2 </span><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>​        Windows10，Microsoft Visual Studio 2019，PowerShell</p>
<h2 id="软件设计"><span class="post-title-index">2.2 </span><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="数据结构"><span class="post-title-index">2.2.1 </span><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="FRAME结构体"><span class="post-title-index">2.2.1.1 </span><a href="#FRAME结构体" class="headerlink" title="FRAME结构体"></a>FRAME结构体</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FRAME</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> kind;            <span class="comment">/*FRAME_DATA, FRAME_ACK, FRAME_NAK*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> seq;             <span class="comment">/*数据帧序号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ack;             <span class="comment">/*ACK帧或NAK帧的序号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[PKT_LEN];   <span class="comment">/*数据帧里的数据部分*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  padding;         <span class="comment">/*CRC冗余码部分*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>三种帧类型的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* FRAME kind */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_DATA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_ACK  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_NAK  3</span></span><br></pre></td></tr></table></figure>
<p>三种帧的具体结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DATA Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | SEQ(1) | ACK(1) | DATA(240~256) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ACK Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NAK Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="GBN协议宏定义和全局变量"><span class="post-title-index">2.2.1.2 </span><a href="#GBN协议宏定义和全局变量" class="headerlink" title="GBN协议宏定义和全局变量"></a>GBN协议宏定义和全局变量</h4><ul>
<li><strong>宏定义</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ 7         <span class="comment">//帧序号最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMER 1500   <span class="comment">//数据帧超时时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMER 300     <span class="comment">//等待捎带ACK的时间</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>全局变量</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> frame_expected = <span class="number">0</span>;           <span class="comment">//接受窗口期待接收的序号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[MAX_SEQ + <span class="number">1</span>][PKT_LEN]; <span class="comment">//发送窗口缓存区。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> ack_expected = <span class="number">0</span>;             <span class="comment">//发送窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> next_frame = <span class="number">0</span>;               <span class="comment">//发送窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> nbuffered;                    <span class="comment">//发送窗口缓冲区已使用的数量，已发送的帧数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> phl_ready = <span class="number">0</span>;                          <span class="comment">//物理层就绪标志。（为 1 就绪）</span></span><br><span class="line"><span class="keyword">int</span> no_nak = <span class="number">1</span>;                                    <span class="comment">//NAK有效标志（为 1 有效）</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<p>① 在GBN协议中，接收窗口大小规定为 1，发送窗口大小 = 帧序号数量 - 1 = 帧序号最大值。</p>
<p>② 发送窗口缓冲区的作用是：将每个已发送未确认的帧缓存下来，若出现丢包或坏帧则可以重发。因此，缓冲区大小和发送窗口大小相同。</p>
<h4 id="SR协议宏定义和全局变量"><span class="post-title-index">2.2.1.3 </span><a href="#SR协议宏定义和全局变量" class="headerlink" title="SR协议宏定义和全局变量"></a>SR协议宏定义和全局变量</h4><ul>
<li><strong>宏定义</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ 63                  <span class="comment">//帧序号最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_BUF ((MAX_SEQ + 1) / 2)  <span class="comment">//接收\发送窗口缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMER 3000             <span class="comment">//数据帧超时时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMER 1000              <span class="comment">//ACK帧超时时间</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>全局变量</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> out_buffer[NR_BUF][PKT_LEN];   <span class="comment">//发送窗口缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> in_buffer[NR_BUF][PKT_LEN];    <span class="comment">//接收窗口缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> ack_expected = <span class="number">0</span>;              <span class="comment">//发送窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> next_frame = <span class="number">0</span>;                <span class="comment">//发送窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> frame_expected = <span class="number">0</span>;            <span class="comment">//接收窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> too_far = NR_BUF;              <span class="comment">//接收窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> nbuffered;                     <span class="comment">//发送窗口缓冲区已使用的数量，已发送的帧数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> phl_ready = <span class="number">0</span>;                           <span class="comment">//物理层就绪标志。（为 1 就绪）</span></span><br><span class="line"><span class="keyword">int</span> no_nak = <span class="number">1</span>;                                     <span class="comment">//NAK有效标志（为 1 有效）</span></span><br><span class="line"><span class="keyword">int</span> arrv[NR_BUF];                                   <span class="comment">//接收窗口缓冲区标志（为 1 表示已占用）</span></span><br></pre></td></tr></table></figure>
<p>其中：接收\发送窗口缓冲区大小 = 发送窗口大小 = 接收窗口大小</p>
<h3 id="模块结构"><span class="post-title-index">2.2.2 </span><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><h4 id="子程序说明"><span class="post-title-index">2.2.2.1 </span><a href="#子程序说明" class="headerlink" title="子程序说明"></a>子程序说明</h4><blockquote>
<p>两个协议的子程序原理、作用及参数等大致相同，不再分开阐述</p>
</blockquote>
<ul>
<li><p><strong>static int between(unsigned char a, unsigned char b, unsigned char c)</strong></p>
<ul>
<li>函数作用：判断帧序号是否落在接收\发送窗口内，以此决定接下来的操作（缓存、发送ACK或者丢弃等）</li>
<li>参数：<ul>
<li>unsigned char a, unsigned char c：窗口的边界</li>
<li>unsigned char b：帧序号或ACK序号</li>
</ul>
</li>
<li>返回值：int 类型，若在窗口内，返回true（1），否则返回false（0）</li>
</ul>
</li>
<li><p><strong>char inc(char c)</strong></p>
<ul>
<li>函数作用：用于序号的循环有界递增。例如，帧序号最大值为3时，序号只能取 0,1,2,3,0,1,2…</li>
<li>参数：char c：需要递增的序号值</li>
<li>返回值：char类型，递增之后的结果</li>
</ul>
</li>
<li><p><strong>static void put_frame(unsigned char* frame, int len)</strong></p>
<ul>
<li>函数作用：为一帧添加CRC校验和，并将这一帧发送给物理层</li>
<li>参数：<ul>
<li>unsigned char* frame：指向这一帧的指针</li>
<li>int len：这一帧的长度，单位为字节</li>
</ul>
</li>
<li>无返回值</li>
</ul>
</li>
<li><p><strong>static void send_data_frame(void)</strong></p>
<ul>
<li><p>函数作用：发送数据帧</p>
</li>
<li><p>无参数</p>
<blockquote>
<p>这里与教材中是不同的，由于本协议实现中使用了大量全局变量，在传参方面省略了很多功夫</p>
</blockquote>
</li>
<li><p>无返回值</p>
</li>
</ul>
</li>
<li><p><strong>static void send_ack_frame(void)</strong></p>
<ul>
<li>函数作用：发送单独ACK帧</li>
</ul>
</li>
<li><p><strong>static void send_nak_frame(void)</strong></p>
<ul>
<li>函数作用：发送单独的NAK帧</li>
</ul>
</li>
</ul>
<h4 id="程序调用关系图"><span class="post-title-index">2.2.2.2 </span><a href="#程序调用关系图" class="headerlink" title="程序调用关系图"></a>程序调用关系图</h4><p><img src="https://i.loli.net/2021/05/06/P5WJxNwhGBRKFlt.png" alt="image-20210505182426979.png"></p>
<h4 id="响应分析"><span class="post-title-index">2.2.2.3 </span><a href="#响应分析" class="headerlink" title="响应分析"></a>响应分析</h4><ul>
<li><p><strong>GBN协议</strong></p>
<p>  <img src="https://i.loli.net/2021/05/06/hwXlKNHo81qUcba.png" alt="image-20210505171554501.png"></p>
</li>
<li><p><strong>SR协议</strong></p>
<p>  <img src="https://i.loli.net/2021/05/06/R9IxP674r3fHYLh.png" alt="image-20210505171638295.png"></p>
</li>
</ul>
<h4 id="算法流程图"><span class="post-title-index">2.2.2.4 </span><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h4><p><img src="https://i.loli.net/2021/05/06/N9k1zYTAbQjwrt2.png" alt="image-20210505182001929.png"></p>
<h2 id="实验结果分析"><span class="post-title-index">2.3 </span><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p><strong>1.描述你所实现的协议软件是否实现了有误码信道环境中无差错传输功能。</strong></p>
<p>实现了有误码信道环境中的无差错传输功能，采用了CRC校验和重传技术使错误得以发现和纠正</p>
<p><strong>2.程序的健壮性如何，能否可靠地长时间运行。</strong></p>
<p>程序健壮性强，在高负荷和高误码率等条件下均未出现过死锁现象，能够正常运行。线下测试时运行30min左右没有问题。</p>
<p><strong>3.协议参数的选取：滑动窗口的大小，重传定时器的时限，ACK 搭载定时器的时限，这些参数是怎样确定的？根据信道特性数据，分组层分组的大小，以及你的滑动窗口机制，给出定量分析，详细列举出选择这些参数值的具体原因。</strong></p>
<p>根据实验模型：8000bps全双工卫星信道，分组长度固定为 256 字节，单向传输时延为270ms，信道误码率（默认）10^-5，帧间间隔1ms。我对两个协议的窗口大小、重传定时器时限和ACK定时器时限进行了理论计算和实际测试。</p>
<p>①  <strong>滑动窗口的大小：</strong></p>
<p>滑动窗口大小直接涉及到信道利用率和数据拥塞问题，若窗口太小，将导致信道利用率过低，信道中长时间没有数据传送；若窗口太大，数据发送过快，将造成接收方被数据淹没，发生拥塞现象导致数据丢失，出错率增加。</p>
<ul>
<li>首先计算得到滑动窗口的最小值，设滑动窗口的大小 W，信道传输时延 t，数据率 c，帧长度 l 。则应有关系式如下：</li>
</ul>
<script type="math/tex; mode=display">
W >= [ 2t + 2 * (l/c) ] / (l/c)</script><blockquote>
<p>根据自定义的帧的数据结构可知，一个数据帧最长包括3字节的帧头（kind，seq，ack）、256字节的数据和4字节的 CRC 冗余码，共263字节。即此处l = 263 * 8 bit。代入其他数据计算可得，W &gt;= 4.05。</p>
</blockquote>
<ul>
<li>而滑动窗口的最大值与帧序列有关，设发送窗口大小 Ws，接收窗口大小为Wr，帧序列的二进制位数为 n。则有关系式如下：<script type="math/tex; mode=display">
Ws + Wr <= 2^n</script></li>
</ul>
<blockquote>
<p>在帧结构中，帧序列seq为unsigned char类型，大小为1字节，即n = 8。<br>在GBN协议中，Wr = 1，所以其Ws &lt;= 255 。<br>在SR协议中，Wr = Ws时效率最高，从而，Wr = Ws &lt;= 128</p>
</blockquote>
<ul>
<li>通过实际测试的结果分析得到合适的 W 值，最终发现，在 GBN 协议中，W 取 7 效率最高；在 SR 协议中，W 取 63 效率最高</li>
</ul>
<p>②  <strong>重传定时器时限和ACK定时器时限</strong>：</p>
<p>重传计时器的时限涉及到重传的响应时间，若太大，将导致重传等待的时间过久；若太小，将导致较为频繁的重传，两种情况均将导致信道利用率下降。</p>
<ul>
<li><p>估算重传定时器时限的<strong>下界 t</strong> ，考虑如下几个时间：</p>
<ul>
<li>每一帧的帧长为263B，由信道传输速率为 8000bps 可得<strong>数据发送延迟时间 Td</strong> 为 263ms 。</li>
<li><strong>传播时延 Ts</strong> 固定为 270ms 。</li>
<li>接收方接收完数据帧后，既可能以捎带 ACK 的方式发送 ACK ，也可能由于 ACK定时器超时而发送单独的 ACK 帧。这里显然应取：对方从接收完数据帧，到开始发送 ACK 的时间间隔的上界进行计算，不难看出，这个上界就是ACK定时器的时长 <strong>ACK_TIMER</strong></li>
<li>ACK 帧在物理层队列中<strong>排队的等待时间</strong>，同样以最坏情况进行计算，即在 ACK 帧之前存在等待发送的普通数据帧（已发送0字节）、重传数据帧和 NAK 帧，总计 263 + 263 + 6 = 532 字节，需要花费 532ms 才能发送完成。</li>
<li><strong>发送这个ACK 帧</strong>的时间为6ms，它在信道上的<strong>传输时延</strong>为270ms 。</li>
<li><p>物理层在发送数据帧时会在帧与帧之间添加 <strong>1ms 的时间间隔</strong>，最坏情况下增加 4ms 的时间。</p>
<p>综上有：</p>
</li>
</ul>
</li>
</ul>
<script type="math/tex; mode=display">
t = 263 + 270 + ACK\_TIMER + 532 + 6 + 270 + 4 = 1345 + ACK\_TIMER (ms)</script><ul>
<li><p>由此可得，重传定时器时限 t 与ACK定时器时限 ACK_TIMER 有关。我们知道，ACK定时器时限的一个最低的下界为数据链路层从网络层获得一个数据包的时间，经过多次的测试和分析，我们发现这个下界大约为200ms。而在实际测试中，当ACK定时器时限高于这个下界时可取得较高的效率。</p>
</li>
<li><p>最终，我们通过多次实验观察的方式，确定了 t 的最优值 : </p>
<ul>
<li>在 GBN 协议中令ACK定时器时限为 <strong>240 ms</strong>，在SR协议中，令ACK定时器时限为<strong>1000 ms</strong>。</li>
<li>重传定时器在 GBN 协议中取 <strong>2800ms</strong> 最优，在SR协议中取 <strong>3000ms</strong> 最优。</li>
</ul>
</li>
</ul>
<p><strong>4.理论分析：根据所设计的滑动窗口工作机制(Go-Back-N 或者选择重传)，推导出在无差错信道环境下分组层能获得的最大信道利用率；推导出在有误码条件下重传操作及时发生等理想情况下分组层能获得的最大信道利用率。给出理论推导过程。理论推导的目的是得到信道利用率的极限数据。为了简化有误码条件下的最大利用率推导过程，可以对问题模型进行简化，比如：假定超时重传的数据帧的回馈ACK 帧可以100%正确传输，但是简化问题分析的这些假设必须不会对整个结论产生较大的误差。</strong></p>
<ul>
<li><p>在无差错信道上，由于需要携带3字节的控制信息和4字节的校验位，因此最大的信道利用率为</p>
<script type="math/tex; mode=display">
  256/(256 + 3 + 4)= 97.3\%</script></li>
<li><p>在误码率为 1e-5 的信道上（即每传送 100000 个比特平均会发生 1 个错误）</p>
<blockquote>
<p>假设信道上始终有数据需要传送，则可以传送 100000/((256+3+4)*8) 约为 47 个数据包，即每 47 个数据包会有一个出错。</p>
<p>假设超时重传的数据帧的回馈ACK 帧可以100%正确传输，出错的是最后一个数据包，且每出错一次，在限定时间内可以正确重传该帧。</p>
</blockquote>
<p>  则每传送 47 个数据包需要传送 47+1+1 = 49 次。于是此时的信道利用率为</p>
<script type="math/tex; mode=display">
  (47 * 256)/(49 *(256+3+4)) ≈ 93.4 \%</script><p>  但由于程序设计并不能够达到理想状态，当一个数据包超时后，往往需要重复多次重传，造成信道浪费。若重传 K 次，则信道利用率为</p>
<script type="math/tex; mode=display">
  (47*256)/((48 + k) *(256+3+4))</script><p>  若平均重传10次，信道利用率约为 78.88% 。</p>
</li>
</ul>
<p><strong>5.实验结果分析：你的程序运行实际达到了什么样的效率，比对理论推导给出的结论，有没有差距？给出原因。有没有改进的办法？如果没有时间把这些方法付诸编程实施，介绍你的方案。</strong></p>
<p>实际达到的效率如下表所示：</p>
<p><img src="https://i.loli.net/2021/05/06/yjQkKdcia9BnDGU.png" alt="image-20210505210958256"></p>
<p>协议效率大部分达到了参考效率，但有一些数据与理想效率有差距，比如无误码情况下的97.3%，以及高误码率下的效率。考虑其原因，猜想主要有以下几方面：</p>
<ul>
<li>不能保证数据链路层和物理层之间没有延迟，ACK和重传的帧也不能100%正确，与理想的假设情况有区别</li>
<li>在高误码率的环境下，NAK帧的丢失有可能会导致一连串的重传，降低传输效率</li>
<li>所选的窗口大小和超时时间还不是最优的</li>
</ul>
<p>据此，提出以下方案：</p>
<ul>
<li>修改回退N步协议，添加NAK帧。根据实测结果（见上述表格），这种方法对回退N的效率有一定提升，但不明显。</li>
<li>对选择重传协议的NAK帧进行一定修改，拓宽其服务对象，设置NAK数组，对每一个缓冲区内的帧都可以单独发送NAK帧，这样可以缓解高误码率下NAK帧丢失、坏帧之后带来的一系列超时重传问题。</li>
<li>针对数据链路层与物理层之间的延迟，考虑取消PHYSICAL_LAYER_READY事件对NAK帧、ACK帧、超时重传的数据帧的限制，一旦产生这些帧，无论PHYSICAL_LAYER_READY事件是否发生，都可以直接发送。</li>
<li>通过有设计的实验，对误码率、传输速率、窗口大小、超时时间等量进行定量分析，借助dbg输出以及相关统计工具，从统计学角度对实验结果进行更加合理严谨的分析，通过图像、函数、求导等手段，得出理论上最优超时时间以及窗口大小。</li>
</ul>
<h2 id="研究和探索的问题"><span class="post-title-index">2.4 </span><a href="#研究和探索的问题" class="headerlink" title="研究和探索的问题"></a>研究和探索的问题</h2><p><strong>（1） CRC校验能力</strong></p>
<p>CRC校验码的检错能力很强，它除了能检查出离散错外，还能检查出突发错误。本次实验采用的CRC校验方案为CRC-32，与IEEE802.3以太网校验和生成多项式相同。生成多项式为：</p>
<p>x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+1</p>
<p>从其检错能力来看，不能发现传输错误的概率为2的-32次方，几乎接近于0，因此没有必要增加成本再去达到理论上为0的错误率。</p>
<p>另外一个方面，如果CRC校验错误而导致给网络层传输了错误数据，那么网络层也可以通过它的校验方式发现错误，采取重传，因此能够进一步保证传输正确性。</p>
<p><strong>（2）</strong> <strong>程序设计方面的问题</strong></p>
<p>①  协议软件跟踪功能为协议的调试提供了优质的方法，通过调用dbg_event和dbg_frame函数，可以清楚地观察协议的运行过程，可以非常自由的输出运行中的调试信息，并且跟踪到相应的代码段。我的程序多处调用dbg函数，实现了协议软件跟踪调试。</p>
<p>②  C语言的time.h当中提供了一些关于时间操作的函数可以用来实现get_ms()函数，如clock_t clock()。该函数返回程序开始执行后占用的处理器时间，如果无法获得占用时间则返回-1。只需在开始通信时，设置一个静态变量start_time。然后在每次调用get_ms()后，获取当前的时间current_time。然后再返回start_time-current_time即可。</p>
<p>③  如果本次实验提供的程序库中不包含log_printf和lprintf函数，可自己实现。</p>
<p>④  Start_timer()函数用于给发出的数据帧计时，如果超时还未收到确认ACK，便重发缓存中的数据帧。因此，在重新调用时应重新开始计时。Start_ack_timer()函数用于等待捎带确认的反向数据帧，若超时还没有反向数据帧，那就需要单独发送一个ACK帧。Start_ack_timer()在重新调用上的特点，就是为了避免ACK定时器时限过长使得发送方超时重发。</p>
<p><strong>（3）对等协议实体之间的流量控制</strong></p>
<p>我的协议解决了流量控制问题。作为滑动窗口协议，窗口本身就是一个流量控制，由于窗口大小的限制，发送方不会一次性发送过多信息导致接收方被数据所淹没或信息丢失。</p>
]]></content>
      <categories>
        <category>专业</category>
        <category>专业课程</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>网络协议</tag>
        <tag>计算机网络</tag>
        <tag>LAB</tag>
      </tags>
  </entry>
  <entry>
    <title>Python语法快速复习</title>
    <url>/2021/09/08/python%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="注释"><span class="post-title-index">1 </span><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>单行注释 <code>#</code></p>
<p>多行注释 <code>&quot;&quot;&quot;</code><span id="more"></span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一个多行注释</span></span><br><span class="line"><span class="string">可以添加很多内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="运算符"><span class="post-title-index">2 </span><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><span class="post-title-index">2.1 </span><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p><img src="https://i.loli.net/2021/09/01/sdfClKy5cA1MtO4.png" alt="image-20210901102028481.png"></p>
<p><img src="https://i.loli.net/2021/09/01/oZdBkxLTKyf9jrR.png" alt="image-20210901102810594"></p>
<h2 id="比较运算符"><span class="post-title-index">2.2 </span><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p><img src="https://i.loli.net/2021/09/03/s95aZFGM8OB347d.png" alt="image-20210903170056417"></p>
<h2 id="逻辑运算符"><span class="post-title-index">2.3 </span><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>and/ or/ not</p>
<h2 id="赋值运算符"><span class="post-title-index">2.4 </span><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><img src="https://i.loli.net/2021/09/07/gCiGKArHObPExoQ.png" alt="image-20210907153131004"></p>
<h1 id="变量"><span class="post-title-index">3 </span><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><span class="post-title-index">3.1 </span><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = content</span><br></pre></td></tr></table></figure>
<ul>
<li>每个变量在使用前必须赋值</li>
<li>变量赋值以后才会被创造</li>
<li>使用“等号”给变量赋值</li>
<li>变量定义后，后续可以直接使用</li>
</ul>
<h2 id="变量类型"><span class="post-title-index">3.2 </span><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p><img src="https://i.loli.net/2021/09/01/GSw5pTBU2hWN7Q1.png" alt="image-20210901110407523"></p>
<ul>
<li>数字型变量可以直接计算<ul>
<li>true 代表 1，false 代表 0</li>
</ul>
</li>
<li>使用 <code>+</code> 拼接字符串变量</li>
</ul>
<h3 id="类型转换函数"><span class="post-title-index">3.2.1 </span><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p><img src="https://i.loli.net/2021/09/01/axALYeHbGSp7DmT.png" alt="image-20210901114240692"></p>
<h2 id="变量的输入输出"><span class="post-title-index">3.3 </span><a href="#变量的输入输出" class="headerlink" title="变量的输入输出"></a>变量的输入输出</h2><ul>
<li>使用 <code>print</code> 输出变量</li>
<li>使用 <code>input</code> 获取用户从键盘的输入</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入银行密码:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(password)</span><br></pre></td></tr></table></figure>
<ul>
<li>input 括号中的字符串是提示信息</li>
<li>用户输入的任何内容都被认为是字符串</li>
<li>input 的返回值可以直接赋值给变量</li>
</ul>
<h3 id="变量的格式化输出"><span class="post-title-index">3.3.1 </span><a href="#变量的格式化输出" class="headerlink" title="变量的格式化输出"></a>变量的格式化输出</h3><p><img src="https://i.loli.net/2021/09/01/gVWEmGd7HMT4sft.png" alt="image-20210901114907260"></p>
<h2 id="变量的命名"><span class="post-title-index">3.4 </span><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h2><h3 id="标识符"><span class="post-title-index">3.4.1 </span><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li>字母数字下划线组成，开头不能是数字</li>
<li>标识符区分大小写</li>
<li>Python中，变量一般全部小写并用下划线分隔。（一般不使用驼峰法）</li>
</ul>
<h3 id="关键字"><span class="post-title-index">3.4.2 </span><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><a href="https://www.w3school.com.cn/python/python_ref_keywords.asp">Python 关键字 (w3school.com.cn)</a></p>
<h1 id="语句"><span class="post-title-index">4 </span><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="if语句"><span class="post-title-index">4.1 </span><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><img src="https://i.loli.net/2021/09/03/RwqZhvsAXyUdixr.png" alt="image-20210903165926985"></p>
<p><img src="https://i.loli.net/2021/09/03/Nw1Uc6nV357fIzE.png" alt="image-20210903170257595"></p>
<p><img src="https://i.loli.net/2021/09/07/L4Ptkux2X6Vf98Y.png" alt="image-20210907152631352"></p>
<h2 id="while语句"><span class="post-title-index">4.2 </span><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p><img src="https://i.loli.net/2021/09/07/kdInYJS1VLNpyzf.png" alt="image-20210907153016424"></p>
<h2 id="for语句"><span class="post-title-index">4.3 </span><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p><img src="https://i.loli.net/2021/09/08/t1e2qzZrWuXyxCN.png" alt="image-20210908001252394"></p>
<h1 id="函数"><span class="post-title-index">5 </span><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="https://i.loli.net/2021/09/07/oBtAGHO9Ffga2h8.png" alt="image-20210907153337724"></p>
<ul>
<li>函数先定义后调用</li>
</ul>
<h2 id="函数说明"><span class="post-title-index">5.1 </span><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><p><img src="https://i.loli.net/2021/09/07/bHwE1tKB6LXrlON.png" alt="image-20210907153850150"></p>
<blockquote>
<p><strong>在调用的地方 Ctrl+Q</strong></p>
</blockquote>
<h2 id="参数和返回值"><span class="post-title-index">5.2 </span><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h2><p><img src="https://i.loli.net/2021/09/07/tinwX6RHGqKyuQV.png" alt="image-20210907154131163"></p>
<h1 id="模块"><span class="post-title-index">6 </span><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p><img src="C:\Users\27512\AppData\Roaming\Typora\typora-user-images\image-20210907154517353.png" alt="image-20210907154517353"></p>
<h2 id="pyc文件"><span class="post-title-index">6.1 </span><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h2><p><img src="https://i.loli.net/2021/09/07/zrxOWCsRdZB87YD.png" alt="image-20210907154630508"></p>
<h1 id="高级变量"><span class="post-title-index">7 </span><a href="#高级变量" class="headerlink" title="高级变量"></a>高级变量</h1><h2 id="列表"><span class="post-title-index">7.1 </span><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="定义列表"><span class="post-title-index">7.1.1 </span><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p><img src="https://i.loli.net/2021/09/07/AfyCuKlmhV3eTji.png" alt="image-20210907234613403"></p>
<h3 id="常用操作"><span class="post-title-index">7.1.2 </span><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><blockquote>
<p><strong>Tips：输入name_list.，敲击tab</strong></p>
</blockquote>
<p><img src="https://i.loli.net/2021/09/07/siHEyqf5D3XB9Yd.png" alt="image-20210907235022456"></p>
<p><a href="https://www.runoob.com/python/python-lists.html">Python 列表(List) | 菜鸟教程 (runoob.com)</a></p>
<h2 id="元组"><span class="post-title-index">7.2 </span><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p><strong><font color="blue">Python的元组与列表的不同之处：</font></strong></p>
<ul>
<li><strong><font color="blue">元组的元素不能修改</font></strong></li>
<li><strong><font color="blue">元组使用小括号，列表使用方括号</font></strong></li>
</ul>
<p><a href="https://www.runoob.com/python/python-tuples.html">Python 元组 | 菜鸟教程 (runoob.com)</a></p>
<h2 id="字典"><span class="post-title-index">7.3 </span><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><img src="https://i.loli.net/2021/09/08/PHrLFwGbj3BuahN.png" alt="image-20210908000014495"></p>
<p><a href="https://www.runoob.com/python/python-dictionary.html">Python 字典(Dictionary) | 菜鸟教程 (runoob.com)</a></p>
<h2 id="字符串"><span class="post-title-index">7.4 </span><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><img src="https://i.loli.net/2021/09/08/2cbgYLNsyKFiZnA.png" alt="image-20210908000134150"></p>
<p><strong><font color="c7254e">Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</font></strong></p>
<h2 id="公共方法"><span class="post-title-index">7.5 </span><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2><h3 id="Python内置函数"><span class="post-title-index">7.5.1 </span><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h3><p><img src="https://i.loli.net/2021/09/08/icySGxOLNA3sbd1.png" alt="image-20210908000943440"></p>
<h3 id="切片"><span class="post-title-index">7.5.2 </span><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p><img src="https://i.loli.net/2021/09/08/Iij6hl8Ns2duJcw.png" alt="image-20210908001024815"></p>
<h3 id="运算符-1"><span class="post-title-index">7.5.3 </span><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://i.loli.net/2021/09/08/UztXP1ZweFbAT2m.png" alt="image-20210908001110504"></p>
<p><img src="https://i.loli.net/2021/09/08/ZOJmafLuKbDE1yH.png" alt="image-20210908001210051"></p>
<h1 id="面向对象"><span class="post-title-index">8 </span><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><a href="https://www.runoob.com/python/python-object.html">Python 面向对象 | 菜鸟教程 (runoob.com)</a></p>
<h2 id="创建类"><span class="post-title-index">8.1 </span><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p><img src="https://i.loli.net/2021/09/08/vUZQubi2ISNydVq.png" alt="image-20210908001545917"></p>
<h2 id="self"><span class="post-title-index">8.2 </span><a href="#self" class="headerlink" title="self"></a>self</h2><p>相当于C++的this</p>
<h2 id="Python内置类属性"><span class="post-title-index">8.3 </span><a href="#Python内置类属性" class="headerlink" title="Python内置类属性"></a>Python内置类属性</h2><p><img src="https://i.loli.net/2021/09/08/dUgjey5wiPGLmR4.png" alt="image-20210908001729430"></p>
<h2 id="构造和析构"><span class="post-title-index">8.4 </span><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><p><img src="https://i.loli.net/2021/09/08/bwDyzOK5ZEGMN2I.png" alt="image-20210908001956529"></p>
<p><img src="https://i.loli.net/2021/09/08/Wj5asoRxAw9FVlC.png" alt="image-20210908002013470"></p>
<h2 id="类的继承"><span class="post-title-index">8.5 </span><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><img src="https://i.loli.net/2021/09/08/1nHYuAsRweijFNV.png" alt="image-20210908002042108"></p>
]]></content>
      <categories>
        <category>专业</category>
        <category>语言学习</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue入门——环境搭建、Webpack、Vue框架了解</title>
    <url>/2021/09/14/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Vue%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>配置Vue开发环境，了解Webpack、Node、Gulp以及Yoeman脚手架等知识。<span id="more"></span></p>
<h1 id="环境搭建及相关知识"><span class="post-title-index">1 </span><a href="#环境搭建及相关知识" class="headerlink" title="环境搭建及相关知识"></a>环境搭建及相关知识</h1><p><img src="https://i.loli.net/2021/09/14/zXxisYphAMkFOZQ.png" alt="image-20210909153940754" style="zoom: 33%;"></p>
<h2 id="Docker——容器化应用"><span class="post-title-index">1.1 </span><a href="#Docker——容器化应用" class="headerlink" title="Docker——容器化应用"></a>Docker——容器化应用</h2><p><img src="https://i.loli.net/2021/09/10/DGIFu1QCZi5NXqc.png" alt="image-20210910103612405" style="zoom: 33%;"></p>
<h2 id="node介绍"><span class="post-title-index">1.2 </span><a href="#node介绍" class="headerlink" title="node介绍"></a>node介绍</h2><p><img src="https://i.loli.net/2021/09/14/INndlBsMX23P9hx.png" alt="image-20210910112330203" style="zoom:33%;"></p>
<h1 id="前端工程化"><span class="post-title-index">2 </span><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><p><img src="https://i.loli.net/2021/09/11/LyDgEI6acVOG9xW.png" alt="image-20210911005012607" style="zoom: 50%;"></p>
<h2 id="前端工程化简介"><span class="post-title-index">2.1 </span><a href="#前端工程化简介" class="headerlink" title="前端工程化简介"></a>前端工程化简介</h2><p><img src="https://i.loli.net/2021/09/11/2scV9twbpxCeKfH.png" alt="image-20210911004535327" style="zoom:33%;"></p>
<h2 id="构建工具——Webpack"><span class="post-title-index">2.2 </span><a href="#构建工具——Webpack" class="headerlink" title="构建工具——Webpack"></a>构建工具——Webpack</h2><p><img src="https://i.loli.net/2021/09/11/Z6TnLlYkNpOxD3I.png" alt="image-20210911211642986"></p>
<h3 id="核心概念"><span class="post-title-index">2.2.1 </span><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong><a href="https://webpack.docschina.org/concepts/">概念 | webpack 中文文档 (docschina.org)</a></strong></p>
<p><strong>入口：</strong>指示 webpack 应该使用哪个模块，来作为构建其内部 <a href="https://webpack.docschina.org/concepts/dependency-graph/">依赖图</a> 的开始</p>
<p><strong>输出：</strong>告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件</p>
<p><strong>Loader：</strong>处理一些webpack不能处理的文件，转化为能够处理的文件</p>
<ul>
<li>使用 <code>yarn add ...</code> 安装loaders</li>
</ul>
<p><strong>插件：</strong>一些扩展功能。范围比Loaders更加广泛，从打包优化到压缩、或者重新定义环境变量等</p>
<ul>
<li><a href="https://webpack.docschina.org/plugins">插件列表 | webpack 中文文档 (docschina.org)</a></li>
</ul>
<p><strong>模式/兼容性：</strong>通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优化。</p>
<ul>
<li>NODE_ENV：<a href="https://www.jianshu.com/p/83e8909fc1cd">NODE_ENV到底是个什么玩意？？ - 简书 (jianshu.com)</a></li>
</ul>
<h3 id="一些好用的东西"><span class="post-title-index">2.2.2 </span><a href="#一些好用的东西" class="headerlink" title="一些好用的东西"></a>一些好用的东西</h3><ul>
<li><strong>热模块替换：</strong><a href="https://webpack.docschina.org/configuration/dev-server/">devServer | webpack 中文文档 (docschina.org)</a></li>
<li><strong>babel：</strong><a href="https://babeljs.io/docs/en/">What is Babel? · Babel (babeljs.io)</a></li>
</ul>
<h2 id="构建工具——Gulp"><span class="post-title-index">2.3 </span><a href="#构建工具——Gulp" class="headerlink" title="构建工具——Gulp"></a>构建工具——Gulp</h2><p><a href="https://gulpjs.com/">gulp.js (gulpjs.com)</a></p>
<h3 id="gulp-flow"><span class="post-title-index">2.3.1 </span><a href="#gulp-flow" class="headerlink" title="gulp flow"></a>gulp flow</h3><p><img src="https://i.loli.net/2021/09/12/cXUItWdroKDBPNn.png" alt="image-20210912094615895"></p>
<h3 id="实践中的错误解决"><span class="post-title-index">2.3.2 </span><a href="#实践中的错误解决" class="headerlink" title="实践中的错误解决"></a>实践中的错误解决</h3><p><img src="https://i.loli.net/2021/09/12/MJjaUWRqZfxYoOK.png" alt="image-20210912111807878"></p>
<p><strong>添加 cb 和 cb()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除dist目录中的内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    del(<span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">    cb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="脚手架——Yeoman"><span class="post-title-index">2.4 </span><a href="#脚手架——Yeoman" class="headerlink" title="脚手架——Yeoman"></a>脚手架——Yeoman</h2><h3 id="错误解决"><span class="post-title-index">2.4.1 </span><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p><a href="https://www.jianshu.com/p/126ba674e395">nrm ls报错:The “path” argument must be of type string. Received undefined - 简书 (jianshu.com)</a></p>
<h1 id="Vue框架"><span class="post-title-index">3 </span><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h1><p><img src="https://i.loli.net/2021/09/13/HfWhneTL2ulYz4t.png" alt="image-20210913164417401"></p>
<h2 id="MVVM架构"><span class="post-title-index">3.1 </span><a href="#MVVM架构" class="headerlink" title="MVVM架构"></a>MVVM架构</h2><ul>
<li>Model-ViewModel-View-Controller，一种软件架构模式</li>
<li>Vue使用了这种架构</li>
</ul>
<p><img src="https://i.loli.net/2021/09/09/SxoITmUjJgl51NK.jpg" alt="img"></p>
<h2 id="组件化思想"><span class="post-title-index">3.2 </span><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h2><p><img src="https://i.loli.net/2021/09/14/FWE12qAelQHBn54.png" alt="image-20210914204042352" style="zoom:50%;"></p>
<p><img src="https://i.loli.net/2021/09/14/cpyOIvU2BRWqPGk.png" alt="image-20210914204248576" style="zoom:50%;"></p>
<p><strong>组件化原则：</strong></p>
<ul>
<li><strong>独立功能模块（松耦合、扁平化、提炼精华）</strong></li>
<li><strong>独立的状态变化（统一的状态管理）</strong></li>
<li><strong>从上而下的逻辑思考，从下而上的组件拆分</strong></li>
</ul>
]]></content>
      <categories>
        <category>专业</category>
        <category>前端开发学习</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>前端开发</tag>
        <tag>Webpack</tag>
        <tag>Gulp</tag>
        <tag>Yoeman</tag>
      </tags>
  </entry>
  <entry>
    <title>修改HEXO博客Next主题的文章显示样式</title>
    <url>/2021/09/17/%E4%BF%AE%E6%94%B9HEXO%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E7%9A%84%E6%96%87%E7%AB%A0%E6%98%BE%E7%A4%BA%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>最近在学习HTML和CSS，看着看着突然想起Typora的code样式很丑，网页显示出来的code、链接也是默认灰色，感觉可以试着改改样式文件练练手了！<span id="more"></span></p>
<h1 id="修改成果展示"><span class="post-title-index">1 </span><a href="#修改成果展示" class="headerlink" title="修改成果展示"></a>修改成果展示</h1><ol>
<li><p><strong>code样式</strong></p>
<p> <img src="https://i.loli.net/2021/09/17/has7YM5AlGQU21V.png" alt="image-20210917155251885"></p>
 <center>↓</center>

<p> <img src="https://i.loli.net/2021/09/17/43wo7QaYVjzTy8B.png" alt="image-20210917155948308"></p>
</li>
<li><p><strong>链接颜色</strong></p>
<p> <img src="https://i.loli.net/2021/09/17/bkwrqh1mHzJ3GIp.png" alt="image-20210917155754569"></p>
 <center>↓</center>

<p> <img src="https://i.loli.net/2021/09/17/526ySHsYreEuvnN.png" alt="image-20210917160013391"></p>
<blockquote>
<p>对比一下，原来灰色的链接，如果不是用红圈框出来，恐怕一时都看不太出这是个链接（除了下面的横线提示），非常不醒目，换了一个颜色后就好多啦。</p>
</blockquote>
</li>
<li><p><strong>有序列表的序号加粗</strong></p>
<p> <img src="https://i.loli.net/2021/09/17/gv5jxd4cFAezSJM.png" alt="image-20210917160405758"></p>
 <center>↓</center>

<p> <img src="https://i.loli.net/2021/09/17/1zAfpLkvK46YrFJ.png" alt="image-20210917160425586"></p>
<blockquote>
<p>这个对比可能不是很明显，但从整体的角度来看是很明显的，旧的那一种就<del>好像健身练胳膊不练腿</del>不太协调的亚子。</p>
</blockquote>
</li>
</ol>
<h1 id="具体操作方法"><span class="post-title-index">2 </span><a href="#具体操作方法" class="headerlink" title="具体操作方法"></a>具体操作方法</h1><h2 id="浏览器查看博客，确定要修改元素的信息"><span class="post-title-index">2.1 </span><a href="#浏览器查看博客，确定要修改元素的信息" class="headerlink" title="浏览器查看博客，确定要修改元素的信息"></a>浏览器查看博客，确定要修改元素的信息</h2><p>在博客界面按 <strong>F12</strong> 打开调试</p>
<p><img src="https://i.loli.net/2021/09/17/qTyKHi1cdNL4XrE.png" alt="image-20210917163008636"></p>
<p>使用调试器内元素选择器选择想要修改样式的部位：</p>
<p><img src="https://i.loli.net/2021/09/17/3DJ1XEcf2u8mGiz.png" alt="image-20210917163159647"></p>
<p>点击后发现调试器的“元素”窗口已经定位到了这个元素对应的HTML代码</p>
<p><img src="https://i.loli.net/2021/09/17/3cRFVz1XoCgakSv.png" alt="image-20210917163303191"></p>
<p>上下左右找找看，发现这个元素处在一个div块中，div块的类是 <code>post-body animated fadeInDown</code> </p>
<p><img src="https://i.loli.net/2021/09/17/cn4CvTPISyfFwLR.png" alt="image-20210917163704354"></p>
<p>下一步来找相应的文件或者模块。</p>
<h2 id="探索next主题文件结构"><span class="post-title-index">2.2 </span><a href="#探索next主题文件结构" class="headerlink" title="探索next主题文件结构"></a>探索next主题文件结构</h2><p><img src="https://i.loli.net/2021/09/17/yJxUT9SBac6vg8l.png" alt="image-20210917161357712"></p>
<p>这个文件夹应该很眼熟，里面的source文件夹存放着我们的博客文章。而<code>themes</code>文件夹顾名思义就是主题相关的一些文件，进入themes文件夹，选择<code>next</code>文件夹，就看到了next主题所有文件：</p>
<p><img src="https://i.loli.net/2021/09/17/65JOo3v8F9bxUui.png" alt="image-20210917161721177"></p>
<p>各个文件夹点开看看，有没有我们要找的CSS文件……一番查找后，在<code>source</code>文件夹下看到了一些熟悉的东西：</p>
<p><img src="https://i.loli.net/2021/09/17/DI9oVpEw2sg5kLy.png" alt="image-20210917161927486"></p>
<p>点进CSS看看……发现一堆子文件夹，还有几个styl文件，这是个什么东西？预想中的CSS呢？</p>
<p><img src="https://i.loli.net/2021/09/18/ZpL8CmU7gRl34kG.png" alt="image-20210917164003072"></p>
<p>管他三七二十一先点开<code>main.style</code>看看，什么情况，一堆import，再仔细一看，哦！这import的内容和子文件夹是对应的啊，那这个基本的调用结构就可以理解了，从<code>main.styl</code>一级一级往下调用，保证了模块化和解耦，也方便找到对应的模块。</p>
<p><img src="https://i.loli.net/2021/09/17/wxdaev2Nc61X4C9.png" alt="image-20210917164303867"></p>
<p>继续如上探索，最终在 <code>css\_common\components\post</code>下找到了一个叫做<code>post-body.styl</code>的文件，与之前看到的类名的前半部分重合，很可能就是你了！今天的主人公！激动的点进去看看！看起来和刚学的CSS语法差不多嘛，下一步就来改改试试。</p>
<h2 id="修改样式文件"><span class="post-title-index">2.3 </span><a href="#修改样式文件" class="headerlink" title="修改样式文件"></a>修改样式文件</h2><h3 id="code样式"><span class="post-title-index">2.3.1 </span><a href="#code样式" class="headerlink" title="code样式"></a>code样式</h3><p>在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">//new</span></span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f7e3e3</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#990000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Git-bash里面<code>hexo s</code>一下，观察网页有无变化</p>
<p><img src="https://i.loli.net/2021/09/17/6uhFwAjkM5iWE7x.png" alt="image-20210917165601055"></p>
<p>变了！！！激动激动，继续改链接样式。</p>
<h3 id="链接样式"><span class="post-title-index">2.3.2 </span><a href="#链接样式" class="headerlink" title="链接样式"></a>链接样式</h3><p>在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;      <span class="comment">/* 未访问链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;   <span class="comment">/* visited link */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;     <span class="comment">/* mouse over link */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;    <span class="comment">/* selected link */</span></span><br></pre></td></tr></table></figure>
<p>刷新网页，观察变化</p>
<p><img src="https://i.loli.net/2021/09/17/UAMIu2vDrfNZ7St.png" alt="image-20210917165850183"></p>
<p>也变化了！！CSS好简单！一学就会一用就对。</p>
<p>……但是但是但是，返回首页看一眼，我们就会发现问题，原先黑色的“read more”竟然也变成了绿色？！！！离谱啊，这不是个button吗！怎么和链接用一样的类啊！太诡异了这绿色，必须改回来！</p>
<p><img src="https://i.loli.net/2021/09/17/5UTMLESIrdgnNkG.png" alt="image-20210917170209366"></p>
<p>这个地方研究了不少时间，一开始觉得自己添加的链接样式的代码应该限定一个范围，像是下面这样：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-class">.post-body</span> <span class="selector-class">.animated</span> <span class="selector-class">.fadeInDown</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125; </span><br></pre></td></tr></table></figure>
<p>但这个行不通，样式并没有修改，直接变回了以前的默认灰色，隐约感觉是我写的格式不太合适，或者没找到合适的类名，经过各种浏览器调试、研究其他styl代码后，又尝试了下面这样：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> <span class="selector-class">.fadeInDown</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;      <span class="comment">/* 未访问链接*/</span></span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;  <span class="comment">/* visited link */</span></span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;  <span class="comment">/* mouse over link */</span></span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;  <span class="comment">/* selected link */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而还是不太行，于是转变思路打算在此基础上修改button的颜色，改为默认值。在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.btn</span> &#123;</span><br><span class="line"> <span class="attribute">color</span>: var(--btn-default-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新一看，诶！好了！嗯嗯嗯嗯真不错我可真<del>是个天才</del>棒！还是这个看着舒服</p>
<p><img src="https://i.loli.net/2021/09/17/vVOba3cT9QjrtIA.png" alt="image-20210917171746877"></p>
<p><strong>【tips】之前也在网上查过修改的方法，好像是直接改了个变量，这个行不通啊真的行不通，结果就是各种能点的地方，颜色全变了……就很离谱。</strong></p>
<h3 id="修改有序列表序号粗细"><span class="post-title-index">2.3.3 </span><a href="#修改有序列表序号粗细" class="headerlink" title="修改有序列表序号粗细"></a>修改有序列表序号粗细</h3><p>利用浏览器调试工具找到这个元素的名字，<code>::marker</code> 没听过的东西，搜索发现修改方法和其他元素一样</p>
<p><img src="https://i.loli.net/2021/09/17/AVdLNPuZTOxGis1.png" alt="image-20210917172100373"></p>
<p>那就果断下手，在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line"> <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刷新看看！</p>
<p><img src="https://i.loli.net/2021/09/17/uEyXohwzPHUMcns.png" alt="image-20210917172412696"></p>
<p>嗯！序号部分和文字部分已经粗细一致啦！（Typora 编辑器的显示也可以一样修改）</p>
<h1 id="相关知识参考"><span class="post-title-index">3 </span><a href="#相关知识参考" class="headerlink" title="相关知识参考"></a>相关知识参考</h1><p><a href="https://www.w3cschool.cn/css/css-grouping-nesting.html">CSS 分组和嵌套 w3cschool</a></p>
<p><a href="https://www.w3cschool.cn/css/css-combinators.html">CSS 组合选择符 w3cschool</a></p>
<p><a href="https://www.w3cschool.cn/css/css-pseudo-classes.html">CSS 伪类_w3cschool</a></p>
<p><a href="https://www.w3cschool.cn/css/css-attribute-selectors.html">CSS 属性选择器_w3cschool</a></p>
]]></content>
      <categories>
        <category>专业</category>
        <category>前端开发学习</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端开发</tag>
        <tag>CSS</tag>
        <tag>HEXO</tag>
        <tag>HEXO-Next主题</tag>
      </tags>
  </entry>
  <entry>
    <title>调试技巧总结</title>
    <url>/2021/10/29/%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="监视数组"><span class="post-title-index">1 </span><a href="#监视数组" class="headerlink" title="监视数组"></a>监视数组</h1><p><code>*( type (*)[ length ]) 数组名</code></p>
<span id="more"></span>
]]></content>
      <categories>
        <category>专业</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>VScode</tag>
      </tags>
  </entry>
  <entry>
    <title>实验 1 —— C 语言词法分析程序的设计与实现</title>
    <url>/2021/10/15/C%E8%AF%AD%E8%A8%80%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实验-1-——-C-语言词法分析程序的设计与实现"><span class="post-title-index">1 </span><a href="#实验-1-——-C-语言词法分析程序的设计与实现" class="headerlink" title="实验 1 —— C 语言词法分析程序的设计与实现"></a>实验 1 —— C 语言词法分析程序的设计与实现</h1><h2 id="实验内容及要求"><span class="post-title-index">1.1 </span><a href="#实验内容及要求" class="headerlink" title="实验内容及要求"></a>实验内容及要求</h2><h3 id="实验内容要求"><span class="post-title-index">1.1.1 </span><a href="#实验内容要求" class="headerlink" title="实验内容要求"></a>实验内容要求</h3><ul>
<li>可以识别出用C语言编写的源程序中的每个单词符号，并以记号的形式输出每个单词符号。 </li>
<li>可以识别并跳过源程序中的注释。</li>
<li>可以统计源程序中的语句行数、各类单词的个数、以及字符总数，并输出统计结果。 </li>
<li>检查源程序中存在的词法错误，并报告错误所在的位置。 </li>
<li>对源程序中出现的错误进行适当的恢复，使词法分析可以继续进行，对源程序进行一次扫描，即可检查并报告源程序中存在的所有词法错误。</li>
</ul>
<span id="more"></span>
<h3 id="实验方法要求"><span class="post-title-index">1.1.2 </span><a href="#实验方法要求" class="headerlink" title="实验方法要求"></a>实验方法要求</h3><ul>
<li><p>方法1：采用C/C++作为实现语言，手工编写词法分析程序。（必做） </p>
</li>
<li><p>方法2：编写LEX源程序，利用LEX编译程序自动生成词法分析程序。 </p>
</li>
</ul>
<h2 id="程序设计说明"><span class="post-title-index">1.2 </span><a href="#程序设计说明" class="headerlink" title="程序设计说明"></a>程序设计说明</h2><h3 id="本C语言词法分析器的词法说明"><span class="post-title-index">1.2.1 </span><a href="#本C语言词法分析器的词法说明" class="headerlink" title="本C语言词法分析器的词法说明"></a>本C语言词法分析器的词法说明</h3><ul>
<li><strong>标识符</strong>：<ul>
<li>必须以<code>字母</code>a~z、 A~Z或<code>下划线</code>开头，后面可跟任意个(可为0)字符，这些字符可以是<code>字母、下划线和数字</code>，其他字符不允许出现在标识符中。</li>
<li>c99规定标识符长度在<code>63</code>个字符以内，但根据不同的编译器、操作系统，限制也不同，在此不限制标识符长度。</li>
</ul>
</li>
<li><strong>保留字</strong>：<ul>
<li>32个保留字</li>
<li>类型说明保留字（14）：<code>int  long  short  float  double  char  unsigned  signed  const  void  volatile  enum  struct  union</code></li>
<li>语句定义保留字（13）：<code>if  else  goto  switch  case  do  while  for  continue  break  return  default  typedef</code></li>
<li>存储类说明保留字（4）：<code>auto  register  extern  static</code></li>
<li>长度运算符保留字（1）：<code>sizeof</code></li>
</ul>
</li>
<li><strong>常量</strong>：<ul>
<li>整数常量<ul>
<li>前缀：<code>0x 或 0X</code> 表示十六进制，<code>0</code> 表示八进制，不带前缀则默认表示十进制</li>
<li>后缀：<code>u 或 U</code> 表示无符号整数（unsigned），<code>l 或 L</code> 表示长整数（long）。二者的顺序任意。</li>
</ul>
</li>
<li>浮点常量<ul>
<li>可以有小数形式和指数形式。指数使用 <code>e 或 E</code> 引入</li>
<li>后缀：<code>f 或 F</code>表示 float，<code>l 或 L</code> 表示 long double</li>
<li>前缀：浮点常量没有前缀，使用 0x 或 0 做前缀表示基数是不合法的。</li>
</ul>
</li>
</ul>
</li>
<li><strong>符号</strong>：<ul>
<li>运算符：<ul>
<li>算术运算符：<code>+  -  *  /  %  ++  --</code></li>
<li>关系运算符：<code>==  !=  &gt;  &lt;  &gt;=  &lt;=</code></li>
<li>逻辑运算符：<code>&amp;&amp;  ||  !</code></li>
<li>位运算符：<code>&amp;  |  ^  ~  &lt;&lt;  &gt;&gt;</code></li>
<li>赋值运算符：<code>=  +=  -=  *=  /=  %=  &lt;&lt;=  &gt;&gt;=  &amp;=  ^=  |=</code></li>
<li>其他运算符：<code>sizeof  ,  ()  []  &amp;  *  ?:  -&gt;  .</code></li>
</ul>
</li>
<li>其他符号：<ul>
<li>分隔符：<code>;  :  &#123;&#125;</code></li>
<li>预处理符号：<code>#</code></li>
<li>换行连接符：<code>\</code></li>
<li>字符和字符串：<code>&#39;&#39;  &quot;&quot;</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>注释标记</strong>：<ul>
<li>单行注释：<code>// 单行注释</code></li>
<li>块注释：<code>/* ... */</code></li>
</ul>
</li>
<li><strong>空白</strong>：<code>空格符、换行符、制表符</code></li>
</ul>
<h3 id="设计词法分析程序的状态转换图"><span class="post-title-index">1.2.2 </span><a href="#设计词法分析程序的状态转换图" class="headerlink" title="设计词法分析程序的状态转换图"></a>设计词法分析程序的状态转换图</h3><h4 id="标识符——根据标识符定义可以得到状态转换图如下："><span class="post-title-index">1.2.2.1 </span><a href="#标识符——根据标识符定义可以得到状态转换图如下：" class="headerlink" title="标识符——根据标识符定义可以得到状态转换图如下："></a>标识符——根据标识符定义可以得到状态转换图如下：</h4><p><img src="https://i.loli.net/2021/10/08/GUNx583k4d6IDRL.jpg" alt="img" style="zoom: 50%;"></p>
<h4 id="符号——按照起始符号将所有符号进行归类整理如下："><span class="post-title-index">1.2.2.2 </span><a href="#符号——按照起始符号将所有符号进行归类整理如下：" class="headerlink" title="符号——按照起始符号将所有符号进行归类整理如下："></a>符号——按照起始符号将所有符号进行归类整理如下：</h4><p><img src="https://i.loli.net/2021/11/23/e14m5SUnsMGtcZl.png" alt="image-20211009121942918"></p>
<p>注意 <code>.</code>这一符号，既有可能是用于结构体，也可能出现在常量的小数中，需要特殊处理（详见第3条常量的状态转换图）</p>
<h4 id="常量——设计状态转换图，见（4）"><span class="post-title-index">1.2.2.3 </span><a href="#常量——设计状态转换图，见（4）" class="headerlink" title="常量——设计状态转换图，见（4）"></a>常量——设计状态转换图，见（4）</h4><h4 id="综合上述元素，得到完整状态转换图如下："><span class="post-title-index">1.2.2.4 </span><a href="#综合上述元素，得到完整状态转换图如下：" class="headerlink" title="综合上述元素，得到完整状态转换图如下："></a>综合上述元素，得到完整状态转换图如下：</h4><p>其中，hdigit 表示 16进制的数字（0-f），0digit 表示 8进制的数字（0-7）。绿色笔标注为后期调试中添加的漏掉的分支。</p>
<p><img src="https://i.loli.net/2021/10/13/BFwQfZ1XaPKtnTH.png" alt="image-20211013210729911" style="zoom: 50%;"></p>
<h3 id="翻译表"><span class="post-title-index">1.2.3 </span><a href="#翻译表" class="headerlink" title="翻译表"></a>翻译表</h3><p><img src="https://i.loli.net/2021/10/09/lzcujC3ErZI7FRk.png" alt="image-20211009123017047" style="zoom: 80%;"></p>
<h3 id="输出形式"><span class="post-title-index">1.2.4 </span><a href="#输出形式" class="headerlink" title="输出形式"></a>输出形式</h3><h4 id="记号输出"><span class="post-title-index">1.2.4.1 </span><a href="#记号输出" class="headerlink" title="记号输出"></a>记号输出</h4><p>利用翻译表，将识别出的单词的记号以二元式的形式输出：&lt;记号，属性&gt;，如下例：</p>
<p><img src="https://i.loli.net/2021/10/12/evSNyArPpqJ81tD.png" alt="image-20211012232907558"></p>
<h4 id="统计结果输出"><span class="post-title-index">1.2.4.2 </span><a href="#统计结果输出" class="headerlink" title="统计结果输出"></a>统计结果输出</h4><p>在词法分析完成后，将词法分析的结果加以统计输出，包括程序行数、程序字符总数、用到的关键字及对应出现次数、用户自定义标识符总数和列表、常量总数和列表，如下例：</p>
<p><img src="https://i.loli.net/2021/10/12/hPXFIZAxDyEGKcl.png" alt="image-20211012233536744" style="zoom:82%;"></p>
<h4 id="词法错误输出"><span class="post-title-index">1.2.4.3 </span><a href="#词法错误输出" class="headerlink" title="词法错误输出"></a>词法错误输出</h4><p>在输出二元组的过程中，如果检测到词法错误，将会以如下形式输出：</p>
<p><img src="https://i.loli.net/2021/11/23/kjdCiV2r7A8YH4s.png" alt="image-20211012233833643"></p>
<p><img src="https://i.loli.net/2021/10/12/BxDAC2NL1gGRMnh.png" alt="image-20211012233856356" style="zoom:96%;"></p>
<h2 id="源程序"><span class="post-title-index">1.3 </span><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><p><a href="https://github.com/thatmee/Compiler_Labs/tree/master/Lab1_lexical_analysis">Compiler_Labs/Lab1_lexical_analysis at master · thatmee/Compiler_Labs (github.com)</a></p>
<h2 id="程序测试及成果说明"><span class="post-title-index">1.4 </span><a href="#程序测试及成果说明" class="headerlink" title="程序测试及成果说明"></a>程序测试及成果说明</h2><h3 id="测试程序1，简单测试："><span class="post-title-index">1.4.1 </span><a href="#测试程序1，简单测试：" class="headerlink" title="测试程序1，简单测试："></a>测试程序1，简单测试：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下图：</p>
<p>可见，本词法分析器能够正确识别标识符、简单的符号和常量。</p>
<p><img src="https://i.loli.net/2021/10/13/xbcdW4sauKiO6UY.png" alt="image-20211013204420348" style="zoom:80%;"></p>
<h3 id="测试程序2，各种特殊常量、字符的测试："><span class="post-title-index">1.4.2 </span><a href="#测试程序2，各种特殊常量、字符的测试：" class="headerlink" title="测试程序2，各种特殊常量、字符的测试："></a>测试程序2，各种特殊常量、字符的测试：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a = \</span><br><span class="line">    <span class="number">2.3</span>;</span><br><span class="line">    <span class="number">02</span>;</span><br><span class="line">    <span class="number">0x5</span><span class="number">.9e10</span>;</span><br><span class="line">    <span class="number">0</span>x<span class="number">.36</span>;</span><br><span class="line">    <span class="number">666u</span>u;</span><br><span class="line">    <span class="number">666ul</span>;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">666</span>;f;</span><br><span class="line">    <span class="number">2.3</span>;</span><br><span class="line">    u;</span><br><span class="line"></span><br><span class="line">    <span class="number">07.9e2</span>;</span><br><span class="line">    <span class="number">07.9</span>;</span><br><span class="line">    <span class="number">8.9e10</span>;</span><br><span class="line">    <span class="number">8.9f</span>;</span><br><span class="line">    <span class="number">8.9</span>;</span><br><span class="line">    <span class="number">20f</span>;</span><br><span class="line">    <span class="number">300f</span>;</span><br><span class="line">    <span class="number">08</span>;</span><br><span class="line">    <span class="number">0x5</span><span class="number">.6</span>;</span><br><span class="line">    <span class="string">&quot;\\&quot;</span> \</span><br><span class="line">    <span class="string">&quot;888&quot;</span>;</span><br><span class="line">    <span class="number">.3</span>;</span><br><span class="line">    <span class="number">.3</span>;</span><br><span class="line">    <span class="number">.3e10</span>;</span><br><span class="line">    <span class="number">04</span>;</span><br><span class="line">    <span class="number">4llu</span>;</span><br><span class="line">    <span class="number">3e10</span>;</span><br><span class="line">    <span class="number">30e5</span>;</span><br><span class="line">    <span class="number">3.0l</span>f;</span><br><span class="line">    </span><br><span class="line">    <span class="number">3.0e10</span>f;</span><br><span class="line">    <span class="number">300</span>;</span><br><span class="line">    <span class="number">0x23</span>;</span><br><span class="line">    &#x27;hello&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下图（仅截取重要片段）：</p>
<p>可见，词法分析器识别出错误：<code>0x.</code>。对应的源代码为：<code>0x.36;</code>根据前文的词法说明，0x后是不可能出现小数点的，因此报错。同时，根据图2中index为4的常量<code>36</code>可知，词法分析器将0x.之后的<code>36</code>识别成了一个常量，可见错误恢复功能正常。</p>
<p><img src="https://i.loli.net/2021/10/13/yU9HXs2F5T7pzwR.png" alt="image-20211013204804482" style="zoom:80%;"></p>
<p><img src="https://i.loli.net/2021/10/13/QwHfAkuypNoP1KI.png" alt="image-20211013204845896" style="zoom:95%;"></p>
<p>另外，行数和字符数统计功能也正常：</p>
<p><img src="https://i.loli.net/2021/10/13/hbtm9swdoMrQf8Z.png" alt="image-20211013205344973" style="zoom:80%;"></p>
<h3 id="测试程序3，块注释、词法错误报告测试："><span class="post-title-index">1.4.3 </span><a href="#测试程序3，块注释、词法错误报告测试：" class="headerlink" title="测试程序3，块注释、词法错误报告测试："></a>测试程序3，块注释、词法错误报告测试：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> ab@c = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO 修改bug</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> SYMBOL_SIZE = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> forwardIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLetter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//进行词法分析</span></span><br><span class="line">    lexicalAna();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;result:&quot;</span>);</span><br><span class="line">    outputData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下图（仅截取重要片段）：</p>
<p>可见词法分析器检测出了标识符的错误：出现了不合法的字符<code>@</code>，同时正常识别到了块注释。</p>
<p><img src="https://i.loli.net/2021/10/13/uXhfTmKgevW2p4U.png" alt="image-20211013205514980" style="zoom:90%;"></p>
<h3 id="测试程序4，双缓冲区、运算符、常量测试："><span class="post-title-index">1.4.4 </span><a href="#测试程序4，双缓冲区、运算符、常量测试：" class="headerlink" title="测试程序4，双缓冲区、运算符、常量测试："></a>测试程序4，双缓冲区、运算符、常量测试：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,k,s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> chi;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;chi);</span><br><span class="line">    <span class="keyword">while</span>(chi!=<span class="string">&#x27;E&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(chi==<span class="string">&#x27;W&#x27;</span>||chi==<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ch[i]=chi;i=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;chi);</span><br><span class="line">     &#125; </span><br><span class="line">    ch[i]=chi;k=i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=k;++i)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">switch</span>(ch[i])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:s=s+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>((<span class="built_in">abs</span>(s-j))&gt;=<span class="number">2</span>&amp;&amp;s&gt;=<span class="number">11</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,s,j);</span><br><span class="line">    s=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:j=j+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(s-j)&gt;=<span class="number">2</span>&amp;&amp;j&gt;=<span class="number">11</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,s,j);</span><br><span class="line">    s=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,s,j);<span class="keyword">break</span>;</span><br><span class="line">    &#125;&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);s=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=k;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(ch[i])</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:s=s+<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">abs</span>(s-j)&gt;=<span class="number">2</span>&amp;&amp;s&gt;=<span class="number">21</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,s,j);s=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:j=j+<span class="number">1</span>;<span class="keyword">if</span>(<span class="built_in">abs</span>(s-j)&gt;=<span class="number">2</span>&amp;&amp;j&gt;=<span class="number">21</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,s,j);s=<span class="number">0</span>;j=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:<span class="built_in">printf</span>(<span class="string">&quot;%d:%d\n&quot;</span>,s,j);<span class="keyword">break</span>;</span><br><span class="line">        &#125;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下图（仅截取重要片段）：</p>
<p>可见关键字统计正常，大量运算符和常量识别正常：</p>
<p><img src="https://i.loli.net/2021/10/13/NCHW4wzIfr6OUgs.png" alt="image-20211013205812794" style="zoom:90%;"></p>
<p><img src="https://i.loli.net/2021/11/23/CnjxZMJXoOKkeV5.png" alt="image-20211013210003804" style="zoom:88%;"></p>
<p>另外，为了测试双缓冲区的正确性，在运行这一程序时我将缓冲区大小 <code>BUFFER_SIZE</code> 改为500，使其能够进行多次缓冲区的替换。可见缓冲区功能也正常。</p>
<h2 id="值得注意的问题总结"><span class="post-title-index">1.5 </span><a href="#值得注意的问题总结" class="headerlink" title="值得注意的问题总结"></a>值得注意的问题总结</h2><ol>
<li><strong>C语言中各种特殊符号及常量，不清楚它们属于词法分析还是语法分析的范畴</strong></li>
</ol>
<p>使用IDE进行测试，输入不同形式的常量及符号，查看IDE是否报错，明确词法分析需要进行检测的内容。</p>
<ol>
<li><strong>预处理指令</strong></li>
</ol>
<p>所谓预处理是指在进行编译的第一遍扫描（词法分析和语法分析）之前所做的工作，预处理是C语言的一个重要功能，它由预处理程序负责完成。当对一个源文件进行编译时，系统将自动引用预处理程序对源程序中的预处理部分作处理，处理完毕自动进行对源程序的编译。</p>
<ol>
<li><strong>常量的类型繁多，有前缀有后缀，还有.开头的小数，不知道如何检测</strong></li>
</ol>
<p>一步步进行分析，绘制出了状态转换图。同时在编程过程中，不断调试修改，解决了这一问题。</p>
<ol>
<li><strong>同一符号多次判断以及漏字符的问题，getChar()函数以及retract()函数需要使用的地方</strong></li>
</ol>
<p>起初选择了在需要回退的地方使用<code>retract()</code>函数，但在调试中发现一些漏洞，应该是那时候状态转换图还不太完善，对各种状态的转移（尤其对出口的处理）不清楚，我删除了所有<code>retract()</code>函数，只使用<code>getChar()</code>对向前指针进行控制，解决了bug。同时，在后续调试程序和完善状态转换图的过程中，我逐渐理清了<code>getChar()</code>函数以及<code>retract()</code>函数需要使用的地方，如果按照一开始的选择使用<code>retract()</code>函数，应该在每次出口的时候统一执行<code>getChar()</code>。</p>
]]></content>
      <categories>
        <category>专业</category>
        <category>专业课程</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>实验 2 —— 语法程序的设计与实现</title>
    <url>/2021/11/21/%E8%AF%AD%E6%B3%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="实验-2-——-语法程序的设计与实现"><span class="post-title-index">1 </span><a href="#实验-2-——-语法程序的设计与实现" class="headerlink" title="实验 2 —— 语法程序的设计与实现"></a>实验 2 —— 语法程序的设计与实现</h1><h2 id="实验内容及要求"><span class="post-title-index">1.1 </span><a href="#实验内容及要求" class="headerlink" title="实验内容及要求"></a>实验内容及要求</h2><h3 id="实验内容"><span class="post-title-index">1.1.1 </span><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>编写语法分析程序，实现对算术表达式的语法分析。要求所分析算数表达式由如下的文法产生：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">E-&gt;E+T|<span class="type">E</span>-T|<span class="type">T</span></span><br><span class="line">T-&gt;T*F|<span class="type">T</span>/F|<span class="type">F</span></span><br><span class="line">F-&gt;(E)|<span class="type">num</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="实验要求"><span class="post-title-index">1.1.2 </span><a href="#实验要求" class="headerlink" title="实验要求"></a>实验要求</h3><p>在对输入的算术表达式进行分析的过程中，依次输出所采用的产生式。</p>
<h3 id="实验方法要求"><span class="post-title-index">1.1.3 </span><a href="#实验方法要求" class="headerlink" title="实验方法要求"></a>实验方法要求</h3><ul>
<li><p>方法 1：编写递归调用程序实现自顶向下的分析。  </p>
</li>
<li><p>方法 2：编写 LL(1) 语法分析程序，要求如下。 （必做） </p>
<ul>
<li>编程实现算法 4.2，为给定文法自动构造预测分析表。 </li>
<li>编程实现算法 4.1，构造 LL(1) 预测分析程序。  </li>
</ul>
</li>
<li><p>方法 3：编写语法分析程序实现自底向上的分析，要求如下。（必做） </p>
<ul>
<li>构造识别该文法所有活前缀的 DFA。</li>
<li>构造该文法的 LR 分析表。</li>
<li>编程实现算法 4.3，构造 LR 分析程序。  </li>
</ul>
</li>
<li><p>方法 4：利用 YACC 自动生成语法分析程序，调用 LEX 自动生成的词法分析程序。</p>
</li>
</ul>
<h2 id="程序设计说明"><span class="post-title-index">1.2 </span><a href="#程序设计说明" class="headerlink" title="程序设计说明"></a>程序设计说明</h2><h3 id="总体设计说明"><span class="post-title-index">1.2.1 </span><a href="#总体设计说明" class="headerlink" title="总体设计说明"></a>总体设计说明</h3><p>本次实验我编程实现了前三种语法分析方法：递归调用分析程序、LL(1) 语法分析程序、LR(1) 语法分析程序。我使用了 C++ 的面向对象特性，将三种方法以及各种数据的存储封装在了 <code>Grammar</code> 类（见 <code>Grammar.h</code>）中。</p>
<h4 id="数据结构"><span class="post-title-index">1.2.1.1 </span><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul>
<li><p><strong>类型定义</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Symbol = std::string;                                                            <span class="comment">// 符号类型</span></span><br><span class="line"><span class="keyword">using</span> SymbolSet = std::set&lt;Symbol&gt;;                                                    <span class="comment">// 符号集合类型</span></span><br><span class="line"><span class="keyword">using</span> VecSymbol = std::vector&lt;Symbol&gt;;                                                 <span class="comment">// 符号的 vector 类型</span></span><br><span class="line"><span class="keyword">using</span> RHS = std::vector&lt;Symbol&gt;;                                                       <span class="comment">// 右部产生式 (right hand side) 类型</span></span><br><span class="line"><span class="keyword">using</span> VectorRHS = std::vector&lt;RHS&gt;;                                                    <span class="comment">// 右部产生式的集合</span></span><br><span class="line"><span class="keyword">using</span> UpdateMap = std::unordered_map&lt;Symbol, SymbolSet&gt;;                               <span class="comment">// 存储更新式的类型</span></span><br><span class="line"><span class="keyword">using</span> SymbolToRHS = std::unordered_map&lt;Symbol, RHS&gt;;                                   <span class="comment">// 符号到右部产生式的映射类型</span></span><br><span class="line"><span class="keyword">using</span> SymbolTable = std::unordered_map&lt;Symbol, std::unordered_map&lt;Symbol, RHS&gt;&gt;;       <span class="comment">// 行列表头为 Symbol 的二维表（预测分析表类型）</span></span><br><span class="line"><span class="keyword">using</span> Productions = std::unordered_map&lt;Symbol, VectorRHS&gt;;                             <span class="comment">// 产生式集合类型</span></span><br><span class="line"><span class="keyword">using</span> ProdSplit = std::pair&lt;Symbol, RHS&gt;;                                              <span class="comment">// 单个产生式类型</span></span><br><span class="line"><span class="keyword">using</span> ProdCnt = std::unordered_map&lt;<span class="keyword">int</span>, ProdSplit&gt;;                                    <span class="comment">// 带编号的产生式集合类型</span></span><br><span class="line"><span class="keyword">using</span> Project = std::pair&lt;ProdSplit, SymbolSet&gt;;                                       <span class="comment">// 项目类型</span></span><br><span class="line"><span class="keyword">using</span> ProjectMap = std::map&lt;ProdSplit, SymbolSet&gt;;                                     <span class="comment">// 项目集合类型</span></span><br><span class="line"><span class="keyword">using</span> ProjectCluster = std::unordered_map&lt;<span class="keyword">int</span>, ProjectMap&gt;;                            <span class="comment">// 项目族类型</span></span><br><span class="line"><span class="keyword">using</span> ActGotoTable = std::unordered_map&lt;<span class="keyword">int</span>, std::unordered_map&lt;Symbol, std::string&gt;&gt;; <span class="comment">// LR1 分析表类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Grammar 类的私有属性</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grammar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    SymbolSet N;                                  <span class="comment">// 非终结符集合</span></span><br><span class="line">    SymbolSet T;                                  <span class="comment">// 终结符集合</span></span><br><span class="line">    Productions P;                                <span class="comment">// 所有产生式</span></span><br><span class="line">    Symbol S;                                     <span class="comment">// 文法起始符号 S</span></span><br><span class="line">    VecSymbol s;                                  <span class="comment">// 待分析的串</span></span><br><span class="line">    <span class="keyword">int</span> pointer = <span class="number">-1</span>;                             <span class="comment">// 当前指向的位置</span></span><br><span class="line">    Symbol ch = <span class="string">&quot;&quot;</span>;                               <span class="comment">// 当前指向的字符</span></span><br><span class="line">    std::unordered_map&lt;Symbol, SymbolSet&gt; first;  <span class="comment">// first 集合</span></span><br><span class="line">    std::unordered_map&lt;Symbol, SymbolSet&gt; follow; <span class="comment">// follow 集合</span></span><br><span class="line">    SymbolTable LL1AnaTable;                      <span class="comment">// LL1 分析表</span></span><br><span class="line">    ProdCnt extensionP;                           <span class="comment">// 带编号的拓广文法</span></span><br><span class="line">    ActGotoTable LR1AnaTable;                     <span class="comment">// LR1 分析表</span></span><br><span class="line">    ProjectCluster C;                             <span class="comment">// 规范项目族</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Grammar 类的常量</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Grammar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ERR_MISSING_R_BRACKET = <span class="number">1</span>; <span class="comment">// 错误状态代码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ERR_MISSING_OBJECT = <span class="number">2</span>;    <span class="comment">// 错误状态代码</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> ERR_MISSING_OPERATOR = <span class="number">3</span>;  <span class="comment">// 错误状态代码</span></span><br><span class="line">    <span class="keyword">const</span> RHS ERR = &#123; <span class="string">&quot;ERR&quot;</span> &#125;;                  <span class="comment">// 错误状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SPLIT_LINE_WIDTH = <span class="number">60</span>;     <span class="comment">// 用于格式化输出</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="通用函数说明（Grammar-cpp）"><span class="post-title-index">1.2.1.2 </span><a href="#通用函数说明（Grammar-cpp）" class="headerlink" title="通用函数说明（Grammar.cpp）"></a>通用函数说明（Grammar.cpp）</h4><ul>
<li><p><strong>Grammar() 默认构造函数</strong></p>
<p>  默认构造函数将为 Grammar 类内 N、T、P、S 赋初值，默认的文法使用实验要求的示例文法</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Grammar::<span class="built_in">Grammar</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;N = &#123; <span class="string">&quot;E&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;F&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;T = &#123; <span class="string">&quot;+&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;(&quot;</span>, <span class="string">&quot;)&quot;</span>, <span class="string">&quot;num&quot;</span> &#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;S = <span class="string">&quot;E&quot;</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;P[<span class="string">&quot;E&quot;</span>] = &#123; &#123;<span class="string">&quot;E&quot;</span>, <span class="string">&quot;+&quot;</span>, <span class="string">&quot;T&quot;</span>&#125;, &#123;<span class="string">&quot;E&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;T&quot;</span>&#125;, &#123;<span class="string">&quot;T&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;P[<span class="string">&quot;T&quot;</span>] = &#123; &#123;<span class="string">&quot;T&quot;</span>, <span class="string">&quot;*&quot;</span>, <span class="string">&quot;F&quot;</span>&#125;, &#123;<span class="string">&quot;T&quot;</span>, <span class="string">&quot;/&quot;</span>, <span class="string">&quot;F&quot;</span>&#125;, &#123;<span class="string">&quot;F&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">this</span>-&gt;P[<span class="string">&quot;F&quot;</span>] = &#123; &#123;<span class="string">&quot;(&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;)&quot;</span>&#125;, &#123;<span class="string">&quot;num&quot;</span>&#125; &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>error() 错误处理函数</strong></p>
<p>  错误处理函数的参数是错误状态码（Grammar 类内有相关静态变量），传入 0 代表未知错误。LL(1) 和 LR(1) 分析程序遇到错误时没有分析错误类型，全部调用了 <code>error(0)</code>。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grammar::error</span><span class="params">(<span class="keyword">int</span> errState)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (errState)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> Grammar::ERR_MISSING_R_BRACKET:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;错误：括号不匹配&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Grammar::ERR_MISSING_OBJECT:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;错误：缺少运算对象&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Grammar::ERR_MISSING_OPERATOR:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;错误：缺少运算符号&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未知错误&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>输入输出函数</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grammar::output</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 输出文法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grammar::inputS</span><span class="params">()</span></span>;       <span class="comment">// 读入待分析的串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grammar::input</span><span class="params">()</span></span>;        <span class="comment">// 读取用户输入的文法</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>forwardPointer() 指针前移操作</strong></p>
<p>  指针前移，并更新 <code>ch</code> 中的值</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Grammar::forwardPointer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pointer++;</span><br><span class="line">    <span class="keyword">if</span> (pointer &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        ch = s[pointer];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ch = <span class="string">&quot;\0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="main-函数说明"><span class="post-title-index">1.2.1.3 </span><a href="#main-函数说明" class="headerlink" title="main 函数说明"></a>main 函数说明</h4><ul>
<li>构造文法对象</li>
<li>提供分析方案的选择</li>
<li>提供各个分析方案的调用</li>
</ul>
<h3 id="方法-1：递归调用分析程序-（1-recursive-analysis-cpp）"><span class="post-title-index">1.2.2 </span><a href="#方法-1：递归调用分析程序-（1-recursive-analysis-cpp）" class="headerlink" title="方法 1：递归调用分析程序 （1_recursive_analysis.cpp）"></a>方法 1：递归调用分析程序 （1_recursive_analysis.cpp）</h3><h4 id="函数调用关系图"><span class="post-title-index">1.2.2.1 </span><a href="#函数调用关系图" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h4><p><img src="https://i.loli.net/2021/11/23/dVulJhirILynYs7.png" alt="image-20211121113034840" style="zoom:67%;"></p>
<h4 id="设计状态转移图"><span class="post-title-index">1.2.2.2 </span><a href="#设计状态转移图" class="headerlink" title="设计状态转移图"></a>设计状态转移图</h4><p><img src="https://i.loli.net/2021/11/23/yROl3aNIT5MU98p.jpg" alt="img" style="zoom:40%;"></p>
<h3 id="方法-2：LL-1-语法分析程序-（2-LL-1-analysis-cpp）"><span class="post-title-index">1.2.3 </span><a href="#方法-2：LL-1-语法分析程序-（2-LL-1-analysis-cpp）" class="headerlink" title="方法 2：LL(1) 语法分析程序 （2_LL(1)_analysis.cpp）"></a>方法 2：LL(1) 语法分析程序 （2_LL(1)_analysis.cpp）</h3><h4 id="函数调用关系图-1"><span class="post-title-index">1.2.3.1 </span><a href="#函数调用关系图-1" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h4><p><img src="https://i.loli.net/2021/11/23/haLSFIrbNxq4TYR.png" alt="image-20211121113103528" style="zoom: 45%;"></p>
<h4 id="函数功能及实现思路"><span class="post-title-index">1.2.3.2 </span><a href="#函数功能及实现思路" class="headerlink" title="函数功能及实现思路"></a>函数功能及实现思路</h4><p>​      请见源程序以及程序注释</p>
<h3 id="方法-3：LR-1-语法分析程序-（3-LR-1-analysis-cpp）"><span class="post-title-index">1.2.4 </span><a href="#方法-3：LR-1-语法分析程序-（3-LR-1-analysis-cpp）" class="headerlink" title="方法 3：LR(1) 语法分析程序 （3_LR(1)_analysis.cpp）"></a>方法 3：LR(1) 语法分析程序 （3_LR(1)_analysis.cpp）</h3><h4 id="函数调用关系图-2"><span class="post-title-index">1.2.4.1 </span><a href="#函数调用关系图-2" class="headerlink" title="函数调用关系图"></a>函数调用关系图</h4><p><img src="https://i.loli.net/2021/11/23/qyWHS8Cfd7TZ3Gr.png" alt="image-20211121113156550" style="zoom:45%;"></p>
<h4 id="函数功能及实现思路-1"><span class="post-title-index">1.2.4.2 </span><a href="#函数功能及实现思路-1" class="headerlink" title="函数功能及实现思路"></a>函数功能及实现思路</h4><p>​      请见源程序以及程序注释</p>
<h2 id="源程序"><span class="post-title-index">1.3 </span><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><p><a href="https://github.com/thatmee/Compiler_Labs/tree/master/Lab2_syntax_analysis">Compiler_Labs/Lab2_syntax_analysis at master · thatmee/Compiler_Labs (github.com)</a></p>
<h2 id="程序测试及成果说明"><span class="post-title-index">1.4 </span><a href="#程序测试及成果说明" class="headerlink" title="程序测试及成果说明"></a>程序测试及成果说明</h2><h3 id="递归调用分析程序"><span class="post-title-index">1.4.1 </span><a href="#递归调用分析程序" class="headerlink" title="递归调用分析程序"></a>递归调用分析程序</h3><p><img src="https://i.loli.net/2021/11/23/ZX2aiE4zU67Whc5.png" alt="image-20211121100326478" style="zoom:80%;"></p>
<h3 id="LL-1-分析程序"><span class="post-title-index">1.4.2 </span><a href="#LL-1-分析程序" class="headerlink" title="LL(1) 分析程序"></a>LL(1) 分析程序</h3><p><img src="https://i.loli.net/2021/11/21/MI8BERd23OpvTXy.png" alt="image-20211121100433090" style="zoom:80%;"></p>
<h3 id="LR-1-分析程序"><span class="post-title-index">1.4.3 </span><a href="#LR-1-分析程序" class="headerlink" title="LR(1) 分析程序"></a>LR(1) 分析程序</h3><p><img src="https://i.loli.net/2021/11/21/1vXq6EhrgpAD8FG.png" alt="image-20211121100617913" style="zoom:80%;"></p>
<p><img src="https://i.loli.net/2021/11/21/wgW4qx5LOBjfZzH.png" alt="image-20211121100657851" style="zoom:74%;"></p>
<h3 id="错误测试——递归调用分析程序"><span class="post-title-index">1.4.4 </span><a href="#错误测试——递归调用分析程序" class="headerlink" title="错误测试——递归调用分析程序"></a>错误测试——递归调用分析程序</h3><p><img src="https://i.loli.net/2021/11/21/CnzdbJGhTSsDRAv.png" alt="image-20211121100857316"></p>
<p><img src="https://i.loli.net/2021/11/23/fnGpI6CveYj4kZV.png" alt="image-20211121101013482" style="zoom:74%;"></p>
<p><img src="https://i.loli.net/2021/11/21/lxP8cr1dRwsQpy6.png" alt="image-20211121101118874" style="zoom:75%;"></p>
<h3 id="错误测试——LL-1-分析程序"><span class="post-title-index">1.4.5 </span><a href="#错误测试——LL-1-分析程序" class="headerlink" title="错误测试——LL(1) 分析程序"></a>错误测试——LL(1) 分析程序</h3><p><img src="https://i.loli.net/2021/11/21/jrqkHAhgaQwK8IX.png" alt="image-20211121101334064" style="zoom:80%;"></p>
<h3 id="错误测试——LR-1-分析程序"><span class="post-title-index">1.4.6 </span><a href="#错误测试——LR-1-分析程序" class="headerlink" title="错误测试——LR(1) 分析程序"></a>错误测试——LR(1) 分析程序</h3><p><img src="https://i.loli.net/2021/11/23/UfGuYA6WOjpbMik.png" alt="image-20211121101446142" style="zoom:80%;"></p>
<h2 id="值得注意的问题总结"><span class="post-title-index">1.5 </span><a href="#值得注意的问题总结" class="headerlink" title="值得注意的问题总结"></a>值得注意的问题总结</h2><ul>
<li><p><strong>VS2019 常量中有换行符、报错缺少 ; 等奇怪的问题</strong></p>
<p>  多半是编码的问题，记录 VS2019 如何修改编码：</p>
<p>  <img src="https://i.loli.net/2021/11/17/FiKLdtCpyVNzqWo.png" alt="image-20211117020547176" style="zoom: 67%;"></p>
<p>  <img src="https://i.loli.net/2021/11/23/qyhGtW92drSoxTV.png" alt="image-20211121031729780" style="zoom: 50%;"></p>
<p>  <img src="https://i.loli.net/2021/11/17/E7YfqXsjVIADxCS.png" alt="image-20211117020725253" style="zoom: 67%;"></p>
<p>  <img src="https://i.loli.net/2021/11/17/dH1vWXMi7L5UeTx.png" alt="image-20211117020748895" style="zoom:50%;"></p>
</li>
<li><p><strong>getline 有时被跳过导致无法输入数据的问题</strong></p>
<p>  <a href="https://www.cnblogs.com/wswang/p/4833900.html">C++中getline被跳过 - wswang - 博客园 (cnblogs.com)</a></p>
</li>
<li><p><strong>unordered_map 的key值问题</strong></p>
<p>  自定义的类型作为 key，需要自己重写哈希函数，或者改为使用 map。但是 map 的效率远不如 unordered_map，最优思路还是重写哈希函数。</p>
</li>
</ul>
<h2 id="仍待改进的地方"><span class="post-title-index">1.6 </span><a href="#仍待改进的地方" class="headerlink" title="仍待改进的地方"></a>仍待改进的地方</h2><ul>
<li>没有使用程序实现 LL(1) 文法的改写（消除二义性、消除左递归、提取左公因子）</li>
<li>程序中使用大量较为复杂的数据类型，执行效率有待考量</li>
<li>LL(1) 和 LR(1) 分析程序的错误报告不能报告错误类型。</li>
</ul>
]]></content>
      <categories>
        <category>专业</category>
        <category>专业课程</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>编译器</tag>
      </tags>
  </entry>
  <entry>
    <title>安装face_recognition中遇到的坑</title>
    <url>/2021/09/16/%E5%AE%89%E8%A3%85face_recognition%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>打算跑一下人脸识别代码，结果在配环境上遭遇了滑铁卢… <span id="more"></span></p>
<h1 id="pip命令配置"><span class="post-title-index">1 </span><a href="#pip命令配置" class="headerlink" title="pip命令配置"></a>pip命令配置</h1><ol>
<li><p><strong><code>pip install --upgrade pip</code>失败之后pip命令失效的问题</strong></p>
<ul>
<li>需要使用<code>python -m ensurepip</code>才能让pip命令重新生效（感觉是—update失败但是删除了一些pip原本的文件，导致pip无法使用）</li>
<li><code>pip install --update --user pip</code>能够成功更新pip</li>
</ul>
</li>
<li><p><strong>pip命令在cmd中无效的问题</strong></p>
<ul>
<li>显然是没有添加环境变量</li>
<li>在添加Python的环境变量时，不仅要添加Python文件夹，还要添加Python/Scripts文件夹，pip.exe、pip3.exe以及其他一些可执行文件都在这个目录下</li>
</ul>
</li>
</ol>
<p><img src="https://i.loli.net/2021/09/16/EptvKmerGnN7dA4.png" alt="image-20210916101933581"></p>
<h1 id="face-recognition包的安装"><span class="post-title-index">2 </span><a href="#face-recognition包的安装" class="headerlink" title="face_recognition包的安装"></a>face_recognition包的安装</h1><h2 id="先安装Cmake"><span class="post-title-index">2.1 </span><a href="#先安装Cmake" class="headerlink" title="先安装Cmake"></a>先安装Cmake</h2><p><code>pip install cmake</code> 没有遇到什么问题</p>
<h2 id="安装dlib的坑"><span class="post-title-index">2.2 </span><a href="#安装dlib的坑" class="headerlink" title="安装dlib的坑"></a>安装dlib的坑</h2><ol>
<li><p><strong>找不到C_CXX_COMPILER的问题</strong></p>
<ul>
<li>由于使用 <code>pip install dlib</code> 命令时，中间文件都在C盘一个奇怪的目录中（xxx/Temp/xxx），猜测这个目录是临时目录，可能安装失败后就自动删除了，所以一直找不到详细错误报告</li>
<li>之后在尝试离线安装的时候，中间文件以及错误报告都在自己创建的文件夹中，于是查看详细错误报告，发现是VS的目录下一个<strong>CL.exe</strong>文件打开失败。退出360安全卫士后解决。（可恶的360！）</li>
</ul>
</li>
<li><p><strong>subprocess.CalledProcessError: Command ‘[‘cmake’, ‘—build’, ‘.’, ‘—config’, ‘Release’, ‘—‘, ‘/m’]’ returned non-zero exit status 1.</strong></p>
<ul>
<li>退出360重新安装时出现这个报错。（在疯的边缘了）</li>
<li>遍寻伟大的互联网，找到如下解决方法：<a href="https://blog.csdn.net/jiang7121250/article/details/118570570">(5条消息) Windows 安装Dlib出现的问题_jiang7121250的博客-CSDN博客</a></li>
<li>不再报上面的错了，但装完使用pipshow还是找不到（猜测是安装路径的问题，但是把文件拷贝过去还是找不到，直接在依赖包的路径下面安装也不行，所以又尝试了安装dlib.whl文件，见下）</li>
</ul>
</li>
<li><p><strong>尝试安装dlib的whl文件，报错：平台不支持</strong></p>
<ul>
<li><p>了解到cp36代表支持Cpython3.6，于是conda一个新环境试试</p>
<p><img src="https://i.loli.net/2021/09/16/5JQr6iEeM7vgdup.png" alt="image-20210916013350324"></p>
</li>
<li><p>中间卡住了（一直在solving environment），感觉也是由于环境或者版本的问题</p>
</li>
<li><p>再继续找方法，看到一个神奇的东西：<a href="https://www.cnblogs.com/chrystal/p/13580051.html">如何在win下安装dlib的whl文件（Anaconda方式） - 绛绛 - 博客园 (cnblogs.com)</a></p>
<p>  <img src="https://i.loli.net/2021/09/16/PEG3O6cShpJk4Fg.png" alt="image-20210916014337392"></p>
<p>  <img src="https://i.loli.net/2021/09/16/Y4tmPyWduUz2j6G.png" alt="image-20210916014359229"></p>
</li>
<li><p><code>pip debug --verbose</code> 可以显示当前python支持的包格式，正好对应下载的dlib.whl文件名中一些看不懂的参数说明，于是按照合适的版本重命名，再次尝试</p>
</li>
<li><p>成功安装！！！激动的心颤抖的手，看看这张美丽的截图：</p>
<p>  <img src="https://i.loli.net/2021/09/16/2ZD6xN4v5YMdVCE.png" alt="image-20210916014459262"></p>
</li>
</ul>
</li>
</ol>
<ol>
<li><p><strong>这还没完，这里是第二天装完OpenCv开始跑代码的虾滑…编译器报错dlib的DLL缺失</strong></p>
<ul>
<li>猜测是由于修改文件名的骚操作导致安装出现问题，解决方法是重装dlib……好嘛从头开始，真的是吐了</li>
<li>这又告诉我们，<code>pip show XXX</code> 是无法检测包有没有安装好的。还是得用 <code>import</code>看看能不能正常使用。</li>
</ul>
</li>
<li><p><strong>踏上重装之旅，<code>pip install dlib --verbose</code> 报错：</strong><font color="blue"><strong>error C2734: “GifAsciiTable8x8”: 如果不是外部的，则必须初始化常量对象 (编译源文件 E:\APKS\dlib-19.14.0\too</strong></font></p>
<ul>
<li><p>找到一条看起来很正确的方法！<a href="https://blog.csdn.net/qq_30267617/article/details/119725917">(5条消息) win10安装dlib问题记录_何为其然的博客-CSDN博客</a></p>
</li>
<li><p>根据上述链接，安装方法和Python版本有很大关系，所以我卸载了已有Python，重装了Anaconda【<strong>见第3部分-Python和Anaconda环境配置</strong>】，之后选择Python3.6版本安装成功。</p>
</li>
</ul>
</li>
</ol>
<h2 id="开始安装face-recognition"><span class="post-title-index">2.3 </span><a href="#开始安装face-recognition" class="headerlink" title="开始安装face_recognition"></a>开始安装face_recognition</h2><p><img src="https://i.loli.net/2021/09/16/3BJDdmVGiKhSqoF.png" alt="image-20210916014627953"></p>
<p>非常顺利！！</p>
<h1 id="Python和Anaconda环境配置"><span class="post-title-index">3 </span><a href="#Python和Anaconda环境配置" class="headerlink" title="Python和Anaconda环境配置"></a>Python和Anaconda环境配置</h1><p>由于已经装了Python3.7 和Python3.8，又新下载了Anaconda，一时搞得有些混乱，于是决定把这俩东西整理一下。</p>
<p>参考：<a href="https://www.cnblogs.com/yamin/p/7111397.html">如何在已安装Python条件下，安装Anaconda,，并将原有Python添加到Anaconda中 - amazingym - 博客园 (cnblogs.com)</a></p>
]]></content>
      <categories>
        <category>专业</category>
        <category>环境配置</category>
        <category>Python相关</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>程序设计实践小作业 3 —— 性能</title>
    <url>/2021/11/18/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%E5%B0%8F%E4%BD%9C%E4%B8%9A%203%20%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD/</url>
    <content><![CDATA[<h1 id="程序设计实践小作业-3-——性能"><span class="post-title-index">1 </span><a href="#程序设计实践小作业-3-——性能" class="headerlink" title="程序设计实践小作业 3 ——性能"></a>程序设计实践小作业 3 ——性能</h1><h2 id="题目及要求"><span class="post-title-index">1.1 </span><a href="#题目及要求" class="headerlink" title="题目及要求"></a>题目及要求</h2><h3 id="题目"><span class="post-title-index">1.1.1 </span><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>wordst_bad.cpp用于统计一文本文件里的每个单词的数量以及出现在文本文件中的行号，最后按照出现次数从大到小排列显示出来，如果出现的行号比较多，那么只显示前20次出现的行号。 </p>
<h3 id="要求"><span class="post-title-index">1.1.2 </span><a href="#要求" class="headerlink" title="要求"></a>要求</h3><ul>
<li>测试当前给出的wordst_bad.cpp，给出这些数据：   <ul>
<li>测试用的文本的单词数量</li>
<li>文本所含的不同单词的数量（根据运行结果得出）</li>
<li>排名前三的单词及其数量</li>
<li>执行所用时间（time命令的显示结果）</li>
</ul>
</li>
</ul>
<span id="more"></span>
<ul>
<li>尝试找出程序中的性能问题，并加以改进，给出：<ul>
<li>改进之后的源程序wordst_good.cpp</li>
<li>修改的依据</li>
<li>与wordst_bad相同测试数据下的执行时间比较（time命令的显示结果）</li>
<li>计算性能提高的比例</li>
</ul>
</li>
</ul>
<h2 id="测试及结果分析"><span class="post-title-index">1.2 </span><a href="#测试及结果分析" class="headerlink" title="测试及结果分析"></a>测试及结果分析</h2><ul>
<li><p><strong>测试用例</strong>：<em>请见附件 <code>test.txt</code></em></p>
</li>
<li><p><strong>测试用的文本的单词数量</strong>：58676（通过输出结果以及 Excel 软件得出）</p>
</li>
<li><p><strong>文本所含的不同单词的数量</strong>：<em>请见附件 <code>result.txt</code></em> </p>
</li>
<li><p><strong>排名前三的单词及其数量</strong>：</p>
  <figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">WORD</span>                 COUNT</span><br><span class="line"><span class="attribute">the</span>                  <span class="number">2704</span> </span><br><span class="line"><span class="attribute">and</span>                  <span class="number">2150</span> </span><br><span class="line"><span class="attribute">to</span>                   <span class="number">1486</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行所用时间</strong>：</p>
<p>  <img src="https://i.loli.net/2021/11/15/1pdksAlLOhUS87x.png" alt="image-20211115091455464"></p>
</li>
</ul>
<h2 id="性能优化"><span class="post-title-index">1.3 </span><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="使用-gprof-命令确定瓶颈"><span class="post-title-index">1.3.1 </span><a href="#使用-gprof-命令确定瓶颈" class="headerlink" title="使用 gprof 命令确定瓶颈"></a>使用 gprof 命令确定瓶颈</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">g++ -pg -o wordst_bad wordst_bad.cpp</span></span><br><span class="line"><span class="meta">$</span><span class="bash">time ./wordst_bad test.txt &gt; result.txt</span></span><br><span class="line"><span class="meta">$</span><span class="bash">gprof wordst_bad gmon.out &gt; gprofResult.txt</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如下图，可知在 main 函数中，主要花费时间的函数是 <code>statisWord</code></p>
<p>  <img src="https://i.loli.net/2021/11/15/PgG4AJxhTVmLpiz.png" alt="image-20211115095327831"></p>
</li>
<li><p>于是观察 <code>statisWord</code> 的调用关系，如下图所示，可以发现在 <code>statisWord</code> 中，主要花费时间的是 <code>find</code> 函数和 <code>[]</code> 操作符</p>
<p>  <img src="https://i.loli.net/2021/11/15/MaKrdf289PytTCb.png" alt="image-20211115095609592"></p>
</li>
</ul>
<h3 id="优化"><span class="post-title-index">1.3.2 </span><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="优化数据结构"><span class="post-title-index">1.3.2.1 </span><a href="#优化数据结构" class="headerlink" title="优化数据结构"></a>优化数据结构</h4><ul>
<li><p>经过查询资料，了解到 hash_map 是比 map 更为高效的数据结构，在 C++11 中，规定了使用 <code>unordered_map</code> 来代替 hash_map，因此我将 map 数据结构更换为 <code>unordered_map</code>:</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> std::unordered_map&lt;std::string, WordInfo*&gt; WordsStatis;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>注意这时应使用 C++11 进行编译，添加 <code>-std=c++11</code> 编译选项：</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">g++ -std=c++11 -pg -o wordst_good wordst_good.cpp</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="优化-statisWord-函数中对-find-和-操作符的调用"><span class="post-title-index">1.3.2.2 </span><a href="#优化-statisWord-函数中对-find-和-操作符的调用" class="headerlink" title="优化 statisWord 函数中对 find 和 [] 操作符的调用"></a>优化 statisWord 函数中对 find 和 [] 操作符的调用</h4><ul>
<li><p>根据之前确定的瓶颈，我尝试修改 <code>find</code> 和 <code>[]</code> 的调用次数，尽量保存一些变量，从而减少遍历 <code>map</code> 的次数。如下所示，我将第一次调用 <code>find</code> 的结果保存起来，之后直接在这个迭代器的基础上进行增删改，取消了对 <code>[]</code> 的两次调用，提升了效率：</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">statisWord</span><span class="params">(WordsStatis&amp; wordsStatis, std::string&amp; word, <span class="keyword">int</span> lineNo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   WordsStatis::iterator a = wordsStatis.<span class="built_in">find</span>(word);</span><br><span class="line">   <span class="keyword">if</span>(a == wordsStatis.<span class="built_in">end</span>())</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 如果当前统计表中没找到，则新增一项</span></span><br><span class="line">      WordInfo* wordInfo = <span class="keyword">new</span> WordInfo;</span><br><span class="line">      wordInfo-&gt;lines.<span class="built_in">push_back</span>(lineNo);</span><br><span class="line">      wordsStatis.<span class="built_in">insert</span>(a, <span class="built_in">WordPair</span>(word, wordInfo));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">// 如果找到了，则增加一个新的行号</span></span><br><span class="line">      a-&gt;second-&gt;lines.<span class="built_in">push_back</span>(lineNo);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="优化结果"><span class="post-title-index">1.3.3 </span><a href="#优化结果" class="headerlink" title="优化结果"></a>优化结果</h3><ul>
<li><p>原执行时间</p>
<p>  <img src="https://i.loli.net/2021/11/15/L79pRgobhBi5mHw.png" alt="image-20211115091455464"></p>
</li>
<li><p>优化数据结构后执行时间</p>
<p>  <img src="https://i.loli.net/2021/11/15/E7uA6z8tHIknpgZ.png" alt="image-20211115104946052"></p>
</li>
<li><p>优化 find 和 [] 调用后的执行时间</p>
<p>  <img src="https://i.loli.net/2021/11/15/3lZewJkOpKjy7oG.png" alt="image-20211115110904986"></p>
</li>
</ul>
<h3 id="4-性能提高的比例"><span class="post-title-index">1.3.4 </span><a href="#4-性能提高的比例" class="headerlink" title="4. 性能提高的比例"></a>4. 性能提高的比例</h3><script type="math/tex; mode=display">
0.075\ ÷ \ 0.165\ ≈ \ 45\%</script>]]></content>
      <categories>
        <category>专业</category>
        <category>专业课程</category>
        <category>程序设计实践</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>性能分析</tag>
      </tags>
  </entry>
  <entry>
    <title>静态路由配置实验</title>
    <url>/2021/10/22/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C2/</url>
    <content><![CDATA[<h1 id="计算机网络技术实践-实验报告"><span class="post-title-index">1 </span><a href="#计算机网络技术实践-实验报告" class="headerlink" title="计算机网络技术实践 实验报告"></a>计算机网络技术实践 实验报告</h1><h2 id="环境"><span class="post-title-index">1.1 </span><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li><p>操作系统：Windows 10</p>
</li>
<li><p>网络平台：Dynamips 仿真软件</p>
</li>
<li><p>网络拓扑图</p>
<p>  <img src="https://i.loli.net/2021/10/22/1KtG8ofSaqwCUml.png" alt="image-20211022101835891"></p>
</li>
</ul>
<span id="more"></span>
<h2 id="实验目的"><span class="post-title-index">1.2 </span><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>按照网络拓扑图完成配置：</p>
<ul>
<li>路由器 R1 和 R2 之间的连接配置</li>
<li>路由器与主机（由路由器模拟）之间的连接配置</li>
<li>四台路由器上的静态路由器配置</li>
</ul>
<h2 id="实验内容及步骤"><span class="post-title-index">1.3 </span><a href="#实验内容及步骤" class="headerlink" title="实验内容及步骤"></a>实验内容及步骤</h2><h3 id="路由器R1与R2的连接配置"><span class="post-title-index">1.3.1 </span><a href="#路由器R1与R2的连接配置" class="headerlink" title="路由器R1与R2的连接配置"></a>路由器R1与R2的连接配置</h3><p>根据拓扑图，R1 和 R2 在实验中作为路由器使用，二者通过串行端口进行连接，配置步骤如下：</p>
<ul>
<li>启动 Dynamips 平台服务以及路由器实验的脚本</li>
<li>启动 R1、R2，并设置 idlepc</li>
<li>使用 telnet 命令进入 R1 的控制台，进行配置</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/HgnE1cL7d4Zz6jF.png" alt="image-20211022174013546"></p>
<ul>
<li>同上，配置 R2 的串行接口</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/jibTEk7C1WhMYe5.png" alt="image-20211022174305176"></p>
<h3 id="路由器与主机的连接配置"><span class="post-title-index">1.3.2 </span><a href="#路由器与主机的连接配置" class="headerlink" title="路由器与主机的连接配置"></a>路由器与主机的连接配置</h3><p>根据网络拓扑图，路由器与主机之间使用 fastEthernet 进行连接，配置步骤如下：</p>
<ul>
<li>启动 PC1、PC2</li>
<li>配置 R1</li>
</ul>
<p><img src="https://i.loli.net/2021/11/23/ydxECTIaY1esMAo.png" alt="image-20211022140438782" style="zoom:94%;"></p>
<ul>
<li>配置 PC1</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/ufMzs8SR3lXbD5Y.png" alt="image-20211022140508048"></p>
<ul>
<li>配置 R2</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/7yGB6CbJpXRHtuv.png" alt="image-20211022140552112"></p>
<ul>
<li>配置 PC2</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/3xbHF8GteDUEYBo.png" alt="image-20211022140626627"></p>
<h3 id="静态路由配置"><span class="post-title-index">1.3.3 </span><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h3><ul>
<li>PC1</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/b9XI1LjT5QzUPZq.png" alt="image-20211022141013304"></p>
<ul>
<li>PC2</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/KUv5acjMLmWHXfd.png" alt="image-20211022141043708"></p>
<ul>
<li>R1</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/FdOV8scXPfCmypt.png" alt="image-20211022141116228"></p>
<ul>
<li>R2</li>
</ul>
<p><img src="https://i.loli.net/2021/10/22/mztqsa7UG13CWhg.png" alt="image-20211022141136014"></p>
<h2 id="实验结果"><span class="post-title-index">1.4 </span><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><p>经过上述配置，以及添加通往 1.0.0.0 的静态路由（见 五-2.），实现了任意一个路由器可以 ping 通任意一个 IP 地址，截图如下：</p>
<p><img src="https://i.loli.net/2021/10/22/O9P26ealgb7xMTG.png" alt="image-20211022163356201"></p>
<p><img src="https://i.loli.net/2021/10/22/6Grx9HqABJVfe1y.png" alt="image-20211022163256137"></p>
<h2 id="实验中的问题及心得"><span class="post-title-index">1.5 </span><a href="#实验中的问题及心得" class="headerlink" title="实验中的问题及心得"></a>实验中的问题及心得</h2><ul>
<li><p><strong>一定要记得配置完成后开启接口：no shutdown</strong></p>
<p>  如果有接口没有开启，导致无法ping通，可以使用 <code>show running-config</code> 查看设备每个接口的配置情况，没有开启的接口将会显示 <code>shut down</code> 这样一行信息</p>
</li>
<li><p><strong>PC1 和 PC2 ping不通 1.1.1.1 以及 1.1.1.2 的问题</strong></p>
<p>  首先使用 <code>ping</code> 命令一段一段排查连通情况如下：</p>
<ul>
<li><p>PC2 ping 2.1.1.2、2.1.1.1、3.1.1.1 没有问题</p>
</li>
<li><p>PC1 ping 3.1.1.2、3.1.1.1、2.1.1.1 没有问题</p>
</li>
<li><p>R1 和 R2 的 serial 端口互相也能够ping通（1.1.1.1 和 1.1.1.2）</p>
<p>起初，我以为是接口类型的影响，询问老师后得知在这一层面接口不会影响到连接。只能是路由的问题，仔细检查后才发现，PPT中所给的静态路由配置，PC1 只包含了通往 3.0.0.0 的路由，PC2 也只包含了通往 2.0.0.0 的路由，因此对 PC1 和 PC2，1.1.1.1 以及 1.1.1.2 都是未知的 IP 地址，所以是 ping 不通的。</p>
<p>发现了问题的根源后，解决方法就一目了然了，在 PC1 和 PC2 添加通往 1.0.0.0 的路由：</p>
<p><img src="https://i.loli.net/2021/10/22/iTCBxEeN2LpOVYc.png" alt="image-20211022161858416"></p>
<p>再次测试，结果如下：</p>
<p><img src="https://i.loli.net/2021/10/22/UGvb1rHJjIZaXEx.png" alt="image-20211022162312349"></p>
</li>
</ul>
</li>
</ul>
<h2 id="实验思考"><span class="post-title-index">1.6 </span><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h2><p>本次实验在上次实验的基础上增加了三种新的配置：路由器与路由器的连接配置、路由器与主机的连接配置、路由器的静态路由配置。其中路由器间的连接涉及 <code>clock rate</code> 和 <code>encapsulation</code> 等属性的配置（相关知识整理在 七），路由器的静态路由配置影响着整个网络拓扑结构的连通性。</p>
<p>在本次实验中，我自己动手完成了所有配置任务，成功运行了开头所示的网络拓扑结构，使我对 Dynamips 的各种配置命令和配置方法更加熟悉。本次实验难度并不高，但在我尝试解决PC1、PC2 ping不通 1.1.1.1 这一问题时，一个接口处于 <code>shutdown</code> 状态导致我花费了一些时间进行排查，最终利用分段执行 <code>ping</code> 命令以及 <code>show running-config</code> 命令解决了问题。看来今后做实验还是要踏踏实实，不能求快而忽略细节。</p>
<h2 id="相关知识复习梳理"><span class="post-title-index">1.7 </span><a href="#相关知识复习梳理" class="headerlink" title="相关知识复习梳理"></a>相关知识复习梳理</h2><h3 id="Ethernet、FastEthernet-与-Serial"><span class="post-title-index">1.7.1 </span><a href="#Ethernet、FastEthernet-与-Serial" class="headerlink" title="Ethernet、FastEthernet 与 Serial"></a>Ethernet、FastEthernet 与 Serial</h3><ul>
<li>serial 是串行口，一般用于连接设备，不能连接电脑</li>
<li>FastEthernet 是以太口,平时 pc 用的就是这种接口</li>
<li>FastEthernet 与 Ethernet 之间最大的区别是速度上的区别。Ethernet 的传输速率是 $10\ mbit/s$，FastEthernet 则是 $100\ mbit/s$</li>
</ul>
<h3 id="Point-to-Point-Protocol-PPP-Encapsulation"><span class="post-title-index">1.7.2 </span><a href="#Point-to-Point-Protocol-PPP-Encapsulation" class="headerlink" title="Point-to-Point Protocol (PPP) Encapsulation"></a>Point-to-Point Protocol (PPP) Encapsulation</h3><ul>
<li><p>PPP 是一个广域网的数据链路层协议，PPP 以及衍生出的 PPPoE、PPPoA 等协议成为目前广域网连接和带宽接入中使用最多的数据链路层协议</p>
</li>
<li><p>PPP协议提供了一种在点对点链路上传输多协议数据包的标准方法.它设计的目的是用简单的链路在两上接点之间传输数据,从而为各种主机网络提供一种通用的网络互联解决方案</p>
<p>  <img src="https://i.loli.net/2021/10/22/dD19eKmzqiAOwCn.png" alt="image-20211022171004835"></p>
</li>
</ul>
<h3 id="DCE-与-DTE"><span class="post-title-index">1.7.3 </span><a href="#DCE-与-DTE" class="headerlink" title="DCE 与 DTE"></a>DCE 与 DTE</h3><ul>
<li><p>DCE（数据通信设备）：</p>
<ul>
<li>该设备和其与通信网络的连接构成了网络终端的用户网络接口。它提供了到网络的一条物理连接、转发业务量，并且提供了一个用于同步 DCE 设备和 DTE 设备之间数据传输的<strong>时钟信号</strong>。调制解调器和接口卡都是 DCE 设备的例子。</li>
<li>只有在同步通信方式的线路上才会有时钟速率，同步通信时需要线路两端进行信号发送频率的同步，也就是同步的时钟，在实际工程中由协议转换器， modem 等线路控制设备来提供，而实验环境中没有专门的线路控制设备，所以由其中的一台 router 的 serial 接口来提供。DCE 一端的确定是由 router 之间的 cable 的线序来决定的，所以 back to back 的 cable 都标明 DCE 和 DTE。</li>
<li>只有标明 DCE 一端的才需要设置 clock rate</li>
<li>同步时钟的频率和带宽没有直接的联系，<code>115200</code> 指的是以 115200 比特率时间间隔添加发送同步位</li>
<li>可以设置其他数值，只要是两端都能达到那个标准即可，对通信没有影响</li>
</ul>
</li>
<li><p>DTE（数据终端设备）：</p>
<p>  指的是位于用户网络接口用户端的设备，它能够作为信源、信宿或同时为二者。数据终端设备通过数据通信设备（例如，调制解调器）连接到一个数据网络上，并且通常<strong>使用数据通信设备产生的时钟信号</strong>。数据终端设备包括计算机、协议翻译器以及多路分解器等设备。</p>
</li>
<li><p>DTE 和 DCE 的区分是针对串行端口的，路由器通常通过串行端口连接广域网络。对于标准的串行端口，通常从外观就能判断是 DTE 还是 DCE，DTE 是针头（俗称公头），DCE 是孔头（俗称母头），这样两种接口才能接在一起。</p>
</li>
<li><p><a href="https://www.cnblogs.com/bakari/archive/2012/08/05/2623703.html">DCE 与 DTE （转） - 猿大白 - 博客园 (cnblogs.com)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>专业</category>
        <category>专业课程</category>
        <category>计算机网络</category>
        <category>计算机网络技术实践</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>计算机网络</tag>
        <tag>Dynamips</tag>
      </tags>
  </entry>
  <entry>
    <title>RIP 和 OSPF 协议配置实验</title>
    <url>/2021/11/14/%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C3/</url>
    <content><![CDATA[<h1 id="RIP-和-OSPF-路由协议的配置及协议流程分析——实验报告"><span class="post-title-index">1 </span><a href="#RIP-和-OSPF-路由协议的配置及协议流程分析——实验报告" class="headerlink" title="RIP 和 OSPF 路由协议的配置及协议流程分析——实验报告"></a>RIP 和 OSPF 路由协议的配置及协议流程分析——实验报告</h1><h2 id="环境（详细说明运行的操作系统，网络平台，网络拓扑图）"><span class="post-title-index">1.1 </span><a href="#环境（详细说明运行的操作系统，网络平台，网络拓扑图）" class="headerlink" title="环境（详细说明运行的操作系统，网络平台，网络拓扑图）"></a>环境（详细说明运行的操作系统，网络平台，网络拓扑图）</h2><ul>
<li><p>操作系统：Windows 10</p>
</li>
<li><p>网络平台：Dynamips 仿真软件</p>
</li>
<li><p>网络拓扑图</p>
<p>  <img src="https://i.loli.net/2021/11/23/8rFvNcBmIEW6o2Z.png" alt="image-20211112202456632"></p>
  <span id="more"></span>
</li>
</ul>
<h2 id="实验目的"><span class="post-title-index">1.2 </span><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>在上一次实验的基础上实现RIP和OSPF路由协议</li>
<li>自己设计网络物理拓扑和逻辑网段，并在其上实现RIP和OSPF协议（不能少于4台路由器，要求IP地址第二位是学号后三位%255）</li>
<li>通过debug信息详细描述RIP和OSPF协议的工作过程，包括初始信息交互、路由计算、链路故障处理等部分。（要修改部分链路，观察工作过程）</li>
<li><p>RIP协议中观察没有配置水平分割和配置水平分割后协议的工作流程，和路由消息传递方式； （要修改部分链路，观察区别，默认有水平分割）</p>
</li>
<li><p>OSPF中数据库同步信息的格式和同步对象？链路改变信息如何发送，具体格式（要修改部分链路，观察消息传递过程）</p>
</li>
</ul>
<h2 id="实验内容及步骤"><span class="post-title-index">1.3 </span><a href="#实验内容及步骤" class="headerlink" title="实验内容及步骤"></a>实验内容及步骤</h2><h3 id="配置命令含义及步骤"><span class="post-title-index">1.3.1 </span><a href="#配置命令含义及步骤" class="headerlink" title="配置命令含义及步骤"></a>配置命令含义及步骤</h3><p><a href="https://cloud.tencent.com/developer/article/1497889">思科命令大全</a></p>
<p><a href="https://blog.csdn.net/chentiefeng521/article/details/51746733">思科基础命令大全-CSDN博客</a></p>
<h4 id="RIP-配置命令"><span class="post-title-index">1.3.1.1 </span><a href="#RIP-配置命令" class="headerlink" title="RIP 配置命令"></a>RIP 配置命令</h4><ul>
<li><strong>show ip route</strong> 查看路由表</li>
<li><strong>router rip</strong> 启动 RIP 进程 </li>
<li><strong>network</strong> 通告网络 </li>
<li><strong>version</strong> 定义 RIP 的版本</li>
<li><strong>neighbor</strong> 配置单播更新的目标<ul>
<li><strong>单播更新</strong>：指 RIP 使用单播发送 RIP 报文。默认情况下，RIP 每隔 30s 以<code>广播或组播</code>方式交换整个路由表的信息，这样会耗费大量网络带宽，尤其是在广域网中，可能出现严重的性能问题。我们可以使用单播更新的方式来交换路由信息，以此来改善性能问题。当使用 slient-interface 命令配置抑制接口后，再指定单播更新的目的地址后，单播更新有效；如果在接口下使用 undo rip output 命令来配置抑制接口，就是再指定单播更新的目的地址也是无法正常的发送更新的路由条目的。</li>
</ul>
</li>
<li><strong>debug ip rip</strong> 动态查看 RIP 的更新过程 </li>
<li><strong>no ip split-horizon</strong> 关闭水平分割</li>
</ul>
<h4 id="RIP-配置步骤"><span class="post-title-index">1.3.1.2 </span><a href="#RIP-配置步骤" class="headerlink" title="RIP 配置步骤"></a>RIP 配置步骤</h4><ul>
<li>配置 R1</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Router<span class="selector-id">#configure</span> terminal</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#router</span> rip</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#version</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">1.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">2.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">4.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#neighbor</span> <span class="number">1.193</span>.<span class="number">1.2</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#neighbor</span> <span class="number">4.193</span>.<span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置 R2</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Router<span class="selector-id">#configure</span> terminal</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#router</span> rip</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#version</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">1.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">3.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">5.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#neighbor</span> <span class="number">1.193</span>.<span class="number">1.1</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#neighbor</span> <span class="number">5.193</span>.<span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置 R3</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Router<span class="selector-id">#configure</span> terminal</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#router</span> rip</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#version</span> <span class="number">2</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">4.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">5.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">6.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#neighbor</span> <span class="number">4.193</span>.<span class="number">1.1</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#neighbor</span> <span class="number">5.193</span>.<span class="number">1.1</span></span><br></pre></td></tr></table></figure>
<h4 id="OSPF-配置命令"><span class="post-title-index">1.3.1.3 </span><a href="#OSPF-配置命令" class="headerlink" title="OSPF 配置命令"></a>OSPF 配置命令</h4><ul>
<li><strong>router ospf 10</strong> 启动 OSPF 进程，10 为进程号（只具有本地意义）</li>
<li><strong>network …  area …</strong> 宣告网络和 OSPF 区域号，网络的宣告使用<strong>反掩码</strong>形式，同一个区域中的路由器区域号要<strong>保持一致</strong></li>
<li>Router(config-if)#<strong>ip ospf hello-interval 5</strong> 修改默认的 Hello 报文发送间隔为 5s</li>
<li>Router(config-if)#<strong>ip ospf dead-interval 20 </strong> 修改默认的死亡间隔为 20s （默认为 Hello 间隔的 4 倍）</li>
<li><strong>debug ip ospf events</strong> 显示OSPF 发生的事件</li>
<li><strong>debug ip ospf packet</strong> 显示路由器收到的所有的 OSPF 数据包</li>
<li><strong>debug ip ospf flood</strong> 显示与泛洪相关的所有信息</li>
<li><strong>show ip ospf neighbor</strong> 查看 OSPF 邻居的基本信息</li>
</ul>
<h4 id="OSPF-配置步骤"><span class="post-title-index">1.3.1.4 </span><a href="#OSPF-配置步骤" class="headerlink" title="OSPF 配置步骤"></a>OSPF 配置步骤</h4><ul>
<li>配置 R1</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#router</span> ospf <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">1.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">2.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">4.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#inter</span> s1/<span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf hello-interval <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf dead-interval <span class="number">20</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span>#exit</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#inter</span> s1/<span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf hello-interval <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf dead-interval <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置 R2</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#router</span> ospf <span class="number">2</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">1.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">2.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">4.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#inter</span> s1/<span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf hello-interval <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf dead-interval <span class="number">20</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span>#exit</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#inter</span> s1/<span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf hello-interval <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf dead-interval <span class="number">20</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置 R3</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#router</span> ospf <span class="number">3</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">4.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">5.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">6.0</span>.<span class="number">0.0</span> <span class="number">0.255</span>.<span class="number">255.255</span> area <span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#inter</span> s1/<span class="number">0</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf hello-interval <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf dead-interval <span class="number">20</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#inter</span> s1/<span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf hello-interval <span class="number">5</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> ospf dead-interval <span class="number">20</span></span><br></pre></td></tr></table></figure>
<h3 id="分析-RIP-协议的工作过程"><span class="post-title-index">1.3.2 </span><a href="#分析-RIP-协议的工作过程" class="headerlink" title="分析 RIP 协议的工作过程"></a>分析 RIP 协议的工作过程</h3><h4 id="信息交互过程（以-R1-为例）"><span class="post-title-index">1.3.2.1 </span><a href="#信息交互过程（以-R1-为例）" class="headerlink" title="信息交互过程（以 R1 为例）"></a>信息交互过程（以 R1 为例）</h4><ul>
<li><p>使用 <code>debug ip rip</code> 命令展示 RIP 报文收发过程</p>
</li>
<li><p>可以看到，R1 收到了来自 S1/0、4.193.1.2 的更新包和来自 s1/1、1.193.1.2 的更新包，每一个包中包含了目标 IP 地址以及对应的跳数信息。结合网络拓扑图，分析跳数信息得到：</p>
<ul>
<li>每个路由器到目标 IP 地址所需的跳数不包含本路由器</li>
<li><p>由于我所设计的网络拓扑图的环形结构，使得从不同端口到达某一 IP 地址的跳数不同:</p>
<ul>
<li>s1/0 端口收到的是 RT3 发来的消息，因此在 s1/0 得到的消息中，到达 3.0.0.0 所需跳数为 2，路径为： RT1 —&gt; RT3 —&gt; RT2</li>
<li>s1/1 端口收到的是 RT2 发来的消息，因此这时到达 3.0.0.0 所需跳数为 1，路径为： RT1 —&gt; RT2</li>
</ul>
<p><img src="https://i.loli.net/2021/11/14/r9JvntZOYmWN1ba.png" alt="image-20211114122518150"></p>
</li>
</ul>
</li>
<li><p>同时，可以看到 R1 向与自己直连的所有端口都发送了更新信息：</p>
<p>  <img src="https://i.loli.net/2021/11/14/59cyZF17JSidTum.png" alt="image-20211114123206955"></p>
<p>  <img src="https://i.loli.net/2021/11/14/zNjWuVSUhHaYBJp.png" alt="image-20211114123223673"></p>
<p>  <img src="https://i.loli.net/2021/11/14/nbxJUMlzZtaCB5k.png" alt="image-20211114123239128"></p>
</li>
<li><p>下面的消息说明，R1 建立了新的表项，包含目标 IP 和跳数信息：</p>
<p>  <img src="https://i.loli.net/2021/11/14/gcbzlkRP8U5uhIL.png" alt="image-20211114123442248"></p>
</li>
<li><p>观察最终稳定的路由表，已经生成了到达各个网段的路由信息。很明显，各个设备之间通信的跳数都是 1，说明 RIP 协议自动选择了跳数最小的一条路径：</p>
<p>  <img src="https://i.loli.net/2021/11/14/AfNLsOWqQoVe6tg.png" alt="image-20211114125411293"></p>
</li>
</ul>
<h4 id="链路故障处理"><span class="post-title-index">1.3.2.2 </span><a href="#链路故障处理" class="headerlink" title="链路故障处理"></a>链路故障处理</h4><ul>
<li><p>尝试切断网络 5.0.0.0，删除 R2 的 s1/1 端口的 IP 信息并关掉这一端口：</p>
  <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">Router<span class="selector-id">#conf</span> t</span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config)</span></span><span class="selector-id">#inter</span> s1/<span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">Router</span><span class="params">(config-if)</span></span>#shutdown</span><br></pre></td></tr></table></figure>
</li>
<li><p>如下所示，观察 R1 的路由表的变化，可见通往网络 5.0.0.0 的分支少了一条</p>
<p>  <img src="https://i.loli.net/2021/11/14/EOfu5d2D6NSZLQJ.png" alt="image-20211114130912113"></p>
</li>
<li><p>如下所示，观察 R2 的路由表，可见，由于拓扑结构的变化，R2 通往网络 6.0.0.0 所需的跳数变成了 2（只能通过蓝色箭头路径到达）：</p>
<p>  <img src="https://i.loli.net/2021/11/23/YHd4cR6PghC5kNE.png" alt="image-20211114131239713" style="zoom:50%;"></p>
<p>  <img src="https://i.loli.net/2021/11/14/VOtw3aJvbPTB4p7.png" alt="image-20211114131021053"></p>
</li>
</ul>
<h4 id="水平分割功能测试与分析"><span class="post-title-index">1.3.2.3 </span><a href="#水平分割功能测试与分析" class="headerlink" title="水平分割功能测试与分析"></a>水平分割功能测试与分析</h4><ul>
<li><p>默认情况下是开始水平分割的，在某个接口中使用 <code>no ip split horizon</code> 命令可以关闭该接口的水平分割功能，这里我关闭 R2 的 s1/0 接口</p>
</li>
<li><p>观察 R2 收发的信息，R2 从 s1/0 端口收到了三条路由消息：</p>
<p>  <img src="https://i.loli.net/2021/11/14/c1bVv8oLleIhWR3.png" alt="image-20211114132401286"></p>
</li>
<li><p>再观察 R1 收发的信息，R1 从 s1/1 接口收到了六条路由消息，其中包含 R2 的 s1/0 端口所收到的三条。由此可以看出，R2  的 s1/0 端口将自己收到的消息重新又通过学习到这条消息的接口转发了出去。这样会产生路由环路问题（见 2.3.3）</p>
<p>  <img src="https://i.loli.net/2021/11/14/Rufmpa5VIyP26vN.png" alt="image-20211114132527080"></p>
</li>
</ul>
<h3 id="分析-OSPF-协议的工作过程"><span class="post-title-index">1.3.3 </span><a href="#分析-OSPF-协议的工作过程" class="headerlink" title="分析 OSPF 协议的工作过程"></a>分析 OSPF 协议的工作过程</h3><h4 id="数据库同步信息的格式和同步对象"><span class="post-title-index">1.3.3.1 </span><a href="#数据库同步信息的格式和同步对象" class="headerlink" title="数据库同步信息的格式和同步对象"></a>数据库同步信息的格式和同步对象</h4><ul>
<li>使用 <code>debug ip ospf events</code> 命令，可以看到路由器接收到的 Hello 报文，以及报文发来的端口等信息</li>
</ul>
<p><img src="https://i.loli.net/2021/11/14/TJRxteUsMuQvZrl.png" alt="image-20211114161052447"></p>
<p><img src="https://i.loli.net/2021/11/14/3Dt8MGFqELegNdz.png" alt="image-20211114161118759"></p>
<ul>
<li><p>使用 <code>debug ip ospf packet</code> 命令，显示的内容更加详细：</p>
<p>  <img src="https://i.loli.net/2021/11/23/mYZq2GocOu9WCNv.png" alt="image-20211114164920050"></p>
<p>  格式说明：</p>
<ul>
<li>v:2    表示 OSPF v2 版本</li>
<li>t:1     表示 Type，即类型，类型 1 是 Hello 报文</li>
<li>l:48   长度 Length 是 48</li>
<li>rid:5.193.1.1    发送整个报文的路由器的RID</li>
<li>aid:0.0.0.0    表示所在区域是 0</li>
<li>chk:F02F     表示验证和</li>
<li>aut:0      表示验证，0 表示空验证，1 表示明文验证，2 表示MD5验证</li>
<li>auk:       验证相关的内容，因为没有使用验证，所以没有值</li>
<li>from Serial1/1    表示从s1/1接口接收到的OSPF分组</li>
</ul>
</li>
</ul>
<h4 id="链路改变信息"><span class="post-title-index">1.3.3.2 </span><a href="#链路改变信息" class="headerlink" title="链路改变信息"></a>链路改变信息</h4><ul>
<li><p>关闭 R2 的 s1/1 端口</p>
</li>
<li><p>R1 有如下泛洪消息：</p>
<p>  <img src="https://i.loli.net/2021/11/14/dSP1uc89x42ZIKT.png" alt="image-20211114164029596" style="zoom:80%;"></p>
</li>
<li><p>R2 有如下泛洪消息：</p>
<p>  <img src="https://i.loli.net/2021/11/23/I8p6Vk2tc3Q59wN.png" alt="image-20211114164536886" style="zoom:80%;"></p>
</li>
<li><p>路由表随之发生变化：</p>
<p>  <img src="https://i.loli.net/2021/11/14/tFLoBAv6rWe37Zf.png" alt="image-20211114165909442"></p>
</li>
</ul>
<h2 id="实验结果"><span class="post-title-index">1.4 </span><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="RIP"><span class="post-title-index">1.4.1 </span><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h3><h4 id="所有设备能够互相-ping-通"><span class="post-title-index">1.4.1.1 </span><a href="#所有设备能够互相-ping-通" class="headerlink" title="所有设备能够互相 ping 通"></a>所有设备能够互相 ping 通</h4><ul>
<li><p>从 R3 ping PC 2：</p>
<p>  <img src="https://i.loli.net/2021/11/23/ZaMwd1J6t3uNj7D.png" alt="image-20211114121336520" style="zoom:80%;"></p>
</li>
<li><p>网络 3 ping 网络 6：</p>
<p>  <img src="https://i.loli.net/2021/11/23/P5BLmMCNtxbHwoa.png" alt="image-20211114121701316" style="zoom:80%;"></p>
</li>
<li><p>网络 3 ping 网络 2：</p>
<p>  <img src="https://i.loli.net/2021/11/23/nhvw29lAVQfPcGF.png" alt="image-20211114121804124" style="zoom:80%;"></p>
</li>
<li><p>网络 6 ping 网络 2：</p>
<p>  <img src="https://i.loli.net/2021/11/23/7oXTueJgv2WxIl1.png" alt="image-20211114121939769" style="zoom:80%;"></p>
</li>
</ul>
<h4 id="如下图所示，路由表正确："><span class="post-title-index">1.4.1.2 </span><a href="#如下图所示，路由表正确：" class="headerlink" title="如下图所示，路由表正确："></a>如下图所示，路由表正确：</h4><ul>
<li><p>每个路由器都含有到 6 个网段的路由信息</p>
</li>
<li><p>路由信息中非直连的网段，都是根据 RIP 协议学习来的</p>
</li>
<li><p>R1：</p>
<p>  <img src="https://i.loli.net/2021/11/14/htNxfzZHcmiVso2.png" alt="image-20211114120049538" style="zoom: 80%;"></p>
</li>
<li><p>R2：</p>
<p>  <img src="https://i.loli.net/2021/11/14/pvIbTcJozX8BOhu.png" alt="image-20211114120027319" style="zoom:80%;"></p>
</li>
<li><p>R3：</p>
<p>  <img src="https://i.loli.net/2021/11/14/YcoHMBNtkA8FOIU.png" alt="image-20211114115938761" style="zoom:80%;"></p>
</li>
</ul>
<h3 id="OSPF"><span class="post-title-index">1.4.2 </span><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h3><h4 id="所有设备能够互相-ping-通-1"><span class="post-title-index">1.4.2.1 </span><a href="#所有设备能够互相-ping-通-1" class="headerlink" title="所有设备能够互相 ping 通"></a>所有设备能够互相 ping 通</h4><ul>
<li><p>网络 2 ping 网络 3：</p>
<p>  <img src="https://i.loli.net/2021/11/14/WQF4MgLUNcDjopO.png" alt="image-20211114170127285" style="zoom:80%;"></p>
</li>
<li><p>网络 2 ping 网络 6：</p>
<p>  <img src="https://i.loli.net/2021/11/23/BK9eM4NnOEw8Hz3.png" alt="image-20211114170234863" style="zoom:80%;"></p>
</li>
<li><p>网络 3 ping 网络 6：</p>
<p>  <img src="https://i.loli.net/2021/11/23/K4AyUNFVm6zRb3k.png" alt="image-20211114170306051" style="zoom:80%;"></p>
</li>
</ul>
<h4 id="路由表正确"><span class="post-title-index">1.4.2.2 </span><a href="#路由表正确" class="headerlink" title="路由表正确"></a>路由表正确</h4><ul>
<li><p>每个路由器都含有到 6 个网段的路由信息</p>
</li>
<li><p>路由信息中非直连的网段，都是根据 OSPF 协议学习来的</p>
</li>
<li><p>R1：</p>
<p>  <img src="https://i.loli.net/2021/11/14/DU7WBsrxiC6b2e5.png" alt="image-20211114170528060"></p>
</li>
<li><p>R2：</p>
<p>  <img src="https://i.loli.net/2021/11/14/rLWnw1CxtI4ydpi.png" alt="image-20211114170631889"></p>
</li>
<li><p>R3：</p>
<p>  <img src="https://i.loli.net/2021/11/14/z6Qfmnlek2oE1St.png" alt="image-20211114170700407"></p>
</li>
</ul>
<h4 id="邻居信息正确"><span class="post-title-index">1.4.2.3 </span><a href="#邻居信息正确" class="headerlink" title="邻居信息正确"></a>邻居信息正确</h4><ul>
<li><p>R1：</p>
<p>  <img src="https://i.loli.net/2021/11/23/J1SZ98wvQ2VAnDz.png" alt="image-20211114172205389" style="zoom:80%;"></p>
</li>
<li><p>R2：</p>
<p>  <img src="https://i.loli.net/2021/11/23/P7LZwTmqzlpQMN5.png" alt="image-20211114172236188" style="zoom:80%;"></p>
</li>
<li><p>R3：</p>
<p>  <img src="https://i.loli.net/2021/11/23/648AZEFPQYJKNTt.png" alt="image-20211114172309794" style="zoom:80%;"></p>
</li>
</ul>
<h2 id="实验中的问题及心得"><span class="post-title-index">1.5 </span><a href="#实验中的问题及心得" class="headerlink" title="实验中的问题及心得"></a>实验中的问题及心得</h2><h3 id="问题1：导入导出配置"><span class="post-title-index">1.5.1 </span><a href="#问题1：导入导出配置" class="headerlink" title="问题1：导入导出配置"></a>问题1：导入导出配置</h3><p><a href="https://blog.csdn.net/zczspring/article/details/4281286">用Dynagen来保存配置文件_zczspring的专栏-CSDN博客</a></p>
<h3 id="问题2：RIP-实验中直连路由信息丢失的问题"><span class="post-title-index">1.5.2 </span><a href="#问题2：RIP-实验中直连路由信息丢失的问题" class="headerlink" title="问题2：RIP 实验中直连路由信息丢失的问题"></a>问题2：RIP 实验中直连路由信息丢失的问题</h3><p>如下所示，在 R1 的路由表中，只有两个直连项</p>
<p><img src="https://i.loli.net/2021/11/14/WQdhA82ofsKOpLi.png" alt="image-20211114171036698" style="zoom:80%;"></p>
<p>同时，从 R1 ping 自己的直连端口也不通：</p>
<p><img src="https://i.loli.net/2021/11/14/9bvjdWSoH4NnMEs.png" alt="image-20211114171314165" style="zoom:80%;"></p>
<p>即如图中红框部分出现了问题。</p>
<p><img src="https://i.loli.net/2021/11/23/PqzKkFrH3I4YBdN.png" alt="image-20211114171419565" style="zoom: 33%;"></p>
<p>首先对各个配置项进行了排查，并没有问题，于是猜测可能是 .net 文件书写的问题，进行修改后解决，R1 中正确显示了所有直连路由：</p>
<p><img src="https://i.loli.net/2021/11/14/bSYFO189JigMcEV.png" alt="image-20211114171746307" style="zoom:80%;"></p>
<h3 id="问题3：RIP-路由信息中的-via-0-0-0-0"><span class="post-title-index">1.5.3 </span><a href="#问题3：RIP-路由信息中的-via-0-0-0-0" class="headerlink" title="问题3：RIP 路由信息中的 via 0.0.0.0"></a>问题3：RIP 路由信息中的 via 0.0.0.0</h3><p>如下所示，一开始以为这个 via 代表下一跳的地址，那为什么是 0.0.0.0 呢，查阅资料后了解到，RIP 协议发给邻居路由器的路由表的下一跳地址是对自己来说的，但是这个下一跳地址发给邻居路由器之后，其实没有任何意义。如果邻居路由器经过计算之后，选择的就是这一条路径， 那么这个路由信息中的下一跳就是本机。</p>
<p><img src="https://i.loli.net/2021/11/14/c1bVv8oLleIhWR3.png" alt="image-20211114132401286"></p>
<h2 id="实验思考"><span class="post-title-index">1.6 </span><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h2><ul>
<li><p><strong>实验中，采用下一跳和转发接口这两种方式配置 PC1和 PC2 的静态路由有什么区别？会导致在你的拓扑结构中从 PC1 ping PC2 时的丢包数有什么变化？需要用你的拓扑中 PC1 和 PC2 的 arp 表和路由表中的内容来解释，要附截图。（ PC1 和 PC2 间隔至少两台路由器）</strong></p>
<ul>
<li><p>采用转发接口方式配置 PC1 的静态路由，ping 之前和 ping 之后的 ARP 表如下所示，可见 ARP 表新增了所 ping 的 IP 地址的 MAC 信息</p>
<p><img src="https://i.loli.net/2021/11/14/MV2lyr15GwSEWTF.png" alt="image-20211114173014042"></p>
</li>
<li><p>采用下一跳地址的方式配置 PC2 的静态路由，ping 之前和 ping 之后的 ARP 表如下所示：</p>
<p>  <img src="https://i.loli.net/2021/11/14/Xel1FdIGt27cf3i.png" alt="image-20211114173722522"></p>
</li>
<li><p>对比丢包情况</p>
<ul>
<li><p>转发接口方式：</p>
<p>  <img src="https://i.loli.net/2021/11/23/agobQmnJDq9zHPp.png" alt="image-20211114173933892" style="zoom:80%;"></p>
</li>
<li><p>下一跳地址方式：</p>
<p>  <img src="https://i.loli.net/2021/11/14/wAKTZLoChqEsBSy.png" alt="image-20211114173901166" style="zoom:80%;"></p>
</li>
<li><p>可见，转发接口方式由于每次都要进行解析，每次都可能发生丢包，而下一跳地址方式则不会产生丢包</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>对照所截获的消息，说明 OSPF 协议和 RIP 协议在邻居发现和数据库同步等部分中消息传递方式和消息内容上的差异。附截图和对消息的说明。</strong></p>
<p>  见 1.3 中对 OSPF 和 RIP 工作过程的分析</p>
</li>
</ul>
<h1 id="相关知识复习"><span class="post-title-index">2 </span><a href="#相关知识复习" class="headerlink" title="相关知识复习"></a>相关知识复习</h1><h2 id="路由协议"><span class="post-title-index">2.1 </span><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><ul>
<li>内部网关协议（IGP）：RIP、OSPF、IS-IS等</li>
<li>外部网关协议（EGP）：BGP</li>
</ul>
<h2 id="自治系统"><span class="post-title-index">2.2 </span><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h2><ul>
<li>一个自治系统是指由若干个二层网络及若干台路由器组成的集合，集合中的这些网络及路由器均属于同一个管理机构<ul>
<li>根据规模大小的不同，一个internet可能只包含一个自治系统，也可能包含多个自治系统</li>
</ul>
</li>
<li>通常情况下，一个自治系统中的所有路由器需要运行<strong>同一种</strong>具体的、由该自治系统的管理机构指定的 <strong>IGP协议</strong>（有时也会运行不同的IGP协议）</li>
<li>IGP协议在自治系统中应该达到的目的：使自治系统中的每一台路由器都能发现通往本自治系统内各个目的网络的路由</li>
</ul>
<h2 id="RIP（Router-Information-Protocol）"><span class="post-title-index">2.3 </span><a href="#RIP（Router-Information-Protocol）" class="headerlink" title="RIP（Router Information Protocol）"></a>RIP（Router Information Protocol）</h2><p><a href="https://blog.csdn.net/qq_42248536/article/details/89319915">RIP协议-CSDN博客</a></p>
<h3 id="基本概念"><span class="post-title-index">2.3.1 </span><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>RIP是一种基于<strong>距离矢量（DV）算法</strong>的内部网关协议（IGP）</li>
<li>RIP协议以<strong>跳数</strong>来定义路由的开销<ul>
<li>跳数：到达目的地所需要经过的路由器的个数</li>
<li>协议规定，$跳数≥16$ 的路由将被看成是<strong>不可达</strong>的路由，这限制了该协议只能应用在规模较小的网络中</li>
</ul>
</li>
</ul>
<ul>
<li>RIP路由器除了拥有IP路由表外，还要单独创建并维护一个<strong>RIP路由表</strong>，该路由表是专门来存放该路由器通过运行RIP协议而发现的路由</li>
</ul>
<h3 id="路由交换过程"><span class="post-title-index">2.3.2 </span><a href="#路由交换过程" class="headerlink" title="路由交换过程"></a>路由交换过程</h3><ul>
<li><p>初态的路由表只包含该路由器自动发现的<strong>直连路由</strong></p>
</li>
<li><p><strong>RIP请求消息</strong>：在RIP路由器开始启动之后，立即向它的所有的 <code>邻居路由器</code> 发送RIP请求消息，以便快速获得关于整个RIP网络的路由信息；运行中的RIP路由器也可以随时的根据自身的需要向它的所有的邻居发出RIP请求消息</p>
</li>
<li><strong>RIP响应消息</strong>：RIP路由器在接收到RIP请求消息后，会立即发出RIP响应消息进行回应。RIP路由器总是会每隔 <code>30秒</code> 的时间向它的所有的邻居路由器周期性的发送RIP响应消息，而该消息中携带了该路由器的RIP路由表中的最新的路由信息</li>
<li>经过一段时间的信息交换，路由表达到<strong>稳定状态</strong>，每台路由器的RIP路由表都包含了该路由器去往整个RIP网络的各个目的网络的路由信息</li>
<li>在稳定的状态下，路由交换过程是仍然会进行的。当网络的结构发生变化后，<strong>稳定状态被打破时</strong>，随着路由交换过程的进行，经过足够长的时间之后，每台路由器的RIP路由表便又会达到新的稳定状态。</li>
</ul>
<h3 id="路由环路问题及解决方法"><span class="post-title-index">2.3.3 </span><a href="#路由环路问题及解决方法" class="headerlink" title="路由环路问题及解决方法"></a>路由环路问题及解决方法</h3><h4 id="问题描述"><span class="post-title-index">2.3.3.1 </span><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>当A路由器一侧的X网络发生故障，则A路由器收到故障信息，并把X网络设置为不可达，等待更新周期来通知相邻的B路由器。但是，如果相邻的B路由器的更新周期先来了，则A路由器讲从B路由器那学习了到达X网络的路由，就是错误路由，因为此时的X网络已经损坏，而A路由器却在自己的路由表内增加了一条经过B路由器到达X网络的路由。然后A路由器还会继续把该错误路由通告给B路由器，B路由器更新路由表，认为到达X网络须经过A路由，然后继续通知相邻的路由器，至此路由环路形成，<strong>A路由器认为经过B路由器可以到达X网络，而B则认为经过A路由器可以到达X网络</strong></p>
<h4 id="解决方法"><span class="post-title-index">2.3.3.2 </span><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul>
<li><strong>触发更新</strong><ul>
<li>当RIP路由表中的某些路由项的内容发生改变时，路由器应该<strong>立即</strong>向它的所有邻居<strong>发布响应消息</strong>，并不是等待更新定时器所规定的下一个响应消息的发送时刻</li>
<li>为了减少带宽和路由器处理资源的浪费，触发更新的响应消息中只需要包含路由消息发生改变了的路由项</li>
</ul>
</li>
<li><strong>水平分割</strong><ul>
<li>一个路由器通过 A 接口学习到路由信息 x/y，当该路由器通过 A 接口向外发送响应消息时，<strong>一定不能包含</strong> x/y 这个路由项的信息</li>
</ul>
</li>
<li><strong>毒性逆转</strong><ul>
<li>一个路由器通过 A 接口学习到路由信息 x/y，当该路由器通过 A 接口向外发送响应消息时，<strong>需要包含</strong> x/y 这个路由项的信息，但是这个路由信息的 <strong>cost 设置为 16</strong>（不可达状态）</li>
</ul>
</li>
</ul>
<blockquote>
<p>毒性逆转和水平分割方法都可以避免产生路由环路，但是两者是<code>互斥的</code>。RIP路由器可以具备水平分割的功能或毒性逆转功能，但是不能同时具备两个功能。</p>
</blockquote>
<h2 id="OSPF（Open-Shortest-Path-First）协议"><span class="post-title-index">2.4 </span><a href="#OSPF（Open-Shortest-Path-First）协议" class="headerlink" title="OSPF（Open Shortest Path First）协议"></a>OSPF（Open Shortest Path First）协议</h2><p><a href="https://www.jianshu.com/p/619cfa3d513a">OSPF协议详解</a> —— 讲的很清楚，不再赘述</p>
]]></content>
      <categories>
        <category>专业</category>
        <category>专业课程</category>
        <category>计算机网络</category>
        <category>计算机网络技术实践</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>计算机网络</tag>
        <tag>Dynamips</tag>
      </tags>
  </entry>
  <entry>
    <title>VLAN 的配置实验</title>
    <url>/2021/12/01/VLAN%20%E7%9A%84%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>BUPT 计算机网络技术实践实验 4——VLAN的配置<span id="more"></span></p>
<h1 id="计算机网络技术实践实验-4——VLAN的配置"><span class="post-title-index">1 </span><a href="#计算机网络技术实践实验-4——VLAN的配置" class="headerlink" title="计算机网络技术实践实验 4——VLAN的配置"></a>计算机网络技术实践实验 4——VLAN的配置</h1><h2 id="环境"><span class="post-title-index">1.1 </span><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul>
<li>操作系统：Windows 10</li>
<li>网络平台：GNS3 &amp; VMWare Workstation 16 Player</li>
<li>网络拓扑图：每部分的链路开启状态不同，详见每部分的报告</li>
</ul>
<h2 id="实验目的"><span class="post-title-index">1.2 </span><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><ul>
<li>设计网络拓扑和逻辑网段，熟悉 VLAN 的基本配置方法，理解 VLAN 的作用</li>
<li>熟悉 trunk 链路的配置方法及作用</li>
<li>熟悉不同 VLAN 互联的配置方法</li>
</ul>
<h2 id="实验内容及步骤"><span class="post-title-index">1.3 </span><a href="#实验内容及步骤" class="headerlink" title="实验内容及步骤"></a>实验内容及步骤</h2><h3 id="第一部分：VLAN-的基本配置以及-VLAN-的作用"><span class="post-title-index">1.3.1 </span><a href="#第一部分：VLAN-的基本配置以及-VLAN-的作用" class="headerlink" title="第一部分：VLAN 的基本配置以及 VLAN 的作用"></a>第一部分：VLAN 的基本配置以及 VLAN 的作用</h3><h4 id="网络拓扑图"><span class="post-title-index">1.3.1.1 </span><a href="#网络拓扑图" class="headerlink" title="网络拓扑图"></a>网络拓扑图</h4><p><img src="https://i.loli.net/2021/12/01/FoHWy42CGKtsdrl.png" alt="image-20211201005428224"></p>
<h4 id="配置-IP-地址"><span class="post-title-index">1.3.1.2 </span><a href="#配置-IP-地址" class="headerlink" title="配置 IP 地址"></a>配置 IP 地址</h4><p><img src="https://i.loli.net/2021/11/30/Sw9LaHAcMiDVUPv.png" alt="image-20211130214521246" style="zoom:150%;"></p>
<p><img src="https://i.loli.net/2021/11/30/4ce3aNFAfixQGT8.png" alt="image-20211130214604667" style="zoom:150%;"></p>
<h4 id="VLAN-的配置和激活"><span class="post-title-index">1.3.1.3 </span><a href="#VLAN-的配置和激活" class="headerlink" title="VLAN 的配置和激活"></a>VLAN 的配置和激活</h4><ul>
<li><p><strong>添加 VLAN 2 和 VLAN 3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/hdZp823qRn9oKMP.png" alt="image-20211130172635632" style="zoom:150%;"></p>
</li>
<li><p><strong>激活 VLAN</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/X6hR48uBESk2txV.png" alt="image-20211130172830499" style="zoom:150%;"></p>
</li>
<li><p><strong>为 SW1 的两个接口配置 VLAN</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/sRqHj3ZJcWAtVki.png" alt="image-20211130172940102" style="zoom:150%;"></p>
<p>  <img src="https://i.loli.net/2021/12/01/Y259mXOzTfcevRD.png" alt="image-20211130173105598" style="zoom:150%;"></p>
</li>
</ul>
<h4 id="观察与分析"><span class="post-title-index">1.3.1.4 </span><a href="#观察与分析" class="headerlink" title="观察与分析  "></a>观察与分析 <span id="1.3.1.4"> </span></h4><ul>
<li><p><strong>从 PC1 ping PC2，不通，可见不同的 VLAN 被分隔开</strong></p>
<p>  <img src="https://i.loli.net/2021/12/01/uniwOaIhoEZVtCk.png" alt="image-20211130180606740" style="zoom:150%;"></p>
</li>
<li><p><strong>修改 f1/12 的 VLAN 为 VLAN2，与 f1/11 相同</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/ZyLNJDqfmKu4F3B.png" alt="image-20211130180754735" style="zoom:150%;"></p>
</li>
<li><p><strong>再次从 PC1 ping PC2，成功，可见相同的 VLAN 间可以正常交换数据</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/bC85BsUVeMnxFmA.png" alt="image-20211130180831255" style="zoom:150%;"></p>
</li>
</ul>
<h3 id="第二部分：trunk-链路的配置"><span class="post-title-index">1.3.2 </span><a href="#第二部分：trunk-链路的配置" class="headerlink" title="第二部分：trunk 链路的配置"></a>第二部分：trunk 链路的配置</h3><h4 id="网络拓扑图-1"><span class="post-title-index">1.3.2.1 </span><a href="#网络拓扑图-1" class="headerlink" title="网络拓扑图"></a>网络拓扑图</h4><p><img src="https://i.loli.net/2021/11/30/MSm1nev7EyzOr6p.png" alt="image-20211130220919901"></p>
<h4 id="配置-PC3-的-IP-地址"><span class="post-title-index">1.3.2.2 </span><a href="#配置-PC3-的-IP-地址" class="headerlink" title="配置 PC3 的 IP 地址"></a>配置 PC3 的 IP 地址</h4><p><img src="https://i.loli.net/2021/11/30/gxGUyKNShfEz76c.png" alt="image-20211130215301628" style="zoom:150%;"></p>
<h4 id="配置-SW2-的-VLAN"><span class="post-title-index">1.3.2.3 </span><a href="#配置-SW2-的-VLAN" class="headerlink" title="配置 SW2 的 VLAN"></a>配置 SW2 的 VLAN</h4><ul>
<li><p><strong>创建 VLAN2 和 VLAN3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/Lg4vc3SDFNuKIla.png" alt="image-20211130202604078" style="zoom:150%;"></p>
</li>
<li><p><strong>激活 VLAN2 和 VLAN3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/k9daPFz4vIyHjoe.png" alt="image-20211130202749879" style="zoom:150%;"></p>
</li>
<li><p><strong>为接口 f1/11 分配 VLAN</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/8GWOMrClewz9Jmo.png" alt="QQ截图20211130203046" style="zoom:150%;"></p>
</li>
</ul>
<h4 id="观察与分析-1"><span class="post-title-index">1.3.2.4 </span><a href="#观察与分析-1" class="headerlink" title="观察与分析  "></a>观察与分析 <span id="1.3.2.4"> </span></h4><ul>
<li><p><strong>从 PC1 ping PC3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/8GBOJtmoHgD9lvN.png" alt="image-20211130215532467" style="zoom:150%;"></p>
</li>
<li><p><strong>修改 SW1 和 SW2 之间的链路为 trunk 模式</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/Uj5sNIpLlfXRqZw.png" alt="image-20211130215703439" style="zoom:150%;"></p>
<p>  <img src="https://i.loli.net/2021/11/30/WZ4laGEHLRdN6zO.png" alt="image-20211130215754395" style="zoom:150%;"></p>
</li>
<li><p><strong>再次从 PC1 ping PC3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/DQ1AkeTyP3nFfcu.png" alt="image-20211130215834684" style="zoom:150%;"></p>
</li>
</ul>
<h3 id="第三部分：不同-VLAN-互联"><span class="post-title-index">1.3.3 </span><a href="#第三部分：不同-VLAN-互联" class="headerlink" title="第三部分：不同 VLAN 互联"></a>第三部分：不同 VLAN 互联</h3><h4 id="网络拓扑图-2"><span class="post-title-index">1.3.3.1 </span><a href="#网络拓扑图-2" class="headerlink" title="网络拓扑图"></a>网络拓扑图</h4><p><img src="https://i.loli.net/2021/11/30/kjWziMT97bufHn6.png" alt="image-20211130222611096"></p>
<h4 id="配置-IP-地址-1"><span class="post-title-index">1.3.3.2 </span><a href="#配置-IP-地址-1" class="headerlink" title="配置 IP 地址"></a>配置 IP 地址</h4><ul>
<li><p><strong>Router</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/HXaTVUQv5ZeA2hD.png" alt="image-20211130221526011" style="zoom:150%;"></p>
<p>  <img src="https://i.loli.net/2021/12/01/qezvHt5bwoNcKBC.png" alt="image-20211130221625273" style="zoom:150%;"></p>
</li>
<li><p><strong>PC3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/pxuUs2H9NtzI8oE.png" alt="image-20211130221806501" style="zoom:150%;"></p>
</li>
</ul>
<h4 id="配置路由协议（RIP）"><span class="post-title-index">1.3.3.3 </span><a href="#配置路由协议（RIP）" class="headerlink" title="配置路由协议（RIP）"></a>配置路由协议（RIP）</h4><ul>
<li><p><strong>PC1</strong></p>
<p>  <img src="https://i.loli.net/2021/12/01/hOnk8szd4fXuebi.png" style="zoom:150%;"></p>
</li>
<li><p><strong>PC2</strong></p>
<p>  <img src="https://i.loli.net/2021/12/01/jrITxVwtJymQ3PZ.png" alt="image-20211130230816855" style="zoom:150%;"></p>
</li>
<li><p><strong>PC3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/i2dKznlMHx6TwCk.png" alt="image-20211130231009881" style="zoom:150%;"></p>
</li>
<li><p><strong>Router</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/bEclVu6GJvDxenz.png" alt="image-20211130230123884" style="zoom:150%;"></p>
<p>  <img src="https://i.loli.net/2021/11/30/l8wunzIsi9Okp3q.png" alt="image-20211130231130844" style="zoom:150%;"></p>
</li>
</ul>
<h4 id="配置-VLAN"><span class="post-title-index">1.3.3.4 </span><a href="#配置-VLAN" class="headerlink" title="配置 VLAN"></a>配置 VLAN</h4><ul>
<li><p><strong>SW1 的 f1/2 接口</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/6HPDdiTqIsUmMbu.png" alt="image-20211130222247281" style="zoom:150%;"></p>
</li>
<li><p><strong>SW2 的 f1/1 接口</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/73jrXhMCfB65DnV.png" alt="image-20211130222354160" style="zoom:150%;"></p>
</li>
<li><p><strong>SW2 的 f1/11 接口</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/B2AfSiyocn4LaTC.png" alt="image-20211130222515157" style="zoom:150%;"></p>
</li>
</ul>
<h4 id="检查是否连通"><span class="post-title-index">1.3.3.5 </span><a href="#检查是否连通" class="headerlink" title="检查是否连通  "></a>检查是否连通 <span id="1.3.3.5"> </span></h4><ul>
<li><p><strong>Router ping PC3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/HsyrWBRfDwkmux1.png" alt="image-20211130222743074" style="zoom:150%;"></p>
</li>
<li><p><strong>PC1 ping Router</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/prwvSg1ioJyjMHf.png" alt="image-20211130225440346" style="zoom:150%;"></p>
<p>  <img src="https://i.loli.net/2021/11/30/N3LZFBsxH4eU7cX.png" alt="image-20211130230211378" style="zoom:150%;"></p>
</li>
<li><p><strong>PC1 ping PC3</strong></p>
<p>  <img src="https://i.loli.net/2021/12/01/UQWcFlbIToHR4tq.png" alt="image-20211130231239182" style="zoom:150%;"></p>
</li>
<li><p><strong>PC3 ping PC2</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/Zd1W8lIgjQ79mXu.png" alt="image-20211130231301491" style="zoom:150%;"></p>
</li>
</ul>
<h2 id="实验结果"><span class="post-title-index">1.4 </span><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><h3 id="连通性"><span class="post-title-index">1.4.1 </span><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><p>参见 <a href="#1.3.1.4">第一部分-4.</a>、<a href="1.3.2.4">第二部分-4.</a>、<a href="1.3.3.5">第三部分-5.</a> </p>
<h3 id="路由表"><span class="post-title-index">1.4.2 </span><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h3><ul>
<li><p><strong>PC1</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/z1bCVK64Foa8rYc.png" alt="image-20211130231928057" style="zoom:150%;"></p>
</li>
<li><p><strong>PC2</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/cfnX2vErkxy8Bs5.png" alt="image-20211130232233355" style="zoom:150%;"></p>
</li>
<li><p><strong>PC3</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/pvAcRhtP3yk7TH4.png" alt="image-20211130232249883" style="zoom:150%;"></p>
</li>
<li><p><strong>Router</strong></p>
<p>  <img src="https://i.loli.net/2021/11/30/ziTRVKnLxBDd32O.png" alt="image-20211130232304677" style="zoom:150%;"></p>
</li>
</ul>
<h2 id="实验中的问题及心得"><span class="post-title-index">1.5 </span><a href="#实验中的问题及心得" class="headerlink" title="实验中的问题及心得"></a>实验中的问题及心得</h2><p><strong>1. 使用 GNS3 遇到了虚拟机无法连接的问题</strong></p>
<p>问题具体表现为在 GNS3 中 VM 前是灰色的，也没有相应的 CPU 资源显示。经过查找资料，了解到 windows 存在一个奇怪的问题——只要电脑休眠，主机就会 ping 不通虚拟机，只能重启网卡。于是我尝试了重启网卡并重启 GNS3，解决了问题。</p>
<h2 id="实验思考"><span class="post-title-index">1.6 </span><a href="#实验思考" class="headerlink" title="实验思考"></a>实验思考</h2><p><strong>1. 如何在同一个局域网中，配置两个 IP 网段</strong></p>
<p>根据前几次实验的知识，可总结出以下几种方法：</p>
<ul>
<li><p>如本次实验，使用<code>交换机以及 VLAN 技术</code></p>
</li>
<li><p>使用<code>路由器</code>进行连接，添加静态路由或使用路由协议（实验2、实验3），如下所示：</p>
<p>  <img src="https://i.loli.net/2021/11/30/PlatujOx8reqR4p.png" alt="image-20211130234413418" style="zoom: 50%;"></p>
<p>  <img src="https://i.loli.net/2021/12/01/COneurAjH2tlqsS.png" alt="image-20211130234436406" style="zoom: 50%;"></p>
</li>
</ul>
<p><strong>2. 选择两个不同 VLAN 中的 PC 机，中间要经过 trunk 链路连接的路由器，阐述互相 ping 时的完整传输流程。（包括交换机和路由器的简单处理过程，并且要指出 VLAN 标签的变化）</strong></p>
<p>以下图中 PC1 和 PC3 为例：</p>
<p><img src="https://i.loli.net/2021/12/01/bA3YepojltkIrsD.png" style="zoom: 50%;"></p>
<ul>
<li><p>PC1 发出报文，到达交换机 SW1，SW1 打上端口的 VID（即 <strong>VLAN 2</strong>），并进行交换转发</p>
</li>
<li><p>接着，SW1 的 f1/12、f1/1、f1/2 端口均准备好发送报文</p>
<ul>
<li>f1/12 端口的 VLAN 为 3，不符合，丢弃</li>
<li>f1/1 为 trunk 端口，将会携带原有的 VLAN 标记转发</li>
<li>f1/2 为 trunk 端口，且路由器的左端口也在 VLAN 2 内，报文携带的 VLAN 2 信息被剥离，变成了标准帧发出</li>
</ul>
</li>
<li><p>之后，SW2 的 f1/2 端口、路由器的左端口均会收到 <strong>VLAN 2</strong> 发来的数据包</p>
<ul>
<li>SW2 的 f1/2 端口为 trunk 端口，它检查这一报文是否有 VLAN 信息，显然是有，为 VLAN 2，于是判断是否允许 VLAN 2 的数据进入，由于我们设置了 trunk 端口允许所有 VLAN 的交换，所以数据包进入 SW2 进行转发交换。数据包在 SW2 内到达了 f1/1 端口和 f1/11 端口，由于 VLAN 都不吻合，因此被丢弃</li>
<li>路由器收到已经剥离了 tag 的帧，拆除其以太网封装，查找路由表后送到右端口，右端口重新封装为标准以太网帧发出</li>
</ul>
</li>
<li><p>SW2 的 f1/1 端口收到了路由器右端口发来的以太网标准帧，并检查出没有 VLAN 信息，于是打上 tag，标记 VID 为 <strong>VLAN 1</strong>，并转发给 f1/11 端口，f1/11 端口检测到自己端口的 VID 和 报文的 VID 吻合，剥离 tag 并转发，最终到达了 PC3 。</p>
</li>
</ul>
<p><strong>3. 阐述 VLAN 、物理网络及 IP 网段的关系</strong></p>
<ul>
<li>物理网络顾名思义，是物理层的概念；VLAN 是一个二层概念；网段是一个第三层概念，一般一个路由器接口对应着一个网段。</li>
<li>VLAN 通过配置交换机接口来限制包的转发，是从数据链路层对物理层进行了限制，提高了网络性能。路由器又可以实现对不同 VLAN 的互联，是从网络层对数据链路层进行了改善。综合起来形成了高性能、易使用的网络结构。</li>
</ul>
<h1 id="相关知识复习整理"><span class="post-title-index">2 </span><a href="#相关知识复习整理" class="headerlink" title="相关知识复习整理"></a>相关知识复习整理</h1><h2 id="VLAN"><span class="post-title-index">2.1 </span><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><h3 id="VLAN-的实现方法"><span class="post-title-index">2.1.1 </span><a href="#VLAN-的实现方法" class="headerlink" title="VLAN 的实现方法"></a>VLAN 的实现方法</h3><ul>
<li>基于端口的虚拟局域网（建立在物理层上）</li>
<li>基于MAC地址的虚拟局域网（建立在数据链路层上）</li>
<li><strong>基于IP地址的虚拟局域网（建立在网络层上）</strong> <strong><font color="blue">【本次实验使用的方法】</font></strong></li>
<li>根据IP组播划分VLAN（建立在网络层上）</li>
<li>基于规则的VLAN</li>
</ul>
<h3 id="VLAN-Trunk"><span class="post-title-index">2.1.2 </span><a href="#VLAN-Trunk" class="headerlink" title="VLAN Trunk"></a>VLAN Trunk</h3><h4 id="问题引入"><span class="post-title-index">2.1.2.1 </span><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><blockquote>
<p>如果两台交换机都有同一VLAN的计算机，怎么办呢？我们可以通过VLAN Trunk来解决。 </p>
</blockquote>
<p>如果交换机 1 的 VLAN1 中的机器要访问交换机 2 的 VLAN1 中的机器，我们可以把两台交换机的级联端口设置为  <code>Trunk 端口</code>，这样，当交换机把数据包从级联口发出去的时候，会在数据包中做一个标记（<code>TAG</code>），以使其它交换机识别该数据包属于哪一个 VLAN，这样，其它交换机收到这样一个数据包后，只会将该数据包转发到标记中指定的 VLAN，从而完成了跨越交换机的 VLAN 内部数据传输。</p>
<h4 id="VLAN-Trunk-目前的两种标准"><span class="post-title-index">2.1.2.2 </span><a href="#VLAN-Trunk-目前的两种标准" class="headerlink" title="VLAN Trunk 目前的两种标准"></a>VLAN Trunk 目前的两种标准</h4><p><code>ISL</code> 和 <code>802.1q</code>，前者是 Cisco 专有技术，后者则是 IEEE 的国际标准，除了 Cisco 两者都支持外，其它厂商都只支持后者。</p>
<h2 id="参考资料"><span class="post-title-index">2.2 </span><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://zhuanlan.zhihu.com/p/137368250">网络工程师（17）：用路由器让VLAN之间互通 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.cnblogs.com/sunada2005/articles/2666902.html">VLAN是什么？如何划分VLAN？如何实现VLAN？VLAN有什么好处？ VLAN可能用到的三层交换技术</a></p>
]]></content>
      <categories>
        <category>专业</category>
        <category>专业课程</category>
        <category>计算机网络</category>
        <category>计算机网络技术实践</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
        <tag>计算机网络</tag>
        <tag>GNS3</tag>
      </tags>
  </entry>
</search>
