<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>thatmee&#39;s blog</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="http://thatmee.github.io/atom.xml" rel="self"/>
  
  <link href="http://thatmee.github.io/"/>
  <updated>2021-09-18T08:44:56.445Z</updated>
  <id>http://thatmee.github.io/</id>
  
  <author>
    <name>thatmee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>修改HEXO博客Next主题的文章显示样式</title>
    <link href="http://thatmee.github.io/2021/09/17/%E4%BF%AE%E6%94%B9HEXO%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E7%9A%84%E6%96%87%E7%AB%A0%E6%98%BE%E7%A4%BA%E6%A0%B7%E5%BC%8F/"/>
    <id>http://thatmee.github.io/2021/09/17/%E4%BF%AE%E6%94%B9HEXO%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E7%9A%84%E6%96%87%E7%AB%A0%E6%98%BE%E7%A4%BA%E6%A0%B7%E5%BC%8F/</id>
    <published>2021-09-17T09:47:00.000Z</published>
    <updated>2021-09-18T08:44:56.445Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习HTML和CSS，看着看着突然想起Typora的code样式很丑，网页显示出来的code、链接也是默认灰色，感觉可以试着改改样式文件练练手了！<span id="more"></span></p><h1 id="修改成果展示"><span class="post-title-index">1 </span><a href="#修改成果展示" class="headerlink" title="修改成果展示"></a>修改成果展示</h1><ol><li><p><strong>code样式</strong></p><p> <img src="https://i.loli.net/2021/09/17/has7YM5AlGQU21V.png" alt="image-20210917155251885"></p> <center>↓</center><p> <img src="https://i.loli.net/2021/09/17/43wo7QaYVjzTy8B.png" alt="image-20210917155948308"></p></li><li><p><strong>链接颜色</strong></p><p> <img src="https://i.loli.net/2021/09/17/bkwrqh1mHzJ3GIp.png" alt="image-20210917155754569"></p> <center>↓</center><p> <img src="https://i.loli.net/2021/09/17/526ySHsYreEuvnN.png" alt="image-20210917160013391"></p><blockquote><p>对比一下，原来灰色的链接，如果不是用红圈框出来，恐怕一时都看不太出这是个链接（除了下面的横线提示），非常不醒目，换了一个颜色后就好多啦。</p></blockquote></li><li><p><strong>有序列表的序号加粗</strong></p><p> <img src="https://i.loli.net/2021/09/17/gv5jxd4cFAezSJM.png" alt="image-20210917160405758"></p> <center>↓</center><p> <img src="https://i.loli.net/2021/09/17/1zAfpLkvK46YrFJ.png" alt="image-20210917160425586"></p><blockquote><p>这个对比可能不是很明显，但从整体的角度来看是很明显的，旧的那一种就<del>好像健身练胳膊不练腿</del>不太协调的亚子。</p></blockquote></li></ol><h1 id="具体操作方法"><span class="post-title-index">2 </span><a href="#具体操作方法" class="headerlink" title="具体操作方法"></a>具体操作方法</h1><h2 id="浏览器查看博客，确定要修改元素的信息"><span class="post-title-index">2.1 </span><a href="#浏览器查看博客，确定要修改元素的信息" class="headerlink" title="浏览器查看博客，确定要修改元素的信息"></a>浏览器查看博客，确定要修改元素的信息</h2><p>在博客界面按 <strong>F12</strong> 打开调试</p><p><img src="https://i.loli.net/2021/09/17/qTyKHi1cdNL4XrE.png" alt="image-20210917163008636"></p><p>使用调试器内元素选择器选择想要修改样式的部位：</p><p><img src="https://i.loli.net/2021/09/17/3DJ1XEcf2u8mGiz.png" alt="image-20210917163159647"></p><p>点击后发现调试器的“元素”窗口已经定位到了这个元素对应的HTML代码</p><p><img src="https://i.loli.net/2021/09/17/3cRFVz1XoCgakSv.png" alt="image-20210917163303191"></p><p>上下左右找找看，发现这个元素处在一个div块中，div块的类是 <code>post-body animated fadeInDown</code> </p><p><img src="https://i.loli.net/2021/09/17/cn4CvTPISyfFwLR.png" alt="image-20210917163704354"></p><p>下一步来找相应的文件或者模块。</p><h2 id="探索next主题文件结构"><span class="post-title-index">2.2 </span><a href="#探索next主题文件结构" class="headerlink" title="探索next主题文件结构"></a>探索next主题文件结构</h2><p><img src="https://i.loli.net/2021/09/17/yJxUT9SBac6vg8l.png" alt="image-20210917161357712"></p><p>这个文件夹应该很眼熟，里面的source文件夹存放着我们的博客文章。而<code>themes</code>文件夹顾名思义就是主题相关的一些文件，进入themes文件夹，选择<code>next</code>文件夹，就看到了next主题所有文件：</p><p><img src="https://i.loli.net/2021/09/17/65JOo3v8F9bxUui.png" alt="image-20210917161721177"></p><p>各个文件夹点开看看，有没有我们要找的CSS文件……一番查找后，在<code>source</code>文件夹下看到了一些熟悉的东西：</p><p><img src="https://i.loli.net/2021/09/17/DI9oVpEw2sg5kLy.png" alt="image-20210917161927486"></p><p>点进CSS看看……发现一堆子文件夹，还有几个styl文件，这是个什么东西？预想中的CSS呢？</p><p><img src="https://i.loli.net/2021/09/18/ZpL8CmU7gRl34kG.png" alt="image-20210917164003072"></p><p>管他三七二十一先点开<code>main.style</code>看看，什么情况，一堆import，再仔细一看，哦！这import的内容和子文件夹是对应的啊，那这个基本的调用结构就可以理解了，从<code>main.styl</code>一级一级往下调用，保证了模块化和解耦，也方便找到对应的模块。</p><p><img src="https://i.loli.net/2021/09/17/wxdaev2Nc61X4C9.png" alt="image-20210917164303867"></p><p>继续如上探索，最终在 <code>css\_common\components\post</code>下找到了一个叫做<code>post-body.styl</code>的文件，与之前看到的类名的前半部分重合，很可能就是你了！今天的主人公！激动的点进去看看！看起来和刚学的CSS语法差不多嘛，下一步就来改改试试。</p><h2 id="修改样式文件"><span class="post-title-index">2.3 </span><a href="#修改样式文件" class="headerlink" title="修改样式文件"></a>修改样式文件</h2><h3 id="code样式"><span class="post-title-index">2.3.1 </span><a href="#code样式" class="headerlink" title="code样式"></a>code样式</h3><p>在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//new</span></span><br><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f7e3e3</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#990000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Git-bash里面<code>hexo s</code>一下，观察网页有无变化</p><p><img src="https://i.loli.net/2021/09/17/6uhFwAjkM5iWE7x.png" alt="image-20210917165601055"></p><p>变了！！！激动激动，继续改链接样式。</p><h3 id="链接样式"><span class="post-title-index">2.3.2 </span><a href="#链接样式" class="headerlink" title="链接样式"></a>链接样式</h3><p>在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;      <span class="comment">/* 未访问链接*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;   <span class="comment">/* visited link */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;     <span class="comment">/* mouse over link */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;    <span class="comment">/* selected link */</span></span><br></pre></td></tr></table></figure><p>刷新网页，观察变化</p><p><img src="https://i.loli.net/2021/09/17/UAMIu2vDrfNZ7St.png" alt="image-20210917165850183"></p><p>也变化了！！CSS好简单！一学就会一用就对。</p><p>……但是但是但是，返回首页看一眼，我们就会发现问题，原先黑色的“read more”竟然也变成了绿色？！！！离谱啊，这不是个button吗！怎么和链接用一样的类啊！太诡异了这绿色，必须改回来！</p><p><img src="https://i.loli.net/2021/09/17/5UTMLESIrdgnNkG.png" alt="image-20210917170209366"></p><p>这个地方研究了不少时间，一开始觉得自己添加的链接样式的代码应该限定一个范围，像是下面这样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> <span class="selector-class">.post-body</span> <span class="selector-class">.animated</span> <span class="selector-class">.fadeInDown</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125; </span><br></pre></td></tr></table></figure><p>但这个行不通，样式并没有修改，直接变回了以前的默认灰色，隐约感觉是我写的格式不太合适，或者没找到合适的类名，经过各种浏览器调试、研究其他styl代码后，又尝试了下面这样：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.animated</span> <span class="selector-class">.fadeInDown</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;      <span class="comment">/* 未访问链接*/</span></span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;<span class="attribute">color</span>:<span class="number">#006600</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#006600</span>&#125;  <span class="comment">/* visited link */</span></span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;  <span class="comment">/* mouse over link */</span></span><br><span class="line">  <span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;<span class="attribute">color</span>:<span class="number">#009966</span>; <span class="attribute">text-decoration-color</span>:<span class="number">#009966</span>&#125;  <span class="comment">/* selected link */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而还是不太行，于是转变思路打算在此基础上修改button的颜色，改为默认值。在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.btn</span> &#123;</span><br><span class="line"> <span class="attribute">color</span>: var(--btn-default-color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新一看，诶！好了！嗯嗯嗯嗯真不错我可真<del>是个天才</del>棒！还是这个看着舒服</p><p><img src="https://i.loli.net/2021/09/17/vVOba3cT9QjrtIA.png" alt="image-20210917171746877"></p><p><strong>【tips】之前也在网上查过修改的方法，好像是直接改了个变量，这个行不通啊真的行不通，结果就是各种能点的地方，颜色全变了……就很离谱。</strong></p><h3 id="修改有序列表序号粗细"><span class="post-title-index">2.3.3 </span><a href="#修改有序列表序号粗细" class="headerlink" title="修改有序列表序号粗细"></a>修改有序列表序号粗细</h3><p>利用浏览器调试工具找到这个元素的名字，<code>::marker</code> 没听过的东西，搜索发现修改方法和其他元素一样</p><p><img src="https://i.loli.net/2021/09/17/AVdLNPuZTOxGis1.png" alt="image-20210917172100373"></p><p>那就果断下手，在<code>post-body.styl</code>文件中的 <code>.post-body</code> 块内增加如下内容，保存</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">::marker</span> &#123;</span><br><span class="line"> <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新看看！</p><p><img src="https://i.loli.net/2021/09/17/uEyXohwzPHUMcns.png" alt="image-20210917172412696"></p><p>嗯！序号部分和文字部分已经粗细一致啦！（Typora 编辑器的显示也可以一样修改）</p><h1 id="相关知识参考"><span class="post-title-index">3 </span><a href="#相关知识参考" class="headerlink" title="相关知识参考"></a>相关知识参考</h1><p><a href="https://www.w3cschool.cn/css/css-grouping-nesting.html">CSS 分组和嵌套 w3cschool</a></p><p><a href="https://www.w3cschool.cn/css/css-combinators.html">CSS 组合选择符 w3cschool</a></p><p><a href="https://www.w3cschool.cn/css/css-pseudo-classes.html">CSS 伪类_w3cschool</a></p><p><a href="https://www.w3cschool.cn/css/css-attribute-selectors.html">CSS 属性选择器_w3cschool</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在学习HTML和CSS，看着看着突然想起Typora的code样式很丑，网页显示出来的code、链接也是默认灰色，感觉可以试着改改样式文件练练手了！&lt;/p&gt;</summary>
    
    
    
    <category term="专业" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="前端开发学习" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CSS" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/CSS/"/>
    
    
    <category term="前端开发" scheme="http://thatmee.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="CSS" scheme="http://thatmee.github.io/tags/CSS/"/>
    
    <category term="HEXO" scheme="http://thatmee.github.io/tags/HEXO/"/>
    
    <category term="HEXO-Next主题" scheme="http://thatmee.github.io/tags/HEXO-Next%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>安装face_recognition中遇到的坑</title>
    <link href="http://thatmee.github.io/2021/09/16/%E5%BF%83%E7%B4%AF%E4%B8%80%E6%99%9A/"/>
    <id>http://thatmee.github.io/2021/09/16/%E5%BF%83%E7%B4%AF%E4%B8%80%E6%99%9A/</id>
    <published>2021-09-15T17:47:00.000Z</published>
    <updated>2021-09-22T10:51:48.771Z</updated>
    
    <content type="html"><![CDATA[<p>打算跑一下人脸识别代码，结果在配环境上遭遇了滑铁卢… <span id="more"></span></p><h1 id="pip命令配置"><span class="post-title-index">1 </span><a href="#pip命令配置" class="headerlink" title="pip命令配置"></a>pip命令配置</h1><ol><li><p><strong><code>pip install --upgrade pip</code>失败之后pip命令失效的问题</strong></p><ul><li>需要使用<code>python -m ensurepip</code>才能让pip命令重新生效（感觉是—update失败但是删除了一些pip原本的文件，导致pip无法使用）</li><li><code>pip install --update --user pip</code>能够成功更新pip</li></ul></li><li><p><strong>pip命令在cmd中无效的问题</strong></p><ul><li>显然是没有添加环境变量</li><li>在添加Python的环境变量时，不仅要添加Python文件夹，还要添加Python/Scripts文件夹，pip.exe、pip3.exe以及其他一些可执行文件都在这个目录下</li></ul></li></ol><p><img src="https://i.loli.net/2021/09/16/EptvKmerGnN7dA4.png" alt="image-20210916101933581"></p><h1 id="face-recognition包的安装"><span class="post-title-index">2 </span><a href="#face-recognition包的安装" class="headerlink" title="face_recognition包的安装"></a>face_recognition包的安装</h1><h2 id="先安装Cmake"><span class="post-title-index">2.1 </span><a href="#先安装Cmake" class="headerlink" title="先安装Cmake"></a>先安装Cmake</h2><p><code>pip install cmake</code> 没有遇到什么问题</p><h2 id="安装dlib的坑"><span class="post-title-index">2.2 </span><a href="#安装dlib的坑" class="headerlink" title="安装dlib的坑"></a>安装dlib的坑</h2><ol><li><p><strong>找不到C_CXX_COMPILER的问题</strong></p><ul><li>由于使用 <code>pip install dlib</code> 命令时，中间文件都在C盘一个奇怪的目录中（xxx/Temp/xxx），猜测这个目录是临时目录，可能安装失败后就自动删除了，所以一直找不到详细错误报告</li><li>之后在尝试离线安装的时候，中间文件以及错误报告都在自己创建的文件夹中，于是查看详细错误报告，发现是VS的目录下一个<strong>CL.exe</strong>文件打开失败。退出360安全卫士后解决。（可恶的360！）</li></ul></li><li><p><strong>subprocess.CalledProcessError: Command ‘[‘cmake’, ‘—build’, ‘.’, ‘—config’, ‘Release’, ‘—‘, ‘/m’]’ returned non-zero exit status 1.</strong></p><ul><li>退出360重新安装时出现这个报错。（在疯的边缘了）</li><li>遍寻伟大的互联网，找到如下解决方法：<a href="https://blog.csdn.net/jiang7121250/article/details/118570570">(5条消息) Windows 安装Dlib出现的问题_jiang7121250的博客-CSDN博客</a></li><li>不再报上面的错了，但装完使用pipshow还是找不到（猜测是安装路径的问题，但是把文件拷贝过去还是找不到，直接在依赖包的路径下面安装也不行，所以又尝试了安装dlib.whl文件，见下）</li></ul></li><li><p><strong>尝试安装dlib的whl文件，报错：平台不支持</strong></p><ul><li><p>了解到cp36代表支持Cpython3.6，于是conda一个新环境试试</p><p><img src="https://i.loli.net/2021/09/16/5JQr6iEeM7vgdup.png" alt="image-20210916013350324"></p></li><li><p>中间卡住了（一直在solving environment），感觉也是由于环境或者版本的问题</p></li><li><p>再继续找方法，看到一个神奇的东西：<a href="https://www.cnblogs.com/chrystal/p/13580051.html">如何在win下安装dlib的whl文件（Anaconda方式） - 绛绛 - 博客园 (cnblogs.com)</a></p><p>  <img src="https://i.loli.net/2021/09/16/PEG3O6cShpJk4Fg.png" alt="image-20210916014337392"></p><p>  <img src="https://i.loli.net/2021/09/16/Y4tmPyWduUz2j6G.png" alt="image-20210916014359229"></p></li><li><p><code>pip debug --verbose</code> 可以显示当前python支持的包格式，正好对应下载的dlib.whl文件名中一些看不懂的参数说明，于是按照合适的版本重命名，再次尝试</p></li><li><p>成功安装！！！激动的心颤抖的手，看看这张美丽的截图：</p><p>  <img src="https://i.loli.net/2021/09/16/2ZD6xN4v5YMdVCE.png" alt="image-20210916014459262"></p></li></ul></li></ol><ol><li><p><strong>这还没完，这里是第二天装完OpenCv开始跑代码的虾滑…编译器报错dlib的DLL缺失</strong></p><ul><li>猜测是由于修改文件名的骚操作导致安装出现问题，解决方法是重装dlib……好嘛从头开始，真的是吐了</li><li>这又告诉我们，<code>pip show XXX</code> 是无法检测包有没有安装好的。还是得用 <code>import</code>看看能不能正常使用。</li></ul></li><li><p><strong>踏上重装之旅，<code>pip install dlib --verbose</code> 报错：</strong><font color="blue"><strong>error C2734: “GifAsciiTable8x8”: 如果不是外部的，则必须初始化常量对象 (编译源文件 E:\APKS\dlib-19.14.0\too</strong></font></p><ul><li><p>找到一条看起来很正确的方法！<a href="https://blog.csdn.net/qq_30267617/article/details/119725917">(5条消息) win10安装dlib问题记录_何为其然的博客-CSDN博客</a></p></li><li><p>根据上述链接，安装方法和Python版本有很大关系，所以我卸载了已有Python，重装了Anaconda【<strong>见第3部分-Python和Anaconda环境配置</strong>】，之后选择Python3.6版本安装成功。</p></li></ul></li></ol><h2 id="开始安装face-recognition"><span class="post-title-index">2.3 </span><a href="#开始安装face-recognition" class="headerlink" title="开始安装face_recognition"></a>开始安装face_recognition</h2><p><img src="https://i.loli.net/2021/09/16/3BJDdmVGiKhSqoF.png" alt="image-20210916014627953"></p><p>非常顺利！！</p><h1 id="Python和Anaconda环境配置"><span class="post-title-index">3 </span><a href="#Python和Anaconda环境配置" class="headerlink" title="Python和Anaconda环境配置"></a>Python和Anaconda环境配置</h1><p>由于已经装了Python3.7 和Python3.8，又新下载了Anaconda，一时搞得有些混乱，于是决定把这俩东西整理一下。</p><p>参考：<a href="https://www.cnblogs.com/yamin/p/7111397.html">如何在已安装Python条件下，安装Anaconda,，并将原有Python添加到Anaconda中 - amazingym - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;打算跑一下人脸识别代码，结果在配环境上遭遇了滑铁卢…&lt;/p&gt;</summary>
    
    
    
    <category term="专业" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="环境配置" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Python相关" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Python%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="Python" scheme="http://thatmee.github.io/tags/Python/"/>
    
    <category term="pip" scheme="http://thatmee.github.io/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>Vue入门——环境搭建、Webpack、Vue框架了解</title>
    <link href="http://thatmee.github.io/2021/09/14/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Vue%E5%85%A5%E9%97%A8/"/>
    <id>http://thatmee.github.io/2021/09/14/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Vue%E5%85%A5%E9%97%A8/</id>
    <published>2021-09-14T12:52:20.000Z</published>
    <updated>2021-09-17T18:44:55.467Z</updated>
    
    <content type="html"><![CDATA[<p>配置Vue开发环境，了解Webpack、Node、Gulp以及Yoeman脚手架等知识。<span id="more"></span></p><h1 id="环境搭建及相关知识"><span class="post-title-index">1 </span><a href="#环境搭建及相关知识" class="headerlink" title="环境搭建及相关知识"></a>环境搭建及相关知识</h1><p><img src="https://i.loli.net/2021/09/14/zXxisYphAMkFOZQ.png" alt="image-20210909153940754" style="zoom: 33%;"></p><h2 id="Docker——容器化应用"><span class="post-title-index">1.1 </span><a href="#Docker——容器化应用" class="headerlink" title="Docker——容器化应用"></a>Docker——容器化应用</h2><p><img src="https://i.loli.net/2021/09/10/DGIFu1QCZi5NXqc.png" alt="image-20210910103612405" style="zoom: 33%;"></p><h2 id="node介绍"><span class="post-title-index">1.2 </span><a href="#node介绍" class="headerlink" title="node介绍"></a>node介绍</h2><p><img src="https://i.loli.net/2021/09/14/INndlBsMX23P9hx.png" alt="image-20210910112330203" style="zoom:33%;"></p><h1 id="前端工程化"><span class="post-title-index">2 </span><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h1><p><img src="https://i.loli.net/2021/09/11/LyDgEI6acVOG9xW.png" alt="image-20210911005012607" style="zoom: 50%;"></p><h2 id="前端工程化简介"><span class="post-title-index">2.1 </span><a href="#前端工程化简介" class="headerlink" title="前端工程化简介"></a>前端工程化简介</h2><p><img src="https://i.loli.net/2021/09/11/2scV9twbpxCeKfH.png" alt="image-20210911004535327" style="zoom:33%;"></p><h2 id="构建工具——Webpack"><span class="post-title-index">2.2 </span><a href="#构建工具——Webpack" class="headerlink" title="构建工具——Webpack"></a>构建工具——Webpack</h2><p><img src="https://i.loli.net/2021/09/11/Z6TnLlYkNpOxD3I.png" alt="image-20210911211642986"></p><h3 id="核心概念"><span class="post-title-index">2.2.1 </span><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong><a href="https://webpack.docschina.org/concepts/">概念 | webpack 中文文档 (docschina.org)</a></strong></p><p><strong>入口：</strong>指示 webpack 应该使用哪个模块，来作为构建其内部 <a href="https://webpack.docschina.org/concepts/dependency-graph/">依赖图</a> 的开始</p><p><strong>输出：</strong>告诉 webpack 在哪里输出它所创建的 <em>bundle</em>，以及如何命名这些文件</p><p><strong>Loader：</strong>处理一些webpack不能处理的文件，转化为能够处理的文件</p><ul><li>使用 <code>yarn add ...</code> 安装loaders</li></ul><p><strong>插件：</strong>一些扩展功能。范围比Loaders更加广泛，从打包优化到压缩、或者重新定义环境变量等</p><ul><li><a href="https://webpack.docschina.org/plugins">插件列表 | webpack 中文文档 (docschina.org)</a></li></ul><p><strong>模式/兼容性：</strong>通过选择 <code>development</code>, <code>production</code> 或 <code>none</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用 webpack 内置在相应环境下的优化。</p><ul><li>NODE_ENV：<a href="https://www.jianshu.com/p/83e8909fc1cd">NODE_ENV到底是个什么玩意？？ - 简书 (jianshu.com)</a></li></ul><h3 id="一些好用的东西"><span class="post-title-index">2.2.2 </span><a href="#一些好用的东西" class="headerlink" title="一些好用的东西"></a>一些好用的东西</h3><ul><li><strong>热模块替换：</strong><a href="https://webpack.docschina.org/configuration/dev-server/">devServer | webpack 中文文档 (docschina.org)</a></li><li><strong>babel：</strong><a href="https://babeljs.io/docs/en/">What is Babel? · Babel (babeljs.io)</a></li></ul><h2 id="构建工具——Gulp"><span class="post-title-index">2.3 </span><a href="#构建工具——Gulp" class="headerlink" title="构建工具——Gulp"></a>构建工具——Gulp</h2><p><a href="https://gulpjs.com/">gulp.js (gulpjs.com)</a></p><h3 id="gulp-flow"><span class="post-title-index">2.3.1 </span><a href="#gulp-flow" class="headerlink" title="gulp flow"></a>gulp flow</h3><p><img src="https://i.loli.net/2021/09/12/cXUItWdroKDBPNn.png" alt="image-20210912094615895"></p><h3 id="实践中的错误解决"><span class="post-title-index">2.3.2 </span><a href="#实践中的错误解决" class="headerlink" title="实践中的错误解决"></a>实践中的错误解决</h3><p><img src="https://i.loli.net/2021/09/12/MJjaUWRqZfxYoOK.png" alt="image-20210912111807878"></p><p><strong>添加 cb 和 cb()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除dist目录中的内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clean</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    del(<span class="string">&#x27;./dist&#x27;</span>)</span><br><span class="line">    cb()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="脚手架——Yeoman"><span class="post-title-index">2.4 </span><a href="#脚手架——Yeoman" class="headerlink" title="脚手架——Yeoman"></a>脚手架——Yeoman</h2><h3 id="错误解决"><span class="post-title-index">2.4.1 </span><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h3><p><a href="https://www.jianshu.com/p/126ba674e395">nrm ls报错:The “path” argument must be of type string. Received undefined - 简书 (jianshu.com)</a></p><h1 id="Vue框架"><span class="post-title-index">3 </span><a href="#Vue框架" class="headerlink" title="Vue框架"></a>Vue框架</h1><p><img src="https://i.loli.net/2021/09/13/HfWhneTL2ulYz4t.png" alt="image-20210913164417401"></p><h2 id="MVVM架构"><span class="post-title-index">3.1 </span><a href="#MVVM架构" class="headerlink" title="MVVM架构"></a>MVVM架构</h2><ul><li>Model-ViewModel-View-Controller，一种软件架构模式</li><li>Vue使用了这种架构</li></ul><p><img src="https://i.loli.net/2021/09/09/SxoITmUjJgl51NK.jpg" alt="img"></p><h2 id="组件化思想"><span class="post-title-index">3.2 </span><a href="#组件化思想" class="headerlink" title="组件化思想"></a>组件化思想</h2><p><img src="https://i.loli.net/2021/09/14/FWE12qAelQHBn54.png" alt="image-20210914204042352" style="zoom:50%;"></p><p><img src="https://i.loli.net/2021/09/14/cpyOIvU2BRWqPGk.png" alt="image-20210914204248576" style="zoom:50%;"></p><p><strong>组件化原则：</strong></p><ul><li><strong>独立功能模块（松耦合、扁平化、提炼精华）</strong></li><li><strong>独立的状态变化（统一的状态管理）</strong></li><li><strong>从上而下的逻辑思考，从下而上的组件拆分</strong></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;配置Vue开发环境，了解Webpack、Node、Gulp以及Yoeman脚手架等知识。&lt;/p&gt;</summary>
    
    
    
    <category term="专业" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="前端开发学习" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Vue" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/Vue/"/>
    
    
    <category term="Vue" scheme="http://thatmee.github.io/tags/Vue/"/>
    
    <category term="前端开发" scheme="http://thatmee.github.io/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
    <category term="Webpack" scheme="http://thatmee.github.io/tags/Webpack/"/>
    
    <category term="Gulp" scheme="http://thatmee.github.io/tags/Gulp/"/>
    
    <category term="Yoeman" scheme="http://thatmee.github.io/tags/Yoeman/"/>
    
  </entry>
  
  <entry>
    <title>Python语法快速复习</title>
    <link href="http://thatmee.github.io/2021/09/08/python%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/"/>
    <id>http://thatmee.github.io/2021/09/08/python%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-09-07T16:36:23.000Z</published>
    <updated>2021-09-07T16:38:23.493Z</updated>
    
    <content type="html"><![CDATA[<h1 id="注释"><span class="post-title-index">1 </span><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>单行注释 <code>#</code></p><p>多行注释 <code>&quot;&quot;&quot;</code><span id="more"></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一个多行注释</span></span><br><span class="line"><span class="string">可以添加很多内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h1 id="运算符"><span class="post-title-index">2 </span><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算数运算符"><span class="post-title-index">2.1 </span><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p><img src="https://i.loli.net/2021/09/01/sdfClKy5cA1MtO4.png" alt="image-20210901102028481.png"></p><p><img src="https://i.loli.net/2021/09/01/oZdBkxLTKyf9jrR.png" alt="image-20210901102810594"></p><h2 id="比较运算符"><span class="post-title-index">2.2 </span><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p><img src="https://i.loli.net/2021/09/03/s95aZFGM8OB347d.png" alt="image-20210903170056417"></p><h2 id="逻辑运算符"><span class="post-title-index">2.3 </span><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>and/ or/ not</p><h2 id="赋值运算符"><span class="post-title-index">2.4 </span><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><img src="https://i.loli.net/2021/09/07/gCiGKArHObPExoQ.png" alt="image-20210907153131004"></p><h1 id="变量"><span class="post-title-index">3 </span><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量定义"><span class="post-title-index">3.1 </span><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = content</span><br></pre></td></tr></table></figure><ul><li>每个变量在使用前必须赋值</li><li>变量赋值以后才会被创造</li><li>使用“等号”给变量赋值</li><li>变量定义后，后续可以直接使用</li></ul><h2 id="变量类型"><span class="post-title-index">3.2 </span><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p><img src="https://i.loli.net/2021/09/01/GSw5pTBU2hWN7Q1.png" alt="image-20210901110407523"></p><ul><li>数字型变量可以直接计算<ul><li>true 代表 1，false 代表 0</li></ul></li><li>使用 <code>+</code> 拼接字符串变量</li></ul><h3 id="类型转换函数"><span class="post-title-index">3.2.1 </span><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><p><img src="https://i.loli.net/2021/09/01/axALYeHbGSp7DmT.png" alt="image-20210901114240692"></p><h2 id="变量的输入输出"><span class="post-title-index">3.3 </span><a href="#变量的输入输出" class="headerlink" title="变量的输入输出"></a>变量的输入输出</h2><ul><li>使用 <code>print</code> 输出变量</li><li>使用 <code>input</code> 获取用户从键盘的输入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入银行密码:&quot;</span>) </span><br><span class="line"><span class="built_in">print</span>(password)</span><br></pre></td></tr></table></figure><ul><li>input 括号中的字符串是提示信息</li><li>用户输入的任何内容都被认为是字符串</li><li>input 的返回值可以直接赋值给变量</li></ul><h3 id="变量的格式化输出"><span class="post-title-index">3.3.1 </span><a href="#变量的格式化输出" class="headerlink" title="变量的格式化输出"></a>变量的格式化输出</h3><p><img src="https://i.loli.net/2021/09/01/gVWEmGd7HMT4sft.png" alt="image-20210901114907260"></p><h2 id="变量的命名"><span class="post-title-index">3.4 </span><a href="#变量的命名" class="headerlink" title="变量的命名"></a>变量的命名</h2><h3 id="标识符"><span class="post-title-index">3.4.1 </span><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>字母数字下划线组成，开头不能是数字</li><li>标识符区分大小写</li><li>Python中，变量一般全部小写并用下划线分隔。（一般不使用驼峰法）</li></ul><h3 id="关键字"><span class="post-title-index">3.4.2 </span><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><a href="https://www.w3school.com.cn/python/python_ref_keywords.asp">Python 关键字 (w3school.com.cn)</a></p><h1 id="语句"><span class="post-title-index">4 </span><a href="#语句" class="headerlink" title="语句"></a>语句</h1><h2 id="if语句"><span class="post-title-index">4.1 </span><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p><img src="https://i.loli.net/2021/09/03/RwqZhvsAXyUdixr.png" alt="image-20210903165926985"></p><p><img src="https://i.loli.net/2021/09/03/Nw1Uc6nV357fIzE.png" alt="image-20210903170257595"></p><p><img src="https://i.loli.net/2021/09/07/L4Ptkux2X6Vf98Y.png" alt="image-20210907152631352"></p><h2 id="while语句"><span class="post-title-index">4.2 </span><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p><img src="https://i.loli.net/2021/09/07/kdInYJS1VLNpyzf.png" alt="image-20210907153016424"></p><h2 id="for语句"><span class="post-title-index">4.3 </span><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><p><img src="https://i.loli.net/2021/09/08/t1e2qzZrWuXyxCN.png" alt="image-20210908001252394"></p><h1 id="函数"><span class="post-title-index">5 </span><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p><img src="https://i.loli.net/2021/09/07/oBtAGHO9Ffga2h8.png" alt="image-20210907153337724"></p><ul><li>函数先定义后调用</li></ul><h2 id="函数说明"><span class="post-title-index">5.1 </span><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h2><p><img src="https://i.loli.net/2021/09/07/bHwE1tKB6LXrlON.png" alt="image-20210907153850150"></p><blockquote><p><strong>在调用的地方 Ctrl+Q</strong></p></blockquote><h2 id="参数和返回值"><span class="post-title-index">5.2 </span><a href="#参数和返回值" class="headerlink" title="参数和返回值"></a>参数和返回值</h2><p><img src="https://i.loli.net/2021/09/07/tinwX6RHGqKyuQV.png" alt="image-20210907154131163"></p><h1 id="模块"><span class="post-title-index">6 </span><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p><img src="C:\Users\27512\AppData\Roaming\Typora\typora-user-images\image-20210907154517353.png" alt="image-20210907154517353"></p><h2 id="pyc文件"><span class="post-title-index">6.1 </span><a href="#pyc文件" class="headerlink" title="pyc文件"></a>pyc文件</h2><p><img src="https://i.loli.net/2021/09/07/zrxOWCsRdZB87YD.png" alt="image-20210907154630508"></p><h1 id="高级变量"><span class="post-title-index">7 </span><a href="#高级变量" class="headerlink" title="高级变量"></a>高级变量</h1><h2 id="列表"><span class="post-title-index">7.1 </span><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="定义列表"><span class="post-title-index">7.1.1 </span><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h3><p><img src="https://i.loli.net/2021/09/07/AfyCuKlmhV3eTji.png" alt="image-20210907234613403"></p><h3 id="常用操作"><span class="post-title-index">7.1.2 </span><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><blockquote><p><strong>Tips：输入name_list.，敲击tab</strong></p></blockquote><p><img src="https://i.loli.net/2021/09/07/siHEyqf5D3XB9Yd.png" alt="image-20210907235022456"></p><p><a href="https://www.runoob.com/python/python-lists.html">Python 列表(List) | 菜鸟教程 (runoob.com)</a></p><h2 id="元组"><span class="post-title-index">7.2 </span><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p><strong><font color="blue">Python的元组与列表的不同之处：</font></strong></p><ul><li><strong><font color="blue">元组的元素不能修改</font></strong></li><li><strong><font color="blue">元组使用小括号，列表使用方括号</font></strong></li></ul><p><a href="https://www.runoob.com/python/python-tuples.html">Python 元组 | 菜鸟教程 (runoob.com)</a></p><h2 id="字典"><span class="post-title-index">7.3 </span><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p><img src="https://i.loli.net/2021/09/08/PHrLFwGbj3BuahN.png" alt="image-20210908000014495"></p><p><a href="https://www.runoob.com/python/python-dictionary.html">Python 字典(Dictionary) | 菜鸟教程 (runoob.com)</a></p><h2 id="字符串"><span class="post-title-index">7.4 </span><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p><img src="https://i.loli.net/2021/09/08/2cbgYLNsyKFiZnA.png" alt="image-20210908000134150"></p><p><strong><font color="c7254e">Python 不支持单字符类型，单字符在 Python 中也是作为一个字符串使用。</font></strong></p><h2 id="公共方法"><span class="post-title-index">7.5 </span><a href="#公共方法" class="headerlink" title="公共方法"></a>公共方法</h2><h3 id="Python内置函数"><span class="post-title-index">7.5.1 </span><a href="#Python内置函数" class="headerlink" title="Python内置函数"></a>Python内置函数</h3><p><img src="https://i.loli.net/2021/09/08/icySGxOLNA3sbd1.png" alt="image-20210908000943440"></p><h3 id="切片"><span class="post-title-index">7.5.2 </span><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p><img src="https://i.loli.net/2021/09/08/Iij6hl8Ns2duJcw.png" alt="image-20210908001024815"></p><h3 id="运算符-1"><span class="post-title-index">7.5.3 </span><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><p><img src="https://i.loli.net/2021/09/08/UztXP1ZweFbAT2m.png" alt="image-20210908001110504"></p><p><img src="https://i.loli.net/2021/09/08/ZOJmafLuKbDE1yH.png" alt="image-20210908001210051"></p><h1 id="面向对象"><span class="post-title-index">8 </span><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p><a href="https://www.runoob.com/python/python-object.html">Python 面向对象 | 菜鸟教程 (runoob.com)</a></p><h2 id="创建类"><span class="post-title-index">8.1 </span><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p><img src="https://i.loli.net/2021/09/08/vUZQubi2ISNydVq.png" alt="image-20210908001545917"></p><h2 id="self"><span class="post-title-index">8.2 </span><a href="#self" class="headerlink" title="self"></a>self</h2><p>相当于C++的this</p><h2 id="Python内置类属性"><span class="post-title-index">8.3 </span><a href="#Python内置类属性" class="headerlink" title="Python内置类属性"></a>Python内置类属性</h2><p><img src="https://i.loli.net/2021/09/08/dUgjey5wiPGLmR4.png" alt="image-20210908001729430"></p><h2 id="构造和析构"><span class="post-title-index">8.4 </span><a href="#构造和析构" class="headerlink" title="构造和析构"></a>构造和析构</h2><p><img src="https://i.loli.net/2021/09/08/bwDyzOK5ZEGMN2I.png" alt="image-20210908001956529"></p><p><img src="https://i.loli.net/2021/09/08/Wj5asoRxAw9FVlC.png" alt="image-20210908002013470"></p><h2 id="类的继承"><span class="post-title-index">8.5 </span><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><p><img src="https://i.loli.net/2021/09/08/1nHYuAsRweijFNV.png" alt="image-20210908002042108"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h1&gt;&lt;p&gt;单行注释 &lt;code&gt;#&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;多行注释 &lt;code&gt;&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="专业" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="语言学习" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Python" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Python/"/>
    
    
    <category term="Python" scheme="http://thatmee.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Haskell语言学习笔记</title>
    <link href="http://thatmee.github.io/2021/08/07/Haskell%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://thatmee.github.io/2021/08/07/Haskell%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-08-07T15:20:23.000Z</published>
    <updated>2021-08-09T10:38:13.976Z</updated>
    
    <content type="html"><![CDATA[<p>学习Haskell函数式编程语言，第一部分，基础知识和基本函数语法。<span id="more"></span></p><h1 id="基础知识"><span class="post-title-index">1 </span><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="语法清单"><span class="post-title-index">1.1 </span><a href="#语法清单" class="headerlink" title="语法清单"></a>语法清单</h2><ul><li><font color="c7254e"><code>let a = 7</code></font>：let 用于定义常量，常量名、函数名必须首字母小写</li></ul><h2 id="List、德州区间和-List-Comprehension"><span class="post-title-index">1.2 </span><a href="#List、德州区间和-List-Comprehension" class="headerlink" title="List、德州区间和 List Comprehension"></a>List、德州区间和 List Comprehension</h2><h3 id="List"><span class="post-title-index">1.2.1 </span><a href="#List" class="headerlink" title="List"></a>List</h3><p>List是一种单类型的数据结构，可以用来存储多个<font color="blue"><strong>类型相同</strong></font>的元素。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> lostNumbers = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>]   </span><br><span class="line"><span class="title">ghci</span>&gt; lostNumbers    </span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">23</span>,<span class="number">48</span>] </span><br></pre></td></tr></table></figure><p>如上，一个List由方括号括起，其中的元素用逗号分隔开来。</p><ul><li><p><font color="c7254e"><code>&quot;hello&quot; ++ &quot; &quot; ++ &quot;world&quot;</code></font> 得到 <font color="c7254e"><code>&quot;hello world&quot;</code></font>：++运算符，用于连接两个List</p></li><li><p><font color="c7254e"><code>5:[1,2,3,4,5]</code></font> 得到 <font color="c7254e"><code>[5,1,2,3,4,5]</code></font>：使用:运算符往一个List前端插入元素</p></li><li><p><font color="c7254e"><code>&quot;Steve Buscemi&quot; !! 6</code></font> 得到  <font color="c7254e"><code>B</code></font>：使用!!运算符按照索引取得List中的元素</p></li><li>用&gt; &lt; &gt;= = 等符号进行List间的比较</li><li>其余常用函数参见 <a href="https://www.w3cschool.cn/hsriti/y2biqozt.html">第二章 Haskell入门_w3cschool</a></li></ul><h3 id="德州区间"><span class="post-title-index">1.2.2 </span><a href="#德州区间" class="headerlink" title="德州区间"></a>德州区间</h3><p>区间（Range）是构造 List 方法之一，而其中的值必须是可枚举的，如1、2、3，A、B、C等。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="number">1.</span><span class="number">.20</span>]   <span class="comment">--简单的区间</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [<span class="number">2</span>,<span class="number">4.</span><span class="number">.20</span>] <span class="comment">--带步长的区间</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (cycle [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])   <span class="comment">--cycle用于循环单个List</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; take <span class="number">10</span> (repeat <span class="number">5</span>)        <span class="comment">--repeat用于循环单个值</span></span><br><span class="line">[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><h3 id="List-Comprehension"><span class="post-title-index">1.2.3 </span><a href="#List-Comprehension" class="headerlink" title="List Comprehension"></a>List Comprehension</h3><p>List Comprehension能够更加方便自由地生成List，类似于集合的描述法：</p><script type="math/tex; mode=display">\{x\ |\ x∈Z\}</script><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [x*<span class="number">2</span> | x &lt;- [<span class="number">1.</span><span class="number">.10</span>]]   <span class="comment">--前10个整数</span></span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">12</span>,<span class="number">14</span>,<span class="number">16</span>,<span class="number">18</span>,<span class="number">20</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x | x &lt;- [<span class="number">50.</span><span class="number">.100</span>], x `mod` <span class="number">7</span> == <span class="number">3</span>] <span class="comment">--取50到100间所有除7的余数为3的元素</span></span><br><span class="line">[<span class="number">52</span>,<span class="number">59</span>,<span class="number">66</span>,<span class="number">73</span>,<span class="number">80</span>,<span class="number">87</span>,<span class="number">94</span>]</span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; [ x*y | x &lt;- [<span class="number">2</span>,<span class="number">5</span>,<span class="number">10</span>], y &lt;- [<span class="number">8</span>,<span class="number">10</span>,<span class="number">11</span>]] <span class="comment">--从多个List中取元素</span></span><br><span class="line">[<span class="number">16</span>,<span class="number">20</span>,<span class="number">22</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">55</span>,<span class="number">80</span>,<span class="number">100</span>,<span class="number">110</span>]</span><br></pre></td></tr></table></figure><h2 id="Tuple"><span class="post-title-index">1.3 </span><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h2><p>Tuple （元组）要求你对需要组合的数据的数目非常的明确，它的类型取决于其中<font color="blue"><strong>项的数目</strong></font>与其<font color="blue"><strong>各自的类型</strong></font>。 Tuple 中的项由括号括起，并由逗号隔开。另外，Tuple 中的项不必为同一类型，在 Tuple 里可以存入<font color="blue"><strong>多类型</strong></font>项的组合。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; fst (<span class="number">8</span>,<span class="number">11</span>)   <span class="comment">--返回一个序对的首项</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; snd (<span class="number">8</span>,<span class="number">11</span>)   <span class="comment">--返回一个序对的尾项</span></span><br><span class="line"><span class="number">11</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 上述两个函数仅对序对有效，而不能应用于三元组，四元组和五元组之上。</span></span><br><span class="line"></span><br><span class="line"><span class="title">ghci</span>&gt; zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] [<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]   <span class="comment">--zip 生成一组序对的List</span></span><br><span class="line">[(<span class="number">1</span>,<span class="number">5</span>),(<span class="number">2</span>,<span class="number">5</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">4</span>,<span class="number">5</span>),(<span class="number">5</span>,<span class="number">5</span>)]  </span><br></pre></td></tr></table></figure><h2 id="类型和类型类"><span class="post-title-index">1.4 </span><a href="#类型和类型类" class="headerlink" title="类型和类型类"></a>类型和类型类</h2><ul><li><p><a href="https://www.w3cschool.cn/hsriti/h72qkozt.html">第三章 Haskell类型和类型类_w3cschool</a></p></li><li><p>Haskell 的类型必须是首字母大写</p></li><li><p>使用:t命令后跟任何可用的表达式，可以检测表达式的类型</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; :t &#x27;a&#x27;   </span><br><span class="line">&#x27;a&#x27; :: <span class="type">Char</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="type">True</span>   </span><br><span class="line"><span class="type">True</span> :: <span class="type">Bool</span>   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="string">&quot;HELLO!&quot;</span>   </span><br><span class="line"><span class="string">&quot;HELLO!&quot;</span> :: [<span class="type">Char</span>]   <span class="comment">--[char] &lt;=&gt; String</span></span><br><span class="line"><span class="title">ghci</span>&gt; :t (<span class="type">True</span>, &#x27;a&#x27;)   </span><br><span class="line">(<span class="type">True</span>, &#x27;a&#x27;) :: (<span class="type">Bool</span>, <span class="type">Char</span>)   </span><br><span class="line"><span class="title">ghci</span>&gt; :t <span class="number">4</span> == <span class="number">5</span>   </span><br><span class="line"><span class="number">4</span> == <span class="number">5</span> :: <span class="type">Bool</span></span><br></pre></td></tr></table></figure></li><li><p>定义函数时，可以定义参数和返回值类型，参数之间以及参数和返回值之间均使用<font color="c7254e"><code>-&gt;</code></font>分隔</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>   <span class="comment">--三个参数，一个返回值</span></span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数语法"><span class="post-title-index">2 </span><a href="#函数语法" class="headerlink" title="函数语法"></a>函数语法</h1><h2 id="函数声明方法"><span class="post-title-index">2.1 </span><a href="#函数声明方法" class="headerlink" title="函数声明方法"></a>函数声明方法</h2><ul><li><p>函数声明：先<font color="blue"><strong>函数名</strong></font>，后跟由空格分隔的<font color="blue"><strong>参数表</strong></font>。声明中一定要在<font color="c7254e"><code>=</code></font>后面定义函数的<font color="blue"><strong>行为</strong></font></p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleMe</span> x = x + x  <span class="comment">--功能：将一个数字乘以2</span></span><br></pre></td></tr></table></figure></li><li><p>可以在其他函数中调用自己编写的函数，不用考虑函数出现的先后顺序</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">doubleUs</span> x y = doubleMe x + doubleMe y  <span class="comment">--功能：接收两个参数，返回它们的和的2倍</span></span><br></pre></td></tr></table></figure></li><li><p>为函数编写明确的类型声明是一个好习惯</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--功能：过滤大写字母</span></span><br><span class="line"><span class="title">removeNonUppercase</span> :: [<span class="type">Char</span>] -&gt; [<span class="type">Char</span>]   </span><br><span class="line"><span class="title">removeNonUppercase</span> st = [ c | c  st, c `elem` [&#x27;<span class="type">A&#x27;</span>..&#x27;<span class="type">Z&#x27;</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment">--功能：三个整数相加</span></span><br><span class="line"><span class="title">addThree</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span>   </span><br><span class="line"><span class="title">addThree</span> x y z = x + y + z</span><br></pre></td></tr></table></figure></li></ul><h2 id="模式匹配"><span class="post-title-index">2.2 </span><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>模式匹配通过检查数据的特定结构来检查其是否匹配，并按模式从中取得数据。类似于<font color="c7254e"><code>switch...case...</code></font>结构。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">&quot;One!&quot;</span>   <span class="comment">--这里 “1” 是参数</span></span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">&quot;Two!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">&quot;Three!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">&quot;Four!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">&quot;Five!&quot;</span>   </span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">&quot;Not between 1 and 5&quot;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">--如果把最后匹配一切的那个模式挪到最前，它的结果就全都是&quot;Not between 1 and 5&quot;</span></span><br></pre></td></tr></table></figure><p>【<strong>注意</strong>】</p><ul><li>不可以在模式匹配中使用 <font color="c7254e"><code>++</code></font></li></ul><h3 id="对Tuple使用模式匹配"><span class="post-title-index">2.2.1 </span><a href="#对Tuple使用模式匹配" class="headerlink" title="对Tuple使用模式匹配"></a>对Tuple使用模式匹配</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--不会模式匹配的时候</span></span><br><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> a b = (fst a + fst b, snd a + snd b) </span><br><span class="line"></span><br><span class="line"><span class="comment">--一个更好的方法</span></span><br><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)   </span><br><span class="line"><span class="title">addVectors</span> (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  </span><br></pre></td></tr></table></figure><p>用模式匹配实现针对三元组的first、second、third函数</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a   </span><br><span class="line"><span class="title">first</span> (x, _, _) = x        </span><br><span class="line"><span class="comment">--&quot;_&quot;表示我们不关心这部分的具体内容</span></span><br><span class="line"></span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b   </span><br><span class="line"><span class="title">second</span> (_, y, _) = y   </span><br><span class="line"></span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c   </span><br><span class="line"><span class="title">third</span> (_, _, z) = z </span><br></pre></td></tr></table></figure><h3 id="在List-Comprehension中使用模式匹配"><span class="post-title-index">2.2.2 </span><a href="#在List-Comprehension中使用模式匹配" class="headerlink" title="在List Comprehension中使用模式匹配"></a>在List Comprehension中使用模式匹配</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; <span class="keyword">let</span> xs = [(<span class="number">1</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">5</span>,<span class="number">3</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">1</span>)]   </span><br><span class="line"><span class="title">ghci</span>&gt; [a+b | (a,b)  xs]   </span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>一旦模式匹配失败，它就简单挪到下个元素。</p><h3 id="对List使用模式匹配"><span class="post-title-index">2.2.3 </span><a href="#对List使用模式匹配" class="headerlink" title="对List使用模式匹配"></a>对List使用模式匹配</h3><p>用<font color="c7254e"><code>[]</code></font>或<font color="c7254e"><code>:</code></font>来匹配List。例如：</p><ul><li><font color="c7254e"><code>x:xs</code></font>模式，可以将list的头部绑定为x，尾部绑定为xs，但这种模式只能匹配长度<font color="blue"><strong>大于等于1</strong></font>的List，因此对于空的List需要进行特殊判断。</li><li><font color="c7254e"><code>x:y:z:xs</code></font>模式，可以将List的前三个元素都绑定到变量中，但只能匹配长度<font color="blue"><strong>大于等于3</strong></font>的List，因此对于长度小于3的List需要进行特殊判断。</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--实现一个自己的 head 函数</span></span><br><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a   </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;Can&#x27;t call head on an empty list, dummy!&quot;</span></span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x  </span><br></pre></td></tr></table></figure><h3 id="as模式"><span class="post-title-index">2.2.4 </span><a href="#as模式" class="headerlink" title="as模式"></a>as模式</h3><p>所谓<font color="c7254e"><code>as</code></font>模式，就是将一个名字和<font color="c7254e"><code>@</code></font>置于模式前，可以在按模式分割什么东西时仍保留对其整体的引用。如这个模式<font color="c7254e"><code>xs@(x:y:ys)</code></font>，它会匹配出与<font color="c7254e"><code>x:y:ys</code></font>对应的东西，同时你也可以方便地通过<font color="c7254e"><code>xs</code></font>得到整个list，而不必在函数体中重复<font color="c7254e"><code>x:y:ys</code></font>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--代码--</span></span><br><span class="line"><span class="title">capital</span> :: <span class="type">String</span> -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">capital</span> <span class="string">&quot;&quot;</span> = <span class="string">&quot;Empty string, whoops!&quot;</span>   </span><br><span class="line"><span class="title">capital</span> all@(x:xs) = <span class="string">&quot;The first letter of &quot;</span> ++ all ++ <span class="string">&quot; is &quot;</span> ++ [x] </span><br><span class="line"></span><br><span class="line"><span class="comment">--执行结果--</span></span><br><span class="line"><span class="title">ghci</span>&gt; capital <span class="string">&quot;Dracula&quot;</span>   </span><br><span class="line"><span class="string">&quot;The first letter of Dracula is D&quot;</span></span><br></pre></td></tr></table></figure><h2 id="门卫"><span class="post-title-index">2.3 </span><a href="#门卫" class="headerlink" title="门卫"></a>门卫</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--一个用到了门卫的函数--</span></span><br><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">bmiTell</span> bmi   </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>   </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span></span><br></pre></td></tr></table></figure><ul><li><p>门卫由跟在函数名及参数后面的<font color="blue"><strong>竖线</strong></font>标志，通常他们都是靠右一个缩进排成一列。一个门卫就是<font color="blue"><strong>一个布尔表达式</strong></font>，如果为真，就使用其对应的函数体。如果为假，就送去见下一个门卫，如之继续。</p></li><li><p>如果一个函数的所有门卫都没有通过（而且没有提供otherwise作万能匹配），就转入下一模式。这便是门卫与模式契合的地方。如果始终没有找到合适的门卫或模式，就会发生一个错误。</p></li></ul><h2 id="where绑定"><span class="post-title-index">2.4 </span><a href="#where绑定" class="headerlink" title="where绑定"></a>where绑定</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--使用where关键字从而避免重复工作</span></span><br><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span>   </span><br><span class="line"><span class="title">bmiTell</span> weight height   </span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">&quot;You&#x27;re underweight, you emo, you!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">&quot;You&#x27;re supposedly normal. Pffft, I bet you&#x27;re ugly!&quot;</span>   </span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">&quot;You&#x27;re fat! Lose some weight, fatty!&quot;</span>   </span><br><span class="line">    | otherwise   = <span class="string">&quot;You&#x27;re a whale, congratulations!&quot;</span>   </span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li>where关键字跟在门卫后面（最好是与竖线缩进一致）。</li><li>可以定义多个名字和函数，这些名字对每个门卫都是可见的。</li><li>函数在where绑定中定义的名字只对本函数可见，因此我们不必担心它会污染其他函数的命名空间。</li><li><p>where绑定不会在多个模式中共享。如果你在一个函数的多个模式中重复用到同一名字，就应该把它置于全局定义之中。</p></li><li><p>where绑定也可以使用<strong>模式匹配</strong></p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...   </span><br><span class="line"><span class="title">where</span> bmi = weight / height ^ <span class="number">2</span>   </span><br><span class="line">      (skinny, normal, fat) = (<span class="number">18.5</span>, <span class="number">25.0</span>, <span class="number">30.0</span>) </span><br></pre></td></tr></table></figure></li></ul><h2 id="let绑定"><span class="post-title-index">2.5 </span><a href="#let绑定" class="headerlink" title="let绑定"></a>let绑定</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--依据半径和高度求圆柱体表面积--</span></span><br><span class="line"><span class="title">cylinder</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; a   </span><br><span class="line"><span class="title">cylinder</span> r h =  </span><br><span class="line">    <span class="keyword">let</span> sideArea = <span class="number">2</span> * pi * r * h   </span><br><span class="line">        topArea = pi * r ^<span class="number">2</span>   </span><br><span class="line">    <span class="keyword">in</span>  sideArea + <span class="number">2</span> * topArea  </span><br></pre></td></tr></table></figure><p>let的格式为<font color="c7254e"><code>let [bindings] in [expressions]</code></font>。在let中绑定的名字仅对in部分可见。let里面定义的名字也得对齐到一列。</p><blockquote><p><strong>note：</strong><font color="blue"><strong>let绑定和where绑定的区别：</strong> </font></p><font color="blue">**（1）where绑定是个语法结构，let绑定是个表达式，可以随处安放（就像if语句一样）。**</font><font color="blue">**（2）let定义域限制的相当小，因此不能在多个门卫中使用。where跟在函数体后面，主函数体距离类型声明近一些，会更易读。**</font></blockquote><ul><li><p>let可以定义<strong>局部函数</strong></p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; [<span class="keyword">let</span> square x = x * x <span class="keyword">in</span> (square <span class="number">5</span>, square <span class="number">3</span>, square <span class="number">2</span>)]  </span><br><span class="line">[(<span class="number">25</span>,<span class="number">9</span>,<span class="number">4</span>)] </span><br></pre></td></tr></table></figure></li><li><p>若要在一行中<strong>绑定多个名字</strong>，可以用分号将其分开</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> a = <span class="number">100</span>; b = <span class="number">200</span>; c = <span class="number">300</span> <span class="keyword">in</span> a*b*c, <span class="keyword">let</span> foo=<span class="string">&quot;Hey &quot;</span>; bar = <span class="string">&quot;there!&quot;</span> <span class="keyword">in</span> foo ++ bar)  </span><br><span class="line">(<span class="number">6000000</span>,<span class="string">&quot;Hey there!&quot;</span>) </span><br></pre></td></tr></table></figure></li><li><p>可以在let绑定中使用<strong>模式匹配</strong>。这在从Tuple取值之类的操作中很方便。</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ghci</span>&gt; (<span class="keyword">let</span> (a,b,c) = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">in</span> a+b+c) * <span class="number">100</span>  </span><br><span class="line"><span class="number">600</span> </span><br></pre></td></tr></table></figure></li><li><p>也可以把let绑定放到<strong>List Comprehension</strong>中。我们重写下那个计算bmi值的函数，用个let替换掉原先的where。</p>  <figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]  </span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi | (w, h) xs, <span class="keyword">let</span> bmi = w / h ^ <span class="number">2</span>]</span><br></pre></td></tr></table></figure></li></ul><h2 id="case表达式"><span class="post-title-index">2.6 </span><a href="#case表达式" class="headerlink" title="case表达式"></a>case表达式</h2><p>模式匹配本质上不过就是case语句的语法糖而已。这两段代码就是完全等价的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a  </span><br><span class="line"><span class="title">head&#x27;</span> [] = error <span class="string">&quot;No head for empty lists!&quot;</span>  </span><br><span class="line"><span class="title">head&#x27;</span> (x:_) = x </span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">head&#x27;</span> :: [a] -&gt; a   </span><br><span class="line"><span class="title">head&#x27;</span> xs = <span class="keyword">case</span> xs <span class="keyword">of</span> [] -&gt; error <span class="string">&quot;No head for empty lists!&quot;</span>   </span><br><span class="line">                      (x:_) -&gt; x  </span><br></pre></td></tr></table></figure><p><strong>case表达式的语法：</strong></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">case</span> expression <span class="keyword">of</span> pattern -&gt; result   </span><br><span class="line">                   pattern -&gt; result   </span><br><span class="line">                   pattern -&gt; result   </span><br><span class="line">                   ...  </span><br></pre></td></tr></table></figure><blockquote><p><strong>note：</strong><font color="blue"><strong>case表达式和模式匹配的区别：</strong></font></p><p>​        <font color="blue"><strong>函数参数的模式匹配只能在定义函数时使用，而case表达式可以用在任何地方</strong></font></p></blockquote><h1 id="关于函数式编程和Haskell的参考文章"><span class="post-title-index">3 </span><a href="#关于函数式编程和Haskell的参考文章" class="headerlink" title="关于函数式编程和Haskell的参考文章"></a>关于函数式编程和Haskell的参考文章</h1><p><a href="https://www.infoq.cn/article/u4eNCEwHEfBZUHpE4RVo">Clojure和Haskell——深度学习中的函数式语言之美-InfoQ</a></p><p><a href="https://www.infoq.cn/article/2009/02/rwh-book-interview">学习Haskell的现实意义-InfoQ</a></p><p>上学期看崔毅东老师的C++课程时，依稀记得老师提到了这门语言，于是大概学习了一下，第一次接触函数式编程的思想，蛮有趣但还是比较懵，之后再找找实战玩玩看。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;学习Haskell函数式编程语言，第一部分，基础知识和基本函数语法。&lt;/p&gt;</summary>
    
    
    
    <category term="专业" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="语言学习" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="Haskell" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/Haskell/"/>
    
    
    <category term="Haskell" scheme="http://thatmee.github.io/tags/Haskell/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络LAB_1——数据链路层协议实现</title>
    <link href="http://thatmee.github.io/2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CLAB_1%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/"/>
    <id>http://thatmee.github.io/2021/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CLAB_1%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%8D%8F%E8%AE%AE%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-05-06T03:12:24.000Z</published>
    <updated>2021-05-23T17:21:42.047Z</updated>
    
    <content type="html"><![CDATA[<p>本次实验的整理，包括LAB文档内容梳理和实验报告。<span id="more"></span></p><h1 id="LAB文档内容梳理"><span class="post-title-index">1 </span><a href="#LAB文档内容梳理" class="headerlink" title="LAB文档内容梳理"></a>LAB文档内容梳理</h1><h2 id="样例程序分析"><span class="post-title-index">1.1 </span><a href="#样例程序分析" class="headerlink" title="样例程序分析"></a>样例程序分析</h2><h3 id="datalink-h"><span class="post-title-index">1.1.1 </span><a href="#datalink-h" class="headerlink" title="datalink.h"></a>datalink.h</h3><p>首先定义了帧的种类，在数据链路层传递的所有帧，分为数据帧、ACK（确认）帧、NAK（否定确认）帧</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FRAME kind */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_DATA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_ACK  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_NAK  3</span></span><br></pre></td></tr></table></figure><p>之后给出了三种帧的具体结构，小括号内是该段信息的大小，单位为字节：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    DATA Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | SEQ(1) | ACK(1) | DATA(240~256) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ACK Frame</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">| KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NAK Frame</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">| KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">+=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>KIND： 1字节，表示这个帧的种类（可取1,2,3）</p><p>SEQ：   1字节，数据帧序号，如果类型为unsigned char，可表示的范围是 0 ~ 255</p><p>ACK：   ACK帧或NAK帧的序号</p><p>DATA：数据帧中的数据段</p><p>CRC：   冗余码部分</p><h2 id="事件"><span class="post-title-index">1.2 </span><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="五种事件类型"><span class="post-title-index">1.2.1 </span><a href="#五种事件类型" class="headerlink" title="五种事件类型"></a>五种事件类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NETWORK_LAYER_READY 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHYSICAL_LAYER_READY 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_RECEIVED 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMEOUT 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMEOUT 4</span></span><br></pre></td></tr></table></figure><p><strong>NETWORK_LAYER_READY：</strong><br>当网络层有新的分组需要发送并且未被链路层disable，会产生NETWORK_LAYER_READY事件；否则网络层自行缓冲待发送分组。此事件发生后才可以调用get_packet()得到网络层待发送的下一个分组。</p><p><strong>PHYSICAL_LAYER_READY：</strong><br>物理层发送队列的长度低于50字节。（3.3）</p><p><strong>FRAME_RECEIVED：</strong><br>物理层收到了一整帧 。</p><p><strong>DATA_TIMEOUT：</strong><br>超时发生时，产生 DATA_TIMEOUT事件， 并给出超时的定时器编号。<strong>发生超时的定时器的编号在参数 arg中返回。</strong></p><p><strong>ACK_TIMEOUT：</strong><br>所设置的搭载ACK定时器超时。</p><h3 id="程序流程示意"><span class="post-title-index">1.2.2 </span><a href="#程序流程示意" class="headerlink" title="程序流程示意"></a>程序流程示意</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enable_network_layer</span>();</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">event = <span class="built_in">wait_for_event</span>(&amp;arg);</span><br><span class="line"><span class="built_in"><span class="keyword">switch</span></span> (event) &#123;</span><br><span class="line"><span class="keyword">case</span> EVENT_NETWORK_LAYER_READY:</span><br><span class="line">len = <span class="built_in">get_packet</span>(my_buf);</span><br><span class="line">… …</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_PHYSICAL_LAYER_READY:</span><br><span class="line">… …</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_FRAME_RECEIVED:</span><br><span class="line">rbuf_len = <span class="built_in">recv_frame</span>(rbuf, <span class="keyword">sizeof</span> rbuf);</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_ACK_TIMEOUT:</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> EVENT_DATA_TIMEOUT:</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line"><span class="built_in">enable_network_layer</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">disable_network_layer</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口函数及库函数"><span class="post-title-index">1.3 </span><a href="#接口函数及库函数" class="headerlink" title="接口函数及库函数"></a>接口函数及库函数</h2><h3 id="初始化协议"><span class="post-title-index">1.3.1 </span><a href="#初始化协议" class="headerlink" title="初始化协议"></a>初始化协议</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void protocol<span class="constructor">_init(<span class="params">int</span> <span class="params">argc</span>, <span class="params">char</span> <span class="operator">**</span><span class="params">argv</span>)</span>;</span><br></pre></td></tr></table></figure><p>必须首先调用此函数对运行环境初始化。该函数的两个参数必<br>须传递 main()函数的两个同名参数。这样做的目的是从命令行参数中获取站点名及某些选项以提供一种配置系统参数的手段。这些 选项包括 重新 指定日志文件，指定 TCP端口号， 设定误码率，等等。当命令行中重新指定了新的参数值，默认值就不再起作用。</p><p>protocol_init()建立两个站点之间的 TCP连接，并且设定时间坐标的 参考 0点，通信的两个站点的时间坐标 0点在建立 TCP连接时被设置成相同的参考时间点 。</p><p>输出样例：</p><p><img src="https://i.loli.net/2021/05/06/pZ3XQuv2S6qxGBy.png" alt="image-20210505142308591.png"></p><h3 id="网络层接口"><span class="post-title-index">1.3.2 </span><a href="#网络层接口" class="headerlink" title="网络层接口"></a>网络层接口</h3><h4 id="网络层包长度"><span class="post-title-index">1.3.2.1 </span><a href="#网络层包长度" class="headerlink" title="网络层包长度"></a>网络层包长度</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PKT_LEN 256</span></span><br></pre></td></tr></table></figure><h4 id="流量控制函数"><span class="post-title-index">1.3.2.2 </span><a href="#流量控制函数" class="headerlink" title="流量控制函数"></a>流量控制函数</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enable_network_layer</span><span class="params">(<span class="keyword">void</span>)</span></span>;<span class="function"><span class="keyword">void</span> <span class="title">disable_network_layer</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>对于发送方向来说，网络层和数据链路层的约定为：数据链路层在缓冲区满等条件下无法发送分组<br>时通过 disable_network_layer()通知网络层；在能够承接新的发送任务时执行<br>enable_network_layer()允许网络层发送 数据 分组</p><h4 id="包处理函数"><span class="post-title-index">1.3.2.3 </span><a href="#包处理函数" class="headerlink" title="包处理函数"></a>包处理函数</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> get<span class="constructor">_packet(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">packet</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：将分组拷贝到指针 p指定的缓冲区中。</p><p>返回值：分组长度</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void put<span class="constructor">_packet(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">packet</span>, <span class="params">int</span> <span class="params">len</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：存放收到分组的缓冲区首地址，分组长度</p><blockquote><p><strong>统计功能：</strong></p><p>如果本次调用 put_packet()函数 比上次调用该函数的时间间隔超过 2秒，将给出一个接收方向的报告，格式如下所示：</p><p>480.484 …. 1784 packets received, 7611 bps, 95.14%, Err 38 (9.9e 006)</p><p>时间坐标为480.484秒，收到了 1784个分组，网络层有效数据传输率 7611bps，实际线路利用率95.14%，接收方向共检出 38个帧校验和错误，统计计算出实际误码率 9.9x10 6。</p></blockquote><h3 id="物理层接口"><span class="post-title-index">1.3.3 </span><a href="#物理层接口" class="headerlink" title="物理层接口"></a>物理层接口</h3><h4 id="帧处理函数"><span class="post-title-index">1.3.3.1 </span><a href="#帧处理函数" class="headerlink" title="帧处理函数"></a>帧处理函数</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void send<span class="constructor">_frame(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">frame</span>, <span class="params">int</span> <span class="params">len</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：将内存 frame处长度为 len的缓冲区块向物理层发送为一帧，每字节发送需要 1ms，帧与帧之间的边界保留 1ms。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> recv<span class="constructor">_frame(<span class="params">unsigned</span> <span class="params">char</span> <span class="operator">*</span><span class="params">buf</span>, <span class="params">int</span> <span class="params">size</span>)</span>;</span><br></pre></td></tr></table></figure><p>参数：从物理层接收一帧， size为用于存放接收帧的缓冲区 buf的空间大小</p><p>返回值：收到帧的实际长度 。</p><h4 id="查看队列长度"><span class="post-title-index">1.3.3.2 </span><a href="#查看队列长度" class="headerlink" title="查看队列长度"></a>查看队列长度</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">phl_sq_len</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数返回当前物理层队列的长度 。</p><h4 id="流量控制机制"><span class="post-title-index">1.3.3.3 </span><a href="#流量控制机制" class="headerlink" title="流量控制机制"></a>流量控制机制</h4><p>为协调数据链路层和物理层之间的流量，采用的机制是：只要在事件处理周期内至少一次调用过 send_frame()函数，那么，事件等待函数 wait_for_event()会在物理层发送队列低于50字节水平时，产生 PHYSICAL_LAYER_READY事件。</p><blockquote><p>例如：物理层当前队列长度 20字节，链路层调用send_frame()发送一 7字节 帧，那么，随后的事件等待函数 wait_for_event()会立即产生PHYSICAL_LAYER_READY事件；再如：物理层当前队列长度 40字节，链路层调用 send_frame()发送一300字节字节帧帧，受限于信道受限于信道8000bps的带宽，需要发送的数据不可能瞬间发送到线路上，的带宽，需要发送的数据不可能瞬间发送到线路上，wait_for_event()会在物理层队列由会在物理层队列由340字节降为字节降为50字节以下（至少需要字节以下（至少需要290毫秒）毫秒）后才产生后才产生PHYSICAL_LAYER_READY事件。</p></blockquote><p>在PHYSICAL_LAYER_READY事件后，如果 数据链路层 暂时没有需要发送的数据，因系统不会再次送来 PHYSICAL_LAYER_READY事件，应记录物理层状态，当有数据需要发送时直接发送。 物理层事件的这种处理方式类似于 硬件中的发送中断。</p><p>不顾物理层是否出于准备好状态而 调用 send_frame()发送多帧，受限于信道的 8000bps能力，会导致数据堆积在物理层发送队列的时间较长，等待物理层慢慢把数据发送出去。</p><p><strong>物理层发送队列最多可以保留 64K字节。</strong></p><h3 id="CRC校验的产生和验证"><span class="post-title-index">1.3.4 </span><a href="#CRC校验的产生和验证" class="headerlink" title="CRC校验的产生和验证"></a>CRC校验的产生和验证</h3><p>本次实验采用的CRC校验方案为 CRC 32，与 IEEE 802.3以太网校验和生成多项式相同。生成多项式为：<br>x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">crc32</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>函数crc32()返回一 个 32比特整数。</p><blockquote><p>设指针 p的定义为 char * p并且 p指向一个缓冲区，缓冲区内有 243字节数据，为这 243字节数据生成 CRC 32校验和，并且把这 32比特校验和附在 243字节之后，执行下面的语句：(unsigned int *)(p + 243) = crc32(p, 243);<br><strong>注意：</strong><br>p所指缓冲区必须至少有 247字节有效空间，以防内存访问越界。</p><p>验证校验和的方法，对上面的例子，只需要判断crc32(p, 243 + 4)是否为 0：<br>校验和正确为 0，否则不为 0。</p></blockquote><h3 id="定时器管理"><span class="post-title-index">1.3.5 </span><a href="#定时器管理" class="headerlink" title="定时器管理"></a>定时器管理</h3><h4 id="get-ms"><span class="post-title-index">1.3.5.1 </span><a href="#get-ms" class="headerlink" title="get_ms"></a>get_ms</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">get_ms</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>get_ms()函数获取当前的时间坐标，单位为毫秒。</p><h4 id="start-timer"><span class="post-title-index">1.3.5.2 </span><a href="#start-timer" class="headerlink" title="start_timer"></a>start_timer</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void start<span class="constructor">_timer(<span class="params">unsigned</span> <span class="params">int</span> <span class="params">nr</span>, <span class="params">unsigned</span> <span class="params">int</span> <span class="params">ms</span>)</span>;</span><br></pre></td></tr></table></figure><p>start_timer()用于启动一个定时器。</p><p><strong>参数：</strong>计时器的编号，超时时间值。计时器的编号只允许在0~63之间，超时时间间隔的单位为毫秒。</p><p>超时发生时，产生 DATA_TIMEOUT事件， 并给出超时的定时器编号。<strong>发生超时的定时器的编号在参数 arg中返回。</strong></p><blockquote><p>例如： start_timer(3, 1200)启动 3号定时器，定时器的长度为 1.2秒 。</p></blockquote><p>系统在把截止到调用函数start_timer()时刻为止已经放入物理层发送队列的数据发送完毕后才开始启动计时（不是从当前时间开始计时）。</p><blockquote><p>例如：当前时间坐标为 5.100，物理层发送队列目前有 300字节，信道速率 8000bps，函数调用 start_timer(3, 1200)会导致 1.5秒之后 时间坐标 6.600处 3号定时器产生DATA_TIMEOUT事件 。</p></blockquote><p>在定时器未超时之前直接对同一个编号的定时器执行start_timer()调用， 将按照<strong>新的时间</strong>设置产生超时事件。</p><h4 id="stop-timer"><span class="post-title-index">1.3.5.3 </span><a href="#stop-timer" class="headerlink" title="stop_timer"></a>stop_timer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> nr)</span></span>;</span><br></pre></td></tr></table></figure><p>stop_timer()中止一个定时器。</p><p><strong>参数：</strong>要终止的定时器的编号</p><h4 id="start-ack-timer"><span class="post-title-index">1.3.5.4 </span><a href="#start-ack-timer" class="headerlink" title="start_ack_timer"></a>start_ack_timer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_ack_timer</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> ms)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>与start_timer（3.5.2）的不同之处：</strong></p><ol><li>少了一个参数：定时器编号。意味着只有一个ACK定时器</li><li>ACK计时器启动时刻为当前时刻；</li><li>在ACK定时器未超时之前重新执行 start_ack_timer()调用，定时器将<strong>依然</strong>按照<strong>先前</strong>的时间设置产生超时事件 ACK_TIMEOUT。</li></ol><h4 id="stop-ack-timer"><span class="post-title-index">1.3.5.5 </span><a href="#stop-ack-timer" class="headerlink" title="stop_ack_timer"></a>stop_ack_timer</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop_ack_timer</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>终止ACK计时器。</p><h3 id="跟踪、调试和输出"><span class="post-title-index">1.3.6 </span><a href="#跟踪、调试和输出" class="headerlink" title="跟踪、调试和输出"></a>跟踪、调试和输出</h3><h4 id="对printf的改良"><span class="post-title-index">1.3.6.1 </span><a href="#对printf的改良" class="headerlink" title="对printf的改良"></a>对printf的改良</h4><p>lprintf()函数</p><h4 id="debug输出"><span class="post-title-index">1.3.6.2 </span><a href="#debug输出" class="headerlink" title="debug输出"></a>debug输出</h4><ol><li><p><strong>debug_mask变量</strong></p><p> 一个静态整型变量，用于调试信息的输出控制，默认值为0。</p></li><li><p><strong>dbg_frame, dbg_event, dbg_warning</strong></p><p> 用 debug_mask的比特 0控制“事件”信息，比特 1控制“帧收发”信息：</p><p> 当 debug_mask的 0号比特为 0时，dbg_event()的所有输出被忽略；</p><p> 当 debug_mask的 1号比特为 0时，dbg_frame()的所有输出被忽略。</p></li></ol><h4 id="获取站点名"><span class="post-title-index">1.3.6.3 </span><a href="#获取站点名" class="headerlink" title="获取站点名"></a>获取站点名</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">station_name</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>此函数获取当前进程所对应的站点名，返回值为字符串 ”A”或者 ”B”。</p><h2 id="命令行选项"><span class="post-title-index">1.4 </span><a href="#命令行选项" class="headerlink" title="命令行选项"></a>命令行选项</h2><p><img src="https://i.loli.net/2021/05/06/P1q6UxWy9zfcAJZ.png" alt="image-20210505141428458.png"></p><h2 id="错误信息"><span class="post-title-index">1.5 </span><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><p><img src="https://i.loli.net/2021/05/06/TkN1AXZevEKlsQx.png" alt="image-20210505141514462.png"></p><h2 id="问题汇总"><span class="post-title-index">1.6 </span><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><ul><li><p><strong>between函数，为什么那么设计</strong></p></li><li><p>ack计时器，为什么只要一个，为什么send_frame之后立刻就stop_ack，start_ack又为什么是在收到帧的时候的操作，而不是发送帧的操作</p><ul><li>ack的计时器，其实是等待捎带ack的计时器。一切都迎刃而解。</li></ul></li><li><p><strong>关于滑动窗口的大小的计算，已经计算出滑动窗口大小&lt;4，为什么还能设为7，设为63？7和63又是如何得到的？</strong></p></li></ul><h1 id="实验报告"><span class="post-title-index">2 </span><a href="#实验报告" class="headerlink" title="实验报告"></a>实验报告</h1><h2 id="实验内容及实验环境描述"><span class="post-title-index">2.1 </span><a href="#实验内容及实验环境描述" class="headerlink" title="实验内容及实验环境描述"></a>实验内容及实验环境描述</h2><h3 id="实验内容"><span class="post-title-index">2.1.1 </span><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h3><p>​        利用所学数据链路层原理，自己设计一个滑动窗口协议，在仿真环境下编程实现有噪音信道环境下两站点之间无差错双工通信。信道模型为8000bps 全双工卫星信道，信道传播时延270毫秒，信道误码率为10^-5，信道提供字节流传输服务，网络层分组长度固定为256字节。</p><p>​        本次实验选用的滑动窗口协议为带NAK和不带NAK的回退N协议，以及选择重传协议。</p><h3 id="实验环境"><span class="post-title-index">2.1.2 </span><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>​        Windows10，Microsoft Visual Studio 2019，PowerShell</p><h2 id="软件设计"><span class="post-title-index">2.2 </span><a href="#软件设计" class="headerlink" title="软件设计"></a>软件设计</h2><h3 id="数据结构"><span class="post-title-index">2.2.1 </span><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="FRAME结构体"><span class="post-title-index">2.2.1.1 </span><a href="#FRAME结构体" class="headerlink" title="FRAME结构体"></a>FRAME结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FRAME</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> kind;            <span class="comment">/*FRAME_DATA, FRAME_ACK, FRAME_NAK*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> seq;             <span class="comment">/*数据帧序号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ack;             <span class="comment">/*ACK帧或NAK帧的序号*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> data[PKT_LEN];   <span class="comment">/*数据帧里的数据部分*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  padding;         <span class="comment">/*CRC冗余码部分*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>三种帧类型的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* FRAME kind */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_DATA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_ACK  2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FRAME_NAK  3</span></span><br></pre></td></tr></table></figure><p>三种帧的具体结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    DATA Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | SEQ(1) | ACK(1) | DATA(240~256) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+===============+========+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ACK Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    NAK Frame</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">    | KIND(1) | ACK(1) | CRC(4) |</span></span><br><span class="line"><span class="comment">    +=========+========+========+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="GBN协议宏定义和全局变量"><span class="post-title-index">2.2.1.2 </span><a href="#GBN协议宏定义和全局变量" class="headerlink" title="GBN协议宏定义和全局变量"></a>GBN协议宏定义和全局变量</h4><ul><li><strong>宏定义</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ 7         <span class="comment">//帧序号最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMER 1500   <span class="comment">//数据帧超时时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMER 300     <span class="comment">//等待捎带ACK的时间</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>全局变量</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> frame_expected = <span class="number">0</span>;           <span class="comment">//接受窗口期待接收的序号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> buffer[MAX_SEQ + <span class="number">1</span>][PKT_LEN]; <span class="comment">//发送窗口缓存区。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> ack_expected = <span class="number">0</span>;             <span class="comment">//发送窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> next_frame = <span class="number">0</span>;               <span class="comment">//发送窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> nbuffered;                    <span class="comment">//发送窗口缓冲区已使用的数量，已发送的帧数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> phl_ready = <span class="number">0</span>;                          <span class="comment">//物理层就绪标志。（为 1 就绪）</span></span><br><span class="line"><span class="keyword">int</span> no_nak = <span class="number">1</span>;                                    <span class="comment">//NAK有效标志（为 1 有效）</span></span><br></pre></td></tr></table></figure><p>其中：</p><p>① 在GBN协议中，接收窗口大小规定为 1，发送窗口大小 = 帧序号数量 - 1 = 帧序号最大值。</p><p>② 发送窗口缓冲区的作用是：将每个已发送未确认的帧缓存下来，若出现丢包或坏帧则可以重发。因此，缓冲区大小和发送窗口大小相同。</p><h4 id="SR协议宏定义和全局变量"><span class="post-title-index">2.2.1.3 </span><a href="#SR协议宏定义和全局变量" class="headerlink" title="SR协议宏定义和全局变量"></a>SR协议宏定义和全局变量</h4><ul><li><strong>宏定义</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SEQ 63                  <span class="comment">//帧序号最大值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NR_BUF ((MAX_SEQ + 1) / 2)  <span class="comment">//接收\发送窗口缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_TIMER 3000             <span class="comment">//数据帧超时时间</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ACK_TIMER 1000              <span class="comment">//ACK帧超时时间</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>全局变量</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> out_buffer[NR_BUF][PKT_LEN];   <span class="comment">//发送窗口缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> in_buffer[NR_BUF][PKT_LEN];    <span class="comment">//接收窗口缓冲区</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> ack_expected = <span class="number">0</span>;              <span class="comment">//发送窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> next_frame = <span class="number">0</span>;                <span class="comment">//发送窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> frame_expected = <span class="number">0</span>;            <span class="comment">//接收窗口下边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> too_far = NR_BUF;              <span class="comment">//接收窗口上边界</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> nbuffered;                     <span class="comment">//发送窗口缓冲区已使用的数量，已发送的帧数量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> phl_ready = <span class="number">0</span>;                           <span class="comment">//物理层就绪标志。（为 1 就绪）</span></span><br><span class="line"><span class="keyword">int</span> no_nak = <span class="number">1</span>;                                     <span class="comment">//NAK有效标志（为 1 有效）</span></span><br><span class="line"><span class="keyword">int</span> arrv[NR_BUF];                                   <span class="comment">//接收窗口缓冲区标志（为 1 表示已占用）</span></span><br></pre></td></tr></table></figure><p>其中：接收\发送窗口缓冲区大小 = 发送窗口大小 = 接收窗口大小</p><h3 id="模块结构"><span class="post-title-index">2.2.2 </span><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h3><h4 id="子程序说明"><span class="post-title-index">2.2.2.1 </span><a href="#子程序说明" class="headerlink" title="子程序说明"></a>子程序说明</h4><blockquote><p>两个协议的子程序原理、作用及参数等大致相同，不再分开阐述</p></blockquote><ul><li><p><strong>static int between(unsigned char a, unsigned char b, unsigned char c)</strong></p><ul><li>函数作用：判断帧序号是否落在接收\发送窗口内，以此决定接下来的操作（缓存、发送ACK或者丢弃等）</li><li>参数：<ul><li>unsigned char a, unsigned char c：窗口的边界</li><li>unsigned char b：帧序号或ACK序号</li></ul></li><li>返回值：int 类型，若在窗口内，返回true（1），否则返回false（0）</li></ul></li><li><p><strong>char inc(char c)</strong></p><ul><li>函数作用：用于序号的循环有界递增。例如，帧序号最大值为3时，序号只能取 0,1,2,3,0,1,2…</li><li>参数：char c：需要递增的序号值</li><li>返回值：char类型，递增之后的结果</li></ul></li><li><p><strong>static void put_frame(unsigned char* frame, int len)</strong></p><ul><li>函数作用：为一帧添加CRC校验和，并将这一帧发送给物理层</li><li>参数：<ul><li>unsigned char* frame：指向这一帧的指针</li><li>int len：这一帧的长度，单位为字节</li></ul></li><li>无返回值</li></ul></li><li><p><strong>static void send_data_frame(void)</strong></p><ul><li><p>函数作用：发送数据帧</p></li><li><p>无参数</p><blockquote><p>这里与教材中是不同的，由于本协议实现中使用了大量全局变量，在传参方面省略了很多功夫</p></blockquote></li><li><p>无返回值</p></li></ul></li><li><p><strong>static void send_ack_frame(void)</strong></p><ul><li>函数作用：发送单独ACK帧</li></ul></li><li><p><strong>static void send_nak_frame(void)</strong></p><ul><li>函数作用：发送单独的NAK帧</li></ul></li></ul><h4 id="程序调用关系图"><span class="post-title-index">2.2.2.2 </span><a href="#程序调用关系图" class="headerlink" title="程序调用关系图"></a>程序调用关系图</h4><p><img src="https://i.loli.net/2021/05/06/P5WJxNwhGBRKFlt.png" alt="image-20210505182426979.png"></p><h4 id="响应分析"><span class="post-title-index">2.2.2.3 </span><a href="#响应分析" class="headerlink" title="响应分析"></a>响应分析</h4><ul><li><p><strong>GBN协议</strong></p><p>  <img src="https://i.loli.net/2021/05/06/hwXlKNHo81qUcba.png" alt="image-20210505171554501.png"></p></li><li><p><strong>SR协议</strong></p><p>  <img src="https://i.loli.net/2021/05/06/R9IxP674r3fHYLh.png" alt="image-20210505171638295.png"></p></li></ul><h4 id="算法流程图"><span class="post-title-index">2.2.2.4 </span><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h4><p><img src="https://i.loli.net/2021/05/06/N9k1zYTAbQjwrt2.png" alt="image-20210505182001929.png"></p><h2 id="实验结果分析"><span class="post-title-index">2.3 </span><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p><strong>1.描述你所实现的协议软件是否实现了有误码信道环境中无差错传输功能。</strong></p><p>实现了有误码信道环境中的无差错传输功能，采用了CRC校验和重传技术使错误得以发现和纠正</p><p><strong>2.程序的健壮性如何，能否可靠地长时间运行。</strong></p><p>程序健壮性强，在高负荷和高误码率等条件下均未出现过死锁现象，能够正常运行。线下测试时运行30min左右没有问题。</p><p><strong>3.协议参数的选取：滑动窗口的大小，重传定时器的时限，ACK 搭载定时器的时限，这些参数是怎样确定的？根据信道特性数据，分组层分组的大小，以及你的滑动窗口机制，给出定量分析，详细列举出选择这些参数值的具体原因。</strong></p><p>根据实验模型：8000bps全双工卫星信道，分组长度固定为 256 字节，单向传输时延为270ms，信道误码率（默认）10^-5，帧间间隔1ms。我对两个协议的窗口大小、重传定时器时限和ACK定时器时限进行了理论计算和实际测试。</p><p>①  <strong>滑动窗口的大小：</strong></p><p>滑动窗口大小直接涉及到信道利用率和数据拥塞问题，若窗口太小，将导致信道利用率过低，信道中长时间没有数据传送；若窗口太大，数据发送过快，将造成接收方被数据淹没，发生拥塞现象导致数据丢失，出错率增加。</p><ul><li>首先计算得到滑动窗口的最小值，设滑动窗口的大小 W，信道传输时延 t，数据率 c，帧长度 l 。则应有关系式如下：</li></ul><script type="math/tex; mode=display">W >= [ 2t + 2 * (l/c) ] / (l/c)</script><blockquote><p>根据自定义的帧的数据结构可知，一个数据帧最长包括3字节的帧头（kind，seq，ack）、256字节的数据和4字节的 CRC 冗余码，共263字节。即此处l = 263 * 8 bit。代入其他数据计算可得，W &gt;= 4.05。</p></blockquote><ul><li>而滑动窗口的最大值与帧序列有关，设发送窗口大小 Ws，接收窗口大小为Wr，帧序列的二进制位数为 n。则有关系式如下：<script type="math/tex; mode=display">Ws + Wr <= 2^n</script></li></ul><blockquote><p>在帧结构中，帧序列seq为unsigned char类型，大小为1字节，即n = 8。<br>在GBN协议中，Wr = 1，所以其Ws &lt;= 255 。<br>在SR协议中，Wr = Ws时效率最高，从而，Wr = Ws &lt;= 128</p></blockquote><ul><li>通过实际测试的结果分析得到合适的 W 值，最终发现，在 GBN 协议中，W 取 7 效率最高；在 SR 协议中，W 取 63 效率最高</li></ul><p>②  <strong>重传定时器时限和ACK定时器时限</strong>：</p><p>重传计时器的时限涉及到重传的响应时间，若太大，将导致重传等待的时间过久；若太小，将导致较为频繁的重传，两种情况均将导致信道利用率下降。</p><ul><li><p>估算重传定时器时限的<strong>下界 t</strong> ，考虑如下几个时间：</p><ul><li>每一帧的帧长为263B，由信道传输速率为 8000bps 可得<strong>数据发送延迟时间 Td</strong> 为 263ms 。</li><li><strong>传播时延 Ts</strong> 固定为 270ms 。</li><li>接收方接收完数据帧后，既可能以捎带 ACK 的方式发送 ACK ，也可能由于 ACK定时器超时而发送单独的 ACK 帧。这里显然应取：对方从接收完数据帧，到开始发送 ACK 的时间间隔的上界进行计算，不难看出，这个上界就是ACK定时器的时长 <strong>ACK_TIMER</strong></li><li>ACK 帧在物理层队列中<strong>排队的等待时间</strong>，同样以最坏情况进行计算，即在 ACK 帧之前存在等待发送的普通数据帧（已发送0字节）、重传数据帧和 NAK 帧，总计 263 + 263 + 6 = 532 字节，需要花费 532ms 才能发送完成。</li><li><strong>发送这个ACK 帧</strong>的时间为6ms，它在信道上的<strong>传输时延</strong>为270ms 。</li><li><p>物理层在发送数据帧时会在帧与帧之间添加 <strong>1ms 的时间间隔</strong>，最坏情况下增加 4ms 的时间。</p><p>综上有：</p></li></ul></li></ul><script type="math/tex; mode=display">t = 263 + 270 + ACK\_TIMER + 532 + 6 + 270 + 4 = 1345 + ACK\_TIMER (ms)</script><ul><li><p>由此可得，重传定时器时限 t 与ACK定时器时限 ACK_TIMER 有关。我们知道，ACK定时器时限的一个最低的下界为数据链路层从网络层获得一个数据包的时间，经过多次的测试和分析，我们发现这个下界大约为200ms。而在实际测试中，当ACK定时器时限高于这个下界时可取得较高的效率。</p></li><li><p>最终，我们通过多次实验观察的方式，确定了 t 的最优值 : </p><ul><li>在 GBN 协议中令ACK定时器时限为 <strong>240 ms</strong>，在SR协议中，令ACK定时器时限为<strong>1000 ms</strong>。</li><li>重传定时器在 GBN 协议中取 <strong>2800ms</strong> 最优，在SR协议中取 <strong>3000ms</strong> 最优。</li></ul></li></ul><p><strong>4.理论分析：根据所设计的滑动窗口工作机制(Go-Back-N 或者选择重传)，推导出在无差错信道环境下分组层能获得的最大信道利用率；推导出在有误码条件下重传操作及时发生等理想情况下分组层能获得的最大信道利用率。给出理论推导过程。理论推导的目的是得到信道利用率的极限数据。为了简化有误码条件下的最大利用率推导过程，可以对问题模型进行简化，比如：假定超时重传的数据帧的回馈ACK 帧可以100%正确传输，但是简化问题分析的这些假设必须不会对整个结论产生较大的误差。</strong></p><ul><li><p>在无差错信道上，由于需要携带3字节的控制信息和4字节的校验位，因此最大的信道利用率为</p><script type="math/tex; mode=display">  256/(256 + 3 + 4)= 97.3\%</script></li><li><p>在误码率为 1e-5 的信道上（即每传送 100000 个比特平均会发生 1 个错误）</p><blockquote><p>假设信道上始终有数据需要传送，则可以传送 100000/((256+3+4)*8) 约为 47 个数据包，即每 47 个数据包会有一个出错。</p><p>假设超时重传的数据帧的回馈ACK 帧可以100%正确传输，出错的是最后一个数据包，且每出错一次，在限定时间内可以正确重传该帧。</p></blockquote><p>  则每传送 47 个数据包需要传送 47+1+1 = 49 次。于是此时的信道利用率为</p><script type="math/tex; mode=display">  (47 * 256)/(49 *(256+3+4)) ≈ 93.4 \%</script><p>  但由于程序设计并不能够达到理想状态，当一个数据包超时后，往往需要重复多次重传，造成信道浪费。若重传 K 次，则信道利用率为</p><script type="math/tex; mode=display">  (47*256)/((48 + k) *(256+3+4))</script><p>  若平均重传10次，信道利用率约为 78.88% 。</p></li></ul><p><strong>5.实验结果分析：你的程序运行实际达到了什么样的效率，比对理论推导给出的结论，有没有差距？给出原因。有没有改进的办法？如果没有时间把这些方法付诸编程实施，介绍你的方案。</strong></p><p>实际达到的效率如下表所示：</p><p><img src="https://i.loli.net/2021/05/06/yjQkKdcia9BnDGU.png" alt="image-20210505210958256"></p><p>协议效率大部分达到了参考效率，但有一些数据与理想效率有差距，比如无误码情况下的97.3%，以及高误码率下的效率。考虑其原因，猜想主要有以下几方面：</p><ul><li>不能保证数据链路层和物理层之间没有延迟，ACK和重传的帧也不能100%正确，与理想的假设情况有区别</li><li>在高误码率的环境下，NAK帧的丢失有可能会导致一连串的重传，降低传输效率</li><li>所选的窗口大小和超时时间还不是最优的</li></ul><p>据此，提出以下方案：</p><ul><li>修改回退N步协议，添加NAK帧。根据实测结果（见上述表格），这种方法对回退N的效率有一定提升，但不明显。</li><li>对选择重传协议的NAK帧进行一定修改，拓宽其服务对象，设置NAK数组，对每一个缓冲区内的帧都可以单独发送NAK帧，这样可以缓解高误码率下NAK帧丢失、坏帧之后带来的一系列超时重传问题。</li><li>针对数据链路层与物理层之间的延迟，考虑取消PHYSICAL_LAYER_READY事件对NAK帧、ACK帧、超时重传的数据帧的限制，一旦产生这些帧，无论PHYSICAL_LAYER_READY事件是否发生，都可以直接发送。</li><li>通过有设计的实验，对误码率、传输速率、窗口大小、超时时间等量进行定量分析，借助dbg输出以及相关统计工具，从统计学角度对实验结果进行更加合理严谨的分析，通过图像、函数、求导等手段，得出理论上最优超时时间以及窗口大小。</li></ul><h2 id="研究和探索的问题"><span class="post-title-index">2.4 </span><a href="#研究和探索的问题" class="headerlink" title="研究和探索的问题"></a>研究和探索的问题</h2><p><strong>（1） CRC校验能力</strong></p><p>CRC校验码的检错能力很强，它除了能检查出离散错外，还能检查出突发错误。本次实验采用的CRC校验方案为CRC-32，与IEEE802.3以太网校验和生成多项式相同。生成多项式为：</p><p>x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+1</p><p>从其检错能力来看，不能发现传输错误的概率为2的-32次方，几乎接近于0，因此没有必要增加成本再去达到理论上为0的错误率。</p><p>另外一个方面，如果CRC校验错误而导致给网络层传输了错误数据，那么网络层也可以通过它的校验方式发现错误，采取重传，因此能够进一步保证传输正确性。</p><p><strong>（2）</strong> <strong>程序设计方面的问题</strong></p><p>①  协议软件跟踪功能为协议的调试提供了优质的方法，通过调用dbg_event和dbg_frame函数，可以清楚地观察协议的运行过程，可以非常自由的输出运行中的调试信息，并且跟踪到相应的代码段。我的程序多处调用dbg函数，实现了协议软件跟踪调试。</p><p>②  C语言的time.h当中提供了一些关于时间操作的函数可以用来实现get_ms()函数，如clock_t clock()。该函数返回程序开始执行后占用的处理器时间，如果无法获得占用时间则返回-1。只需在开始通信时，设置一个静态变量start_time。然后在每次调用get_ms()后，获取当前的时间current_time。然后再返回start_time-current_time即可。</p><p>③  如果本次实验提供的程序库中不包含log_printf和lprintf函数，可自己实现。</p><p>④  Start_timer()函数用于给发出的数据帧计时，如果超时还未收到确认ACK，便重发缓存中的数据帧。因此，在重新调用时应重新开始计时。Start_ack_timer()函数用于等待捎带确认的反向数据帧，若超时还没有反向数据帧，那就需要单独发送一个ACK帧。Start_ack_timer()在重新调用上的特点，就是为了避免ACK定时器时限过长使得发送方超时重发。</p><p><strong>（3）对等协议实体之间的流量控制</strong></p><p>我的协议解决了流量控制问题。作为滑动窗口协议，窗口本身就是一个流量控制，由于窗口大小的限制，发送方不会一次性发送过多信息导致接收方被数据所淹没或信息丢失。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本次实验的整理，包括LAB文档内容梳理和实验报告。&lt;/p&gt;</summary>
    
    
    
    <category term="专业" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="专业课程" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/"/>
    
    <category term="计算机网络" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E4%B8%93%E4%B8%9A%E8%AF%BE%E7%A8%8B/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="C" scheme="http://thatmee.github.io/tags/C/"/>
    
    <category term="网络协议" scheme="http://thatmee.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    
    <category term="计算机网络" scheme="http://thatmee.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="LAB" scheme="http://thatmee.github.io/tags/LAB/"/>
    
  </entry>
  
  <entry>
    <title>C++程序设计08——运算符重载</title>
    <link href="http://thatmee.github.io/2021/04/27/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A108%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>http://thatmee.github.io/2021/04/27/C++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A108%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</id>
    <published>2021-04-26T16:32:23.000Z</published>
    <updated>2021-05-06T04:11:25.298Z</updated>
    
    <content type="html"><![CDATA[<p>崔毅东C++程序设计——运算符重载的笔记。<span id="more"></span></p><h1 id="引入：平面向量类-2D-Vector-Class"><span class="post-title-index">1 </span><a href="#引入：平面向量类-2D-Vector-Class" class="headerlink" title="引入：平面向量类 2D Vector Class"></a>引入：平面向量类 2D Vector Class</h1><h2 id="在C-中描述平面向量"><span class="post-title-index">1.1 </span><a href="#在C-中描述平面向量" class="headerlink" title="在C++中描述平面向量"></a>在C++中描述平面向量</h2><ol><li><p>C++ STL vector: 变长数组</p></li><li><p>向量数据成员：</p><p> <em>double x, double y</em></p><p> <em>或者 std::array<double, 2> v_;</double,></em></p></li><li><p>运算</p><p> a. 数乘、点积</p><p> b. 求长度和方向</p><p> ​     <em>| (1, 2)| : √ ( 11 + 22)</em></p><p> ​     <em>dir (1, 2) : arctan ( 1/2 )</em></p></li><li><p>==, !=, &lt;, &lt;=, &gt;, &gt;=</p></li><li><p>类型转换：</p><ol><li>转为double，即求向量长度；</li><li>转为string</li></ol></li><li><p>负值</p></li><li><p>自加1，自减1</p></li></ol><h2 id="TDD开发设计方法"><span class="post-title-index">1.2 </span><a href="#TDD开发设计方法" class="headerlink" title="TDD开发设计方法"></a>TDD开发设计方法</h2><ol><li><p>Test-Driven Development (TDD),测试驱动开发</p><blockquote><p>一种开发设计方法，值得一看。Kent Beck 《测试驱动开发》</p></blockquote></li><li><p>步骤</p><p> (1)   先编写测试代码，而不是功能代码</p><p> (2)   编译运行测试代码，发现不能通过</p><p> (3)   做一些小小的改动（编写功能代码），尽快地让测试程序可运行</p><p> (4)   重构代码，优化设计</p></li></ol><h2 id="Vector-2D-类成员函数"><span class="post-title-index">1.3 </span><a href="#Vector-2D-类成员函数" class="headerlink" title="Vector 2D 类成员函数"></a>Vector 2D 类成员函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">atan</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的反正切值，以弧度为单位。有其他类型重载</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">double</span> x)</span></span>; <span class="comment">//返回x的平方根。有其它类型重载</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pow</span> <span class="params">(<span class="keyword">double</span> b, <span class="keyword">double</span> exp)</span></span>; <span class="comment">// 返回b的exp次方。有其它类型重载</span></span><br></pre></td></tr></table></figure><h1 id="重载运算符基本介绍"><span class="post-title-index">2 </span><a href="#重载运算符基本介绍" class="headerlink" title="重载运算符基本介绍"></a>重载运算符基本介绍</h1><h2 id="运算符与函数的异同"><span class="post-title-index">2.1 </span><a href="#运算符与函数的异同" class="headerlink" title="运算符与函数的异同"></a>运算符与函数的异同</h2><ol><li><p>运算符可以看做是函数</p></li><li><p>不同之处</p><p> （1） 语法有区别</p><p> （2） 不能自定义新的运算符，只能重载已经存在的运算符</p><p> （3） <strong>函数可overload, override产生任何想要的结果，但运算符作用于内置类型的行为不能修改</strong></p></li><li><p>函数式编程语言的观念——一切皆是函数【Haskell】</p></li><li><p>Emacs calculator软件</p></li></ol><h2 id="C-运算符函数"><span class="post-title-index">2.2 </span><a href="#C-运算符函数" class="headerlink" title="C++运算符函数"></a>C++运算符函数</h2><h3 id="可重载的运算符"><span class="post-title-index">2.2.1 </span><a href="#可重载的运算符" class="headerlink" title="可重载的运算符"></a>可重载的运算符</h3><ol><li><p>类型转换运算符：double, int, char, ……</p></li><li><p>new/delete, new []/delete[]</p></li><li><p>“”_suffix 用户自定义字面量运算符(自C++11起)</p></li><li><p>一般运算符:</p><p> <img src="https://i.loli.net/2021/05/06/MKTHDrqfknUy7t8.png" alt="QQ截图20210506113235" style="zoom: 50%;"></p></li></ol><h3 id="不可重载的运算符"><span class="post-title-index">2.2.2 </span><a href="#不可重载的运算符" class="headerlink" title="不可重载的运算符"></a>不可重载的运算符</h3><div class="table-container"><table><thead><tr><th>Operator</th><th style="text-align:left">Name</th></tr></thead><tbody><tr><td>.</td><td style="text-align:left">类属关系运算符</td></tr><tr><td>.*</td><td style="text-align:left">成员指针运算符</td></tr><tr><td>::</td><td style="text-align:left">作用域运算符</td></tr><tr><td>?:</td><td style="text-align:left">条件运算符</td></tr><tr><td>#</td><td style="text-align:left">预编译符号</td></tr></tbody></table></div><h3 id="运算符重载的限制"><span class="post-title-index">2.2.3 </span><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><ol><li>优先级和结合性不变</li><li>不可创造新的运算符</li></ol><h3 id="运算符函数"><span class="post-title-index">2.2.4 </span><a href="#运算符函数" class="headerlink" title="运算符函数"></a>运算符函数</h3><p><img src="https://i.loli.net/2021/05/06/tkHxceE5rpDMQYP.png" alt="QQ截图20210506113253"></p><p>【<strong>注意</strong>】</p><ol><li>v2作为<strong>参数</strong>传递给v1的operator函数</li><li>this指针的几个要点（见上图），调用v1 &lt; v2 时，this指向v1</li><li>传参的时候可以不用引用吗——可以</li><li>使用引用的好处——提高调用效率，不需要调用拷贝构造函数！</li></ol><h3 id="确定运算符的调用形式"><span class="post-title-index">2.2.5 </span><a href="#确定运算符的调用形式" class="headerlink" title="确定运算符的调用形式"></a>确定运算符的调用形式</h3><p><img src="https://i.loli.net/2021/05/06/jc7uy5ZGzi2CRos.png" alt="image-20210426215559462"></p><h2 id="左值、纯右值与将亡值"><span class="post-title-index">2.3 </span><a href="#左值、纯右值与将亡值" class="headerlink" title="左值、纯右值与将亡值"></a>左值、纯右值与将亡值</h2><h3 id="C-03-的左值和右值"><span class="post-title-index">2.3.1 </span><a href="#C-03-的左值和右值" class="headerlink" title="C++03 的左值和右值"></a>C++03 的左值和右值</h3><p>(1)   能放在等号左边的是lvalue</p><p>(2)   只能放在等号右边的是rvalue</p><p>(3)   lvalue可以作为rvalue使用</p><h3 id="C-11-的左值和右值"><span class="post-title-index">2.3.2 </span><a href="#C-11-的左值和右值" class="headerlink" title="C++11 的左值和右值"></a>C++11 的左值和右值</h3><ol><li><p><strong>左值</strong></p><ul><li><p>指定了一个函数或者对象，它是一个可以取地址的表达式</p></li><li><p>举例：</p><p>​    (1)   解引用表达式<em>p：&amp;(\</em>p)</p><p>​    (2)   字符串字面量”abc”：字符串存储在静态区，是有地址的，首地址是一个指针。</p><p>​    (3)   <strong>前置</strong>自增/自减表达式 ++i / —i：前置表达式操作过程是先对i进行自增自减运算，再取地址，&amp;(++i)等价于&amp;i。后置自增/自减表达式不能进行取地址操作</p><p>​    (4)   赋值或复合运算符表达式(x=y或m*=n等）</p></li></ul></li><li><p><strong>纯右值</strong></p><ul><li><p>纯右值：不和对象相关联的值(字面量)，或者其求值结果是字面量或者一个匿名的临时对象</p></li><li><p>举例：</p><p>  (1)   除字符串字面量以外的字面量，比如 32, ‘a’</p><p>  (2)   返回非引用类型的函数调用 int f() { return 1;}</p><p>  (3)   后置自增/自减表达式 i++/i—</p><p>  (4)   算术/逻辑/关系表达式（a+b、a&amp;b、a&lt;<b）（a&&b、a||b、~a）（a==b、a>=b、a&lt;b）</b）（a&&b、a||b、~a）（a==b、a></p><p>  (5)   取地址（&amp;x）</p></li></ul></li><li><p><strong>左值可以当成右值使用</strong></p></li></ol><h3 id="C-11-将亡值"><span class="post-title-index">2.3.3 </span><a href="#C-11-将亡值" class="headerlink" title="C++11 将亡值"></a>C++11 将亡值</h3><ol><li><p>将亡值：将亡值也指定了一个对象，是一个将纯右值转换为<strong>右值引用</strong>的表达式</p><ul><li>右值引用：int<strong>&amp;&amp;</strong> rvr1{ 22 };</li><li><p>举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prv</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> <span class="number">6</span> * x; &#125; <span class="comment">// pure rvalue </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span>&amp; lvr5&#123; <span class="number">21</span> &#125;; <span class="comment">// 常量左值引用可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp; lvr6&#123; <span class="number">22</span> &#125;; <span class="comment">// 错！非常量左值引用不可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp;&amp; rvr1&#123; <span class="number">22</span> &#125;; <span class="comment">// 右值引用可以引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp; lvr7&#123; <span class="built_in">prv</span>(<span class="number">2</span>) &#125;; <span class="comment">// 错！非常量左值引用不可引用纯右值</span></span><br><span class="line">      <span class="keyword">int</span>&amp;&amp; rvr2&#123; <span class="built_in">prv</span>(<span class="number">2</span>) &#125;; <span class="comment">// 右值引用普通函数返回值</span></span><br><span class="line">      rvr1 = ++rvr2; <span class="comment">// 右值引用做左值使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右值引用可以看作延续了纯右值的生命期，比如line7，原本执行完prv(2)之后返回值就找不到了，使用右值引用就可以继续对返回值进行修改，比如line8。</p></li></ul></li></ol><h1 id="重载实例"><span class="post-title-index">3 </span><a href="#重载实例" class="headerlink" title="重载实例"></a>重载实例</h1><h2 id="重载一般二元算术运算符"><span class="post-title-index">3.1 </span><a href="#重载一般二元算术运算符" class="headerlink" title="重载一般二元算术运算符"></a>重载一般二元算术运算符</h2><h3 id="调用一般二元运算符"><span class="post-title-index">3.1.1 </span><a href="#调用一般二元运算符" class="headerlink" title="调用一般二元运算符"></a>调用一般二元运算符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vec2D a&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, b&#123;<span class="number">3</span>, <span class="number">6</span>&#125;; <span class="keyword">double</span> z &#123;<span class="number">1.3</span>&#125;;</span><br><span class="line">Vec2D c = a + b;  <span class="comment">// a.operator+(b); à Vec2D Vec2D::operator+(Vec2D);</span></span><br><span class="line">Vec2D d = a + z;  <span class="comment">// a.operator+(z); à Vec2D Vec2D::operator+(double);</span></span><br><span class="line">Vec2D e = z + b;  <span class="comment">// z.operator+(b); à Vec2D double::operator+(Vec2D);错误！</span></span><br></pre></td></tr></table></figure><p>【注意】最后一行错误原因：double 类型是内建类型，其运算符不能被重载</p><h3 id="函数原型"><span class="post-title-index">3.1.2 </span><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2D</span> &#123;</span></span><br><span class="line">  Vec2D <span class="keyword">operator</span> +(Vec2D);                <span class="comment">//成员函数</span></span><br><span class="line">  Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>);               <span class="comment">//成员函数</span></span><br><span class="line">  <span class="keyword">friend</span> Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>, Vec2D); <span class="comment">//非成员函数，友元函数    </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vec2D <span class="keyword">operator</span> +(<span class="keyword">double</span>, Vec2D) &#123; <span class="comment">// Do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】友元函数需要两个参数，不能像成员函数一样默认本对象为调用者</p><h3 id="关于返回值"><span class="post-title-index">3.1.3 </span><a href="#关于返回值" class="headerlink" title="关于返回值"></a>关于返回值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Matrice Matrice::<span class="keyword">operator</span>+(<span class="keyword">const</span> Matrice&amp; second_m) <span class="keyword">const</span> &#123;</span><br><span class="line">    Matrice resultMatrice&#123; <span class="keyword">this</span>-&gt;lines, <span class="keyword">this</span>-&gt;rows &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">this</span>-&gt;lines); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">this</span>-&gt;rows); j++) &#123;</span><br><span class="line">            (resultMatrice.matricePointer)[i][j] =</span><br><span class="line">                (<span class="keyword">this</span>-&gt;matricePointer)[i][j] + (second_m.matricePointer)[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultMatrice; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】类内如果有指针成员，在返回的时候一定要格外小心深拷贝、浅拷贝。</p><p>如果要用上面代码实现矩阵加法的重载，一定要先重载拷贝构造函数，将默认的浅拷贝重载成深拷贝的方式，不然将会出现内存泄漏——也就是直接返回了 resultMatrice 这个局部对象，而+运算的函数体结束后这个对象会立刻被析构，其中的矩阵指针也会立刻被释放，这时继续使用返回值里的矩阵指针，显然是内存泄漏！！</p><h3 id="举例"><span class="post-title-index">3.1.4 </span><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">Vec2D v2 = v1 + <span class="built_in">Vec2D</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1 is &quot;</span> &lt;&lt; v1.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2 is &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="重载复合二元算术运算符（-and-）"><span class="post-title-index">3.2 </span><a href="#重载复合二元算术运算符（-and-）" class="headerlink" title="重载复合二元算术运算符（+=, -=, *=, and /=）"></a>重载复合二元算术运算符（+=, -=, *=, and /=）</h2><h3 id="复合运算符操作的特殊之处"><span class="post-title-index">3.2.1 </span><a href="#复合运算符操作的特殊之处" class="headerlink" title="复合运算符操作的特殊之处"></a>复合运算符操作的特殊之处</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">v1 += v2; <span class="comment">// 语句执行后，v1的值被改变了（这非常重要！！）</span></span><br><span class="line">v1 = v1 + v2;</span><br></pre></td></tr></table></figure><h3 id="复合运算符的重载"><span class="post-title-index">3.2.2 </span><a href="#复合运算符的重载" class="headerlink" title="复合运算符的重载"></a>复合运算符的重载</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Vec2D Vec2D::<span class="keyword">operator</span> +=(<span class="keyword">const</span> Vec2D&amp; secondVec2D ) &#123;</span><br><span class="line">    *<span class="keyword">this</span> = <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D); <span class="comment">//add函数返回临时的匿名对象，这个对象被赋给this指针</span></span><br><span class="line"> <span class="keyword">return</span> (*<span class="keyword">this</span>); <span class="comment">//返回解引用的this指针，也就是返回了this指向的对象</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">Vec2D <span class="title">Vec2D::add</span><span class="params">(<span class="keyword">const</span> Vec2D&amp; secondVec2D)</span> </span>&#123; <span class="comment">//prvalue</span></span><br><span class="line"> <span class="keyword">double</span> m = x_ + secondVec2D.<span class="built_in">getX</span>()</span><br><span class="line"> <span class="keyword">double</span> n = y_ + secondVec2D.y_;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">Vec2D</span>(m, n); <span class="comment">//返回临时的匿名对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果将以上代码对应v1+=v2; 则有：</p><ul><li>secondVec2D 是 v2</li><li>(*this) 是改变后的 v1</li></ul></li><li><p>如果将</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">this</span> = <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D);</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>  修改为：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">add</span>(secondVec2D);</span><br></pre></td></tr></table></figure><p>  这个重载是否还有效？</p></li></ul><h3 id="举例-1"><span class="post-title-index">3.2.3 </span><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v2</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">v2 += <span class="built_in">Vec2D</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2 is &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h2 id="重载数组下标运算符"><span class="post-title-index">3.3 </span><a href="#重载数组下标运算符" class="headerlink" title="重载数组下标运算符"></a>重载数组下标运算符</h2><h3 id="重载-运算符"><span class="post-title-index">3.3.1 </span><a href="#重载-运算符" class="headerlink" title="重载[]运算符"></a>重载[]运算符</h3><ul><li><p>为什么重载[]运算符</p></li><li><p>[]重载后可用类似数组的语法格式访问对象内容</p></li><li><p>重载代码示例</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vec2D v &#123;<span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v.x_: &quot;</span> &lt;&lt; v[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;v.y_: &quot;</span> &lt;&lt; v[<span class="number">1</span>] &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> Vec2D::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (index == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> y_;</span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;index out of bound&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*这种重载方法只能读取数据*/</span></span><br></pre></td></tr></table></figure><h3 id="数组下标运算符作为访问器和修改器"><span class="post-title-index">3.3.2 </span><a href="#数组下标运算符作为访问器和修改器" class="headerlink" title="数组下标运算符作为访问器和修改器"></a>数组下标运算符作为访问器和修改器</h3></li></ul><ol><li><p>访问器和修改器：作为访问器就是用[]运算符读取数据，修改器就是用[]运算符修改数据</p></li><li><p>使r2[]成为左值的方法：使[]返回一个引用</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>&amp; Vec2D::<span class="keyword">operator</span>[](<span class="keyword">const</span> <span class="keyword">int</span> &amp;index) &#123; <span class="comment">//lvalue</span></span><br><span class="line">  <span class="keyword">if</span> (index == <span class="number">0</span>)</span><br><span class="line">      <span class="keyword">return</span> x_;  <span class="comment">//x_ can be modified</span></span><br><span class="line">      <span class="comment">//...... Now, the Vec2D class is mutable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>​    </p><h2 id="重载一元运算符"><span class="post-title-index">3.4 </span><a href="#重载一元运算符" class="headerlink" title="重载一元运算符"></a>重载一元运算符</h2><h3 id="单目运算符"><span class="post-title-index">3.4.1 </span><a href="#单目运算符" class="headerlink" title="单目运算符"></a>单目运算符</h3><ol><li><p>主要的单目运算符：—, ++, -（负号）, *（解引用）</p></li><li><p>编译器执行过程：</p><ul><li><p>若operator @是在obj的类的<strong>成员函数</strong>，则调用obj.operator @()【无参数】</p></li><li><p>若operator @是obj的类的<strong>友元函数</strong>，则调用operator @(obj)</p></li></ul></li></ol><h3 id="重载负号运算符"><span class="post-title-index">3.4.2 </span><a href="#重载负号运算符" class="headerlink" title="重载负号运算符"></a>重载负号运算符</h3><h4 id="调用"><span class="post-title-index">3.4.2.1 </span><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Vec2D v2 = -v1;  <span class="comment">// 向量v1求负值；v1的值不变</span></span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">toString</span>();</span><br></pre></td></tr></table></figure><h4 id="重载负号运算符-1"><span class="post-title-index">3.4.2.2 </span><a href="#重载负号运算符-1" class="headerlink" title="重载负号运算符"></a>重载负号运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vec2D* Vec2D::<span class="keyword">operator</span>-()&#123;</span><br><span class="line">    <span class="keyword">return</span> *Vec2D*(-<span class="keyword">this</span>-&gt;x_**,** **-**<span class="keyword">this</span>-&gt;y_); <span class="comment">// 返回匿名临时对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载-和-运算符"><span class="post-title-index">3.4.3 </span><a href="#重载-和-运算符" class="headerlink" title="重载++和- -运算符"></a>重载++和- -运算符</h3><h4 id="前置、后置运算符与操作顺序"><span class="post-title-index">3.4.3.1 </span><a href="#前置、后置运算符与操作顺序" class="headerlink" title="前置、后置运算符与操作顺序"></a>前置、后置运算符与操作顺序</h4><ul><li><p>前置：先增减后取值，表达式是lvalue</p></li><li><p>后置：先取值（存在某个地方）后增减，表达式是prvalue（纯右值）</p><ul><li>举例：<ul><li>b = (a++) / 2 这一算式中，会先把a的值取出来放到某处，假设为temp（temp将被用于参加整个表达式的后续计算），之后a会被+1，a的值被改变。</li><li>b = (++a) / 2 这一算式，则直接将a值+1，并用a进行后续计算，没有temp这一环节。</li></ul></li><li>代码示例：</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1: &quot;</span> &lt;&lt; v1.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">//v1: (3, 4)</span></span><br><span class="line">Vec2D v2 = ++v1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2: &quot;</span> &lt;&lt; v2.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v2: (3, 4)</span></span><br><span class="line"><span class="function">Vec2D <span class="title">v3</span><span class="params">(<span class="number">2</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Vec2D v4 = v3++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v3: &quot;</span> &lt;&lt; v3.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v3: (3, 4)</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v4: &quot;</span> &lt;&lt; v4.<span class="built_in">toString</span>() &lt;&lt; endl; <span class="comment">// v4: (2, 3)</span></span><br></pre></td></tr></table></figure><h4 id="前置与后置在函数定义中的区别"><span class="post-title-index">3.4.3.2 </span><a href="#前置与后置在函数定义中的区别" class="headerlink" title="前置与后置在函数定义中的区别"></a>前置与后置在函数定义中的区别</h4><p><img src="https://i.loli.net/2021/05/06/jc7uy5ZGzi2CRos.png" alt="image-20210426215559462"></p><ul><li><p>前置++/—重载无参数，返回引用类型</p></li><li><p>后置++/—重载带参数——“dummy”</p><ul><li>这个参数用于表示这是一个后置运算符，实际调用的时候并不会传参</li></ul></li><li>若在类外定义，则不论前置后置都需要参数</li></ul><h4 id="重载实例-1"><span class="post-title-index">3.4.3.3 </span><a href="#重载实例-1" class="headerlink" title="重载实例"></a>重载实例</h4><ul><li>前置++运算符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vec2D&amp; Vec2D::<span class="keyword">operator</span>++()&#123;</span><br><span class="line">    x_ += <span class="number">1</span>;</span><br><span class="line">    y_ += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回对象本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后置++运算符</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vec2D Vec2D::<span class="keyword">operator</span>++(<span class="keyword">int</span> dummy)&#123;</span><br><span class="line">    <span class="function">Vec2D <span class="title">temp</span><span class="params">(<span class="keyword">this</span>-&gt;x_, <span class="keyword">this</span>-&gt;y_)</span></span>;</span><br><span class="line">    x_ += <span class="number">1</span>;</span><br><span class="line">    y_ += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">//返回的是未自增的对象，是一个纯右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>两条返回语句的不同</strong>导致了前置++和后置++的区别</li></ul><h2 id="重载流插入-lt-lt-提取-gt-gt-运算符"><span class="post-title-index">3.5 </span><a href="#重载流插入-lt-lt-提取-gt-gt-运算符" class="headerlink" title="重载流插入(&lt;&lt;)/提取(&gt;&gt;)运算符"></a>重载流插入(&lt;&lt;)/提取(&gt;&gt;)运算符</h2><h3 id="重载-lt-lt-gt-gt-的目的"><span class="post-title-index">3.5.1 </span><a href="#重载-lt-lt-gt-gt-的目的" class="headerlink" title="重载&lt;&lt;/&gt;&gt;的目的"></a>重载&lt;&lt;/&gt;&gt;的目的</h3><p>能够把对象信息直接输出，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; vec2d;</span><br><span class="line">cin &gt;&gt; vec2d;</span><br></pre></td></tr></table></figure><h3 id="重载为友元函数"><span class="post-title-index">3.5.2 </span><a href="#重载为友元函数" class="headerlink" title="重载为友元函数"></a>重载为友元函数</h3><ol><li><p>为什么不能重载为成员函数</p><p> 运算符重载为类成员函数后，当调用该运算符时，左操作数必须是该类的实例。若&lt;&lt;和&gt;&gt;重载为成员函数，则只能用 v1&lt;&lt;cout; 如下所示：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*重载为成员函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vec2D</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream);</span><br><span class="line">    istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;stream);</span><br><span class="line">&#125;;</span><br><span class="line">Vec2D v1;</span><br><span class="line">v1 &lt;&lt; cout; <span class="comment">//Vec2D对象只能作为第一个操作数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*重载为友元函数*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vec2D</span> &#123;</span> </span><br><span class="line">  <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;stream, Vec2D &amp;v);</span><br><span class="line">  <span class="keyword">friend</span> istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;stream, Vec2D &amp;v);</span><br><span class="line">&#125;;</span><br><span class="line">Vec2D v1;</span><br><span class="line">cout &lt;&lt; v1; <span class="comment">//更符合编程习惯</span></span><br></pre></td></tr></table></figure></li><li><p>为什么友元函数的返回值是<strong>ostream&amp;</strong>类型</p><p> 要实现cout&lt;&lt;x&lt;&lt;y; 这类<strong>连续输出</strong>的代码，想要输出y，cout&lt;&lt;x这一部分应该返回一个ostream类型，所以使用ostream&amp;作为返回值</p><blockquote><p>返回ostream类型与&amp;有什么联系？为什么一定是&amp;呢</p></blockquote></li></ol><h2 id="重载对象转换运算符"><span class="post-title-index">3.6 </span><a href="#重载对象转换运算符" class="headerlink" title="重载对象转换运算符"></a>重载对象转换运算符</h2><h3 id="重载目的"><span class="post-title-index">3.6.1 </span><a href="#重载目的" class="headerlink" title="重载目的"></a>重载目的</h3><ul><li>将Vec2D对象转换为double数时，我们可以求该对象的范数，也就是向量长度</li></ul><h3 id="重载实例-2"><span class="post-title-index">3.6.2 </span><a href="#重载实例-2" class="headerlink" title="重载实例"></a>重载实例</h3><ul><li>类型转换函数：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D::<span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> </span>&#123; <span class="comment">//操作符名称和要转到的类型同名，类似于构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">magnitude</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>调用实例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vec2D <span class="title">v1</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> d = v1 + <span class="number">5.1</span>; <span class="comment">// d: 10.1</span></span><br><span class="line"><span class="keyword">double</span> e = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(v1);  <span class="comment">// e: 5.0</span></span><br></pre></td></tr></table></figure><h2 id="重载赋值运算符"><span class="post-title-index">3.7 </span><a href="#重载赋值运算符" class="headerlink" title="重载赋值运算符"></a>重载赋值运算符</h2><p><a href="https://www.icourse163.org/learn/BUPT-1003564002?tid=1461043448#/learn/content?type=detail&amp;id=1237770721&amp;cid=1257884782">C++程序设计（面向对象进阶）_中国大学MOOC(慕课) (icourse163.org)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;崔毅东C++程序设计——运算符重载的笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="专业" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/"/>
    
    <category term="语言学习" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="C++" scheme="http://thatmee.github.io/categories/%E4%B8%93%E4%B8%9A/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C/"/>
    
    
    <category term="C++" scheme="http://thatmee.github.io/tags/C/"/>
    
  </entry>
  
</feed>
